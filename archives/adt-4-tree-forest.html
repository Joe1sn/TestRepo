<!DOCTYPE html>
<head>
<meta charset="UTF-8" /><title>PureWeb Blog-数据结构与算法-4.树和森林</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>  <script>    document.querySelectorAll('code').forEach((code) => {      if (!code.classList.length) {        code.classList.add('language-bash');      }    });  </script>	<script>		document.addEventListener('DOMContentLoaded', (event) => {			hljs.highlightAll();		});	</script><link rel="stylesheet" href="../github.css">
<link rel="stylesheet" href="../speciou.css"
</head><body>    <div class="container">        <header class="main-header">            <h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabinet</a></h1>            <nav class="main-header__nav">                <ul class="main-nav">                    <li class="main-nav__list"><a class="main-nav__list__link active" href="/" target="_self">HOME</a>                    </li>                    <li class="main-nav__list"><a class="main-nav__list__link" href="/archives/"                            target="_self">ARCHIVE</a>                    </li>                    <li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn"                            target="_blank">GITHUB</a></li>                </ul>            </nav>        </header>    </div><div class="typora-export os-windows"><div id="write" class>
<p><strong>2022-06-25 18:53:45</strong></p>
<h1>数和二叉树</h1>
<blockquote>
<p>This chapter contains lots of definations and very complex concepts</p>
<p>So this README file is in Chinese(my native laguage), there will be english version few months later</p>
</blockquote>
<blockquote>
<p>full project can see	 here: https://github.com/Joe1sn/ADT</p>
<p>this is first note in english</p>
</blockquote>
<!-- more -->
<h1>树</h1>
<h2>定义</h2>
<p>包括$n$个节点的有限集合$D$，$R$是$D$中元素构成的序偶集合</p>
<ul>
<li>每个节点都只有有限个子节点或无子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
<li>树里面没有环路(cycle)</li>
</ul>
<h2>术语</h2>
<ol>
<li><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度；</li>
<li><strong>树的度</strong>：一棵树中，最大的节点度称为树的度；</li>
<li><strong>叶节点</strong>或<strong>终端节点</strong>：度为零的节点；</li>
<li><strong>非终端节点</strong>或<strong>分支节点</strong>：度不为零的节点；</li>
<li><strong>父亲节点</strong>或<strong>父节点</strong>：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li><strong>孩子节点</strong>或<strong>子节点</strong>：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li><strong>兄弟节点</strong>：具有相同父节点的节点互称为兄弟节点；</li>
<li>节点的<strong>层次</strong>：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li><strong>深度</strong>：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；</li>
<li><strong>高度</strong>：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；</li>
<li><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟；</li>
<li><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；</li>
<li><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
<li><strong>森林</strong>：由m（m&gt;=0）棵互不相交的树的集合称为森林；</li>
</ol>
<h1>二叉树</h1>
<p>就是度小于2的树</p>
<h2>性质</h2>
<ul>
<li>
<p>第 $i$ 层最多有 $2^{i-1}$ 个节点</p>
</li>
<li>
<p>高度为 $h$ 的二叉树最多有 $2^h-1$ 个节点</p>
</li>
<li>
<p>包含 $n$ 个节点的二叉树高度至少为 $log_2{n+1}$，最多为 $n$</p>
</li>
<li>
<p>任意一棵二叉树中，叶子节点数目为 $n_0$ ，度为 $2$ 的节点数为 $n_2$ ，则 $n_0=n_2+1$</p>
<p>证明：</p>
<p>​	设二叉树共有 $n$ 个节点，度为1的节点数为 $n_1$ 。
二叉树中仅仅只有度为$0,1,2$的节点，所以 $n=n_0+n_1+n_2$</p>
<p>​	设该二叉树共有 $B$ 条边，除了根节点其他至少有1条边，得到 $B=n-1$ ,$B=n_1+2n_2$
三式可得: $n_0=n_2+1$</p>
</li>
<li>
<p>如果高度为 $h$ 的二叉树有 $2^h-1$ 个节点称为 <strong>满二叉树</strong></p>
</li>
<li>
<p>二叉树只有最小面两层叶节点度小于2，最下层节点集中在靠左的若干位置上，这样二叉树就为<strong>完全二叉树</strong></p>
</li>
<li>
<p>不存在度为1的树叫做 <strong>2-数</strong></p>
</li>
<li>
<p>具有 $n$ 个节点的完全二叉树的高度为 $[log_2(n+1)]$</p>
<p>对于完全二叉树的前 $h-1$ 层为满二叉树，有 $2^{h-1}-1$ 个节点
最下层最多有节点个数不超过 $2^{h-1}$</p>
<ul>
<li>$2^{h-1} \lt n \le 2^{h-1}-1$</li>
<li>$h-1 \lt log_2(n+1) \le h$</li>
</ul>
<p>所以 $h$ 是不小于 $log_2(n+1)$ 的最小整数</p>
</li>
</ul>
<h2>ADT</h2>
<ul>
<li>
<p>数据</p>
<p>节点的有限集合，要么为空，要么为一个根节点个两个子节点，两个子节点也是二叉树</p>
</li>
<li>
<p>算法</p>
<p><code>create(bt)</code>: 构造一棵空二叉树bt。
<code>new_node(x，ln，rn)</code>: 创建一个新结点，该结点的值为x，ln和rn为该结点的左右孩子结点。
<code>IsEmpty(bt)</code>:若二叉树bt为空，则返回TRUE，否则返回FALSE。
<code>tree_clear(bt)</code>:清除二叉树bt中的所有结点，使之成为空二叉树。
<code>root(bt，x)</code>:若二叉树bt非空，则用x返回其根结点的值，并返回TRUE，否则返回FALSE。
<code>make_tree(bt，x，left，right)</code>:构造一棵二叉树bt，根结点的值为x，以left和right为该根结点的左右子树。<code>preorder_tree(bt)</code>: 先序遍历二叉树bt。
<code>inorder_tree(bt)</code>: 中序遍历二叉树bt。
<code>postOrder_tree(bt)</code>: 后序遍历二叉树bt。
<code>levelorder_tree(bt)</code>: 层次遍历二叉树bt。</p>
</li>
</ul>
<p><strong>节点结构体</strong></p>
<pre><code class="language-c">typedef struct bt_node
{
    element_type element;
    struct bt_node *l_child;
    struct bt_node *r_child;
    
}bt_node;
</code></pre>
<p><strong>树结构体</strong></p>
<h3>create</h3>
<p><code>create(bt)</code>: 构造一棵空二叉树bt</p>
<pre><code class="language-c">void create(bin_tree * bt){
    bt-&gt;root = NULL;
}
</code></pre>
<h3>new_node</h3>
<p><code>new_node(x，ln，rn)</code>: 创建一个新结点，该结点的值为x，ln和rn为该结点的左右孩子结点。</p>
<pre><code class="language-c">bt_node *new_node(element_type x, bt_node *ln, bt_node *rn){
    bt_node *p = (bt_node *)malloc(sizeof(bt_node));
    p-&gt;element = x;
    p-&gt;l_child = ln;
    p-&gt;r_child = rn;
    return p;
}
</code></pre>
<h3>is_empty</h3>
<p><code>is_empty(bt)</code>:若二叉树bt为空，则返回TRUE，否则返回FALSE。</p>
<pre><code class="language-c">BOOL is_empty(bin_tree *bt){
    if(bt-&gt;root == NULL)
        return true;
    return false;
}
</code></pre>
<h3>root</h3>
<p><code>root(bt，x)</code>:若二叉树bt非空，则用x返回其根结点的值，并返回TRUE，否则返回FALSE。</p>
<pre><code class="language-c">BOOL root(bin_tree *bt, element_type *x){
    if (bt-&gt;root)
    {
        *x = bt-&gt;root-&gt;element;
        return true;
    }
    return false;
}
</code></pre>
<h3>make_tree</h3>
<p><code>make_tree(bt，x，left，right)</code>:构造一棵二叉树bt，根结点的值为x，以left和right为该根结的左右子树。</p>
<pre><code class="language-c">void make_tree(bin_tree *bt, element_type e, bin_tree *ln, bin_tree *rn){
    if(bt-&gt;root || ln == rn)
        return;
    bt-&gt;root = new_node(e, ln-&gt;root, rn-&gt;root);
    ln-&gt;root = rn-&gt;root = NULL;
}
</code></pre>
<h1>二叉树遍历</h1>
<p>要实现的功能</p>
<p><code>preorder_tree(bt)</code>: 先序遍历二叉树bt。
<code>inorder_tree(bt)</code>: 中序遍历二叉树bt。
<code>postOrder_tree(bt)</code>: 后序遍历二叉树bt。
<code>levelorder_tree(bt)</code>: 层次遍历二叉树bt。</p>
<h2>递归遍历</h2>
<p>既然每个子节点都是一个树，那为什么不用递归去遍历呢？</p>
<p>先不考虑二叉树为空的情况，有以下的递归遍历方法</p>
<ul>
<li>
<p><strong>先序遍历(VLR)</strong></p>
<p>根节点 -&gt; 先序遍历(左子树) -&gt; 先序遍历(右子树)</p>
</li>
<li>
<p><strong>中序遍历(LVR)</strong></p>
<p>中序遍历(左子树) -&gt; 根节点 -&gt; 中序遍历(右子树)</p>
</li>
<li>
<p><strong>后序遍历(LRV)</strong></p>
<p>后序遍历(左子树) -&gt; 后序遍历(右子树) -&gt; 根节点</p>
</li>
</ul>
<p><img src="https://img.joe1sn.top/uploads/big/c65e72c38fea85c82609f549b6059904.jpg" alt="" /></p>
<p>尝试用递归的思想理解</p>
<h3>先序遍历</h3>
<p><code>preorder_tree(bt)</code>: 先序遍历二叉树bt。</p>
<pre><code class="language-c">void preorder_tree(bin_tree *bt){
    preorde(bt);
}
//VLR
void preorder(bt_node *bn){
    if (!bn)
        return;
    printf(&quot;%c&quot;,bn-&gt;element);
    printf(&quot;%c&quot;,preorde(bn-&gt;l_child));
    printf(&quot;%c&quot;,preorde(bn-&gt;r_child));
}
</code></pre>
<h3>中序遍历</h3>
<p><code>inorder_tree(bt)</code>: 中序遍历二叉树bt。</p>
<pre><code class="language-c">//VLR
void preorder_tree(bin_tree *bt){
    preorder(bt-&gt;root);
}
void preorder(bt_node *bn){
    if (!bn)
        return;
    printf(&quot;%c &quot;,bn-&gt;element);
    preorder(bn-&gt;l_child);
    preorder(bn-&gt;r_child);
}

//LVR
void inorder_tree(bin_tree *bt){
    inorder(bt-&gt;root);
}
void inorder(bt_node *bn){
    if (!bn)
        return;
    inorder(bn-&gt;l_child);
    printf(&quot;%c &quot;,bn-&gt;element);
    inorder(bn-&gt;r_child);
}
</code></pre>
<h3>后序遍历</h3>
<p><code>postOrder_tree(bt)</code>: 后序遍历二叉树bt。</p>
<pre><code class="language-c">//LVR
void inorder_tree(bin_tree *bt){
    inorder(bt-&gt;root);
}
void inorder(bt_node *bn){
    if (!bn)
        return;
    inorder(bn-&gt;l_child);
    printf(&quot;%c &quot;,bn-&gt;element);
    inorder(bn-&gt;r_child);
}
</code></pre>
<h3>小测试</h3>
<p>注意：我们还没有写回收函数，只能让程序退出时操作系统回收内存，但是这里仅仅只验证遍历算法是否正确</p>
<ol>
<li>
<p>构建二叉树</p>
<pre><code class="language-c">    bin_tree a,b,x,y,z;
    create(&amp;a);
    create(&amp;b);
    create(&amp;x);
    create(&amp;y);
    create(&amp;z);

    make_tree(&amp;y,'E',&amp;a,&amp;b);
    make_tree(&amp;z,'F',&amp;a,&amp;b);
    make_tree(&amp;x,'C',&amp;y,&amp;z);
    make_tree(&amp;y,'D',&amp;a,&amp;b);
    make_tree(&amp;z,'B',&amp;y,&amp;x);
</code></pre>
<p>虽然这里<code>bin_tree</code>都是保存在栈上面的，但是</p>
<p><code>make_tree</code>调用的<code>new_node</code>节点是使用的<code>malloc</code>函数分配的，所以节点的链接是不会改变的</p>
<pre><code class="language-c">bt_node *new_node(element_type x, bt_node *ln, bt_node *rn){
    bt_node *p = (bt_node *)malloc(sizeof(bt_node));
    p-&gt;element = x;
    p-&gt;l_child = ln;
    p-&gt;r_child = rn;
    return p;
}
</code></pre>
<p>关于调用过程</p>
<p><img src="https://img.joe1sn.top/uploads/big/ce0f1f6ebad4dce248be7aa39a1bd2a3.jpg" alt="" /></p>
</li>
<li>
<p>遍历二叉树</p>
<pre><code class="language-c">    printf(&quot;preorder: &quot;);
    preorder_tree(&amp;z);

    printf(&quot;\ninorder: &quot;);
    inorder_tree(&amp;z);

    printf(&quot;\npostorder: &quot;);
    postorder_tree(&amp;z);
    printf(&quot;\n&quot;);
</code></pre>
<p>那么</p>
<ul>
<li>先序遍历：BDCEF</li>
<li>中序遍历：DBECF</li>
<li>后序遍历：DEFCB</li>
</ul>
<p>结果</p>
<pre><code>preorder: B D C E F
inorder: D B E C F
postorder: D E F C B
</code></pre>
<p>发现没有问题</p>
</li>
</ol>
<h3>层次遍历</h3>
<p>每次从左到右访问该二叉树的元素，上面的例子使用层次遍历的话就为:<code>BDCEF</code></p>
<ol>
<li>若二叉树为空，退出；初始化队列Q，根节点入队</li>
<li>队列不为空：
<ol>
<li>获取队列头中的节点<code>p</code>，将头元素出队</li>
<li>访问节点<code>p</code>中元素</li>
<li>若左节点存在，左节点进队</li>
<li>若右节点存在，右节点进队</li>
</ol>
</li>
<li>退出</li>
</ol>
<p><code>levelorder_tree(bt)</code>: 层次遍历二叉树bt。</p>
<pre><code class="language-c">void level_order_tree(bin_tree *bt){
    if (!bt-&gt;root)
        return;
    queue q;
    create_q(&amp;q,100);
    bt_node *bn;
    en_queue(&amp;q, bt-&gt;root);

    while(!is_q_empty(&amp;q))
    {
        
        front(&amp;q,bn);
        de_queue(&amp;q);
        int i;
        printf(&quot;%c &quot;,bn-&gt;element);
        if(bn-&gt;l_child)
            en_queue(&amp;q,bn-&gt;l_child);
        if(bn-&gt;r_child)
            en_queue(&amp;q,bn-&gt;r_child);
    }
    destroy(&amp;q);
}
</code></pre>
<h2>遍历的应用</h2>
<h3>计算二叉树节点的个数</h3>
<p>使用任意一种方式，存在则总数+1，也可递归使用<code>size(bin_tree)</code>函数</p>
<pre><code class="language-c">int tree_size(bin_tree *bt){
    return size(bt-&gt;root);
}
int size(bt_node *bn){
    if (!bn)
        return 0;
    return size(bn-&gt;l_child)+size(bn-&gt;r_child)+1;
}
</code></pre>
<h3>清空二叉树</h3>
<pre><code class="language-c">void tree_clear(bin_tree *bt){
    tclear(bt-&gt;root);
    bt-&gt;root=NULL;
}

void tclear(bt_node *bn){
    if(!bn)
        return;
    tclear(bn-&gt;l_child);
    tclear(bn-&gt;r_child);
    free(bn);
}
</code></pre>
<h3>先序构建二叉树</h3>
<p>之前的二叉树</p>
<p><img src="https://img.joe1sn.top/uploads/big/70a44a2742499a15ee87317b0f73cccd.jpg" alt="" /></p>
<p>先序遍历的顺序是：<strong>B D C E F</strong>。那么如何反向构建一颗二叉树？</p>
<p>为了区别叶子节点，叶子结点的两个子节点均为NULL，使用<code>#</code>表示，那么上面的顺序就为<code>BD##CE##F##</code>
<img src="https://img.joe1sn.top/uploads/big/e7167b15172cba652769098b0a14b6a2.jpg" alt="" /></p>
<pre><code class="language-c">bt_node *pre_create(bt_node *bn){
    char ch;
    ch=getchar();
    if(ch=='#')
        bn=NULL; //create null node
    else
    {
        bn = (bt_node*)malloc(sizeof(bt_node));
        bn-&gt;element = ch;
        bn-&gt;l_child=pre_create(bn-&gt;l_child);
        bn-&gt;r_child=pre_create(bn-&gt;r_child);
    }
    printf(&quot;pre_creating\n&quot;);
    return bn;
}
void pre_make(bin_tree *bt){
    bt-&gt;root=pre_create(bt-&gt;root);
    printf(&quot;pre_make\n&quot;);
}
</code></pre>
<p>使用递归同样可以做到交换左右子树、求二叉树高度等</p>
<h2>非递归遍历</h2>
<p>递归其实是一种非常浪费空间的方法，递归深度过高会导致内存耗尽。所以一般希望使用它的迭代版本</p>
<p>二叉树作为一种非线性结构，在进行递归访问的时候我们利用程序的栈来实现对另外一侧节点的访问。如果我们想要线性地、能迭代的访问二叉树就不洗自己实现这种功能，这种保存的信息叫做“线索”，这样就可以定义一颗线索二叉树了。</p>
<p>不过这里不用线索二叉树，大致讲下思路</p>
<p>很明显为了保存这些信息我们需要一个堆栈<code>s</code>保存待访问的节点</p>
<p>对该二叉树</p>
<p><img src="https://img.joe1sn.top/uploads/big/6c7f71cf4485a160dbff13ec823c80b4.jpg" alt="" /></p>
<ul>
<li>
<p>先序遍历(VLR)</p>
<pre><code class="language-fake_python">s=stack()
p=root
s.push(p)
while(p!=NULL or !is_empty(s)):
	print(s.top-&gt;value)
	s.pop()
	if p-&gt;rchild:
		s.push(p-&gt;rchild)
	elif -&gt;lchild:
		s.push(p-&gt;lchild)
</code></pre>
</li>
<li>
<p>中序遍历(LVR)</p>
<pre><code class="language-fake_python">s=stack()
p=root
s.push(p)
p=p-&gt;left
while(p!=NULL or !is_empty(s)):
	while(p):
		s.push(p) #此处可以让右节点入栈
		p=p-&gt;lchild
	print(s.top()-&gt;value)
	p=s.top()
	s.pop()
	p=p-&gt;rchild
</code></pre>
<p>回溯的时候右节点入栈</p>
</li>
<li>
<p>后序遍历(LRV)</p>
<pre><code class="language-fake_python">s=stack()
p=root
while(p!=NULL or !is_empty(s)):
	while(p):
		s.push(p)
		if(p-&gt;lchild): p = p-&gt;lchild
		elif(p-&gt;rchild): p = p-&gt;rchild
	print(s.top())
	p = s.top()
    s.pop()
	if s and s.top()-&gt;lchild == p:
		p = p-&gt;rchild
	else:
		p = NULL  
</code></pre>
<p>若为左节点，则右节点入栈</p>
<p>若为右节点，返回上一层</p>
</li>
</ul>
<h2>线索二叉树</h2>
<h3>构建</h3>
<p>叶子结点的指针空余带来的是很多没有被利用的空间</p>
<p><img src="https://img.joe1sn.top/uploads/big/c941a2a89724d2e44eebd64e25239047.jpg" alt="" /></p>
<ul>
<li>
<p><strong>Ltag</strong></p>
<ul>
<li><strong>0</strong>: <code>lchild</code>指向左节点</li>
<li><strong>1</strong>: <code>lchild</code>指向该节点的遍历前驱</li>
</ul>
</li>
<li>
<p><strong>Rtag</strong></p>
<ul>
<li><strong>0</strong>: <code>rchild</code>指向左节点</li>
<li><strong>1</strong>: <code>rchild</code>指向该节点的遍历后继</li>
</ul>
</li>
</ul>
<p>最后就可以按照遍历方式得到一个链表，依次访问该链表就是该遍历方式的遍历顺序</p>
<p><img src="https://img.joe1sn.top/uploads/big/6c7f71cf4485a160dbff13ec823c80b4.jpg" alt="" /></p>
<p>上图的中序遍历就是：CBDAEGF</p>
<p>对应的中序穿线树为</p>
<p><img src="https://img.joe1sn.top/uploads/big/2f9fd2bbb039b4517a4e169e2ab62b7d.jpg" alt="" /></p>
<h3>遍历</h3>
<h4>中序</h4>
<p>使用python伪代码</p>
<pre><code class="language-fake_python">//中序遍历
p=root
while p-&gt;lchild:
	p = p-&gt;lchild
while p:
	print(p)
	if(p-&gt;rtag==0 and p-&gt;rchild): #不是线索
		p = p-&gt;rchild
        while(p-&gt;lchild):
            p = p-&gt;lchild
	else: p = p-&gt;rchild
</code></pre>
<p>跟着步骤得到遍历顺序: CBDAEGF
这里只得到了中序遍历的结果</p>
<h4>先序</h4>
<pre><code class="language-fake_python">p=root
while(p):
	print(p-&gt;value)
	if p-&gt;lchild and p-&gt;ltag == 0: #不为线索
		p = p-&gt;lchild
	else:
		p = p-&gt;rchild
</code></pre>
<h4>后序（有点难）</h4>
<p>后续比较特殊的是由于遍历不能存储之前的信息，所以后序穿线树多了一个叫做<code>parent</code>的指针指向父节点</p>
<pre><code class="language-fake_python">p = root
pre_node=NULL
while(p):
	while(p-&gt;lchild and p-&gt;ltag == 0): #到最左节点
		p = p-&gt;lchild
	while(p-&gt;rchild and p-&gt;rtag == 1): #右节点为线索
		print(p-&gt;value)
		pre_node = p
		p = p-&gt;rchild
	while(p and p-&gt;rchild == pre_node): #类似回路判断
										#则返回到父节点
		print(p-&gt;value)
		prev_node = p
		p=p-&gt;parent
	if(node and node-&gt;rtag == 0): #进入右子树遍历
		p = p-&gt;rchild
</code></pre>
<h1>树和森林</h1>
<h2>森林与二叉树转换</h2>
<h3>森林转二叉树</h3>
<ol>
<li>根结点相连</li>
<li>兄弟关系的节点相连</li>
<li>去掉从双亲到除了第一个孩子以外的连线</li>
<li>一点点的倾斜</li>
</ol>
<p><img src="https://img.joe1sn.top/uploads/big/0686aa8e5cbc0a915262234583af378c.jpg" alt="" /></p>
<h3>二叉树转森林</h3>
<p>基本就是逆转</p>
<ol>
<li>对 <strong>P</strong> 左节点的右节点存在，即<code>P-&gt;lchild-&gt;rchild!=NULL</code>，则 <strong>P</strong> 和<code>P-&gt;lchild-&gt;rchild</code>相连，也和<code>P-&gt;lchild-&gt;rchild-&gt;rchild-&gt;...</code>相连</li>
<li>删除原有二叉树中的右节点关系</li>
<li>得到森林</li>
</ol>
<p><img src="https://img.joe1sn.top/uploads/big/c442f1eaab3db69ab1e800d9e038d358.jpg" alt="" /></p>
<h2>树和森林的存储表示</h2>
<p><strong>多重链表法</strong></p>
<p>就是一个节点有多个指针只想子节点，虽然比较直观，但是空间浪费严重，</p>
<p><strong>孩子兄弟表示法</strong></p>
<p>就是将树或者森林变成二叉树，然后就是用二叉树的方式表示</p>
<p>| child | node_data | node_sibling |
| ----- | --------- | ------------ |
|       |           |              |</p>
<p><strong>双亲表示法</strong></p>
<p>从叶节点指向父节点，最后使用线性表格存储</p>
<p>| node_index | node_data | node_parent_index |
| ---------- | --------- | ----------------- |
|            |           |                   |</p>
<p><strong>三重链表表示法</strong></p>
<p>相当 <strong>双亲表示法</strong> + <strong>孩子兄弟表示法</strong>，每个节点如下，只多了一个指向<code>parent</code>节点的指针，这样方便从字节带你找到父节点，也能从父节点找到子节点</p>
<p>| child | child | node_data | parent |
| ----- | ----- | --------- | ------ |
|       |       |           |        |</p>
<p><strong>带右链的x序表示法</strong></p>
<p>既然三重链表表示法是方法的叠加，那么我们也可以从 森林/树-&gt;二叉树-&gt;x序二叉树，而且二叉树还森林原操作都是针对右节点操作，所以按照x序遍历过后指针都是向右指的，比如（其中<code>l_tag</code>表示当前节点是有左子节点，为0表示有，1表示无）</p>
<p>这里以带右链的中序表示法为例</p>
<p><img src="https://img.joe1sn.top/uploads/big/021293d5f31279bdfc0d3555c85fc3d3.jpg" alt="" /></p>
<p>| sibling     | 4    | 2    | -1   | -1   | -1   | 7    | -1   | 9    | -1   | -1   |
| ----------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| <strong>element</strong> | A    | B    | C    | K    | D    | E    | H    | F    | J    | G    |
| <strong>l_tag</strong>   | 0    | 1    | 0    | 1    | 0    | 0    | 1    | 0    | 1    | 1    |
| <strong>index</strong>   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |</p>
<h2>树和森林遍历</h2>
<h3>深度遍历</h3>
<p>对应的是递归三种遍历：先序、中序、后序</p>
<h3>宽度遍历</h3>
<p>对应的是层次遍历</p>
<h1>堆和优先权队列</h1>
<p>​	有一种数据结构，元素加入的次序无所谓，但是元素之前有取出的优先权，每次出去都是优先权最高的元素。
​	很容易想到队列，因为如果入队时间越早，优先权越高，优先权自然越高，而出队也最方便</p>
<p>​	问题就是使用队列每次插入新的值会执行线性搜索，会增加复杂度</p>
<h2>关于堆</h2>
<p>就是一颗<strong>完全二叉树</strong>，根节点叫做堆顶，由子节点和父节点的关系分为</p>
<ul>
<li><strong>最小堆</strong>：父节点小于或等于子节点</li>
<li><strong>最小堆</strong>：父节点大于或等于子节点，父节点存储最大值</li>
</ul>
<h2>建堆运算</h2>
<p>以建立最小堆位例子，比如有</p>
<p><img src="https://img.joe1sn.top/uploads/big/a2220a0f613261f69de10d6bf422906f.jpg" alt="" /></p>
<p>上面的序列就是一个很好的输入序列，但是我们输入是无序的，所以需要调整位置</p>
<p>虽然逻辑结构上是树，但是存储上是线性表存储，也就是说我们可以通过数组下表计算的方式调整堆</p>
<p>最小堆这里有特性：$lchild \ge rchild \ge root$
那么只需要从上往下，从左子树开始比较后，然后置换对应的节点，最后扫描的为叶子节点就算调整完毕 <strong>注意，这里是完全二叉树，计算下标很简单</strong></p>
<pre><code class="language-c">void adjust_down(element_type heap[], int cur, int boder){
    int p = cur;
    int min_child;
    element_type tmp;

    while(2*p+1 &lt;= boder){
        if ((2*p+2 &lt;= boder) &amp;&amp; (heap[2*p+1]&gt;heap[2*p+2]))
            min_child = 2*p+2;
        else
            min_child = 2*p+1;
        if(heap[p]&lt;=heap[min_child])
            break;
        else{
            tmp = heap[p];
            heap[p]=heap[min_child];
            heap[min_child]=tmp;
            /* If it's int type*/
            //heap[p]=heap[min_child]^0x10
            //heap[min_child]=heap[p]^0x10
            p=min_child;
        }
    }
}
</code></pre>
<p>那么为了在建立堆的时候</p>
<pre><code class="language-c">void create_heap(element_type heap[], int n){
    int i;
    for(i=(n-2)/2; i&gt;=0; i--)
        adjust_down(heap,i,n-1);
}
</code></pre>
<h2>优先权队列</h2>
<p><strong>这里依然以最小堆位例子</strong></p>
<h3>ADT</h3>
<ul>
<li>
<p><strong>data</strong></p>
<p>$n \ge 0$的最小堆</p>
</li>
<li>
<p><strong>algorithm</strong></p>
<p><code>prior_create(pq, max_size)</code>: create a empty prirorityQueue</p>
<p><code>priro_destroy(pq)</code>: realese memroy space</p>
<p><code>priro_is_empty(pq)</code>:</p>
<p><code>priro_is_full(pq)</code>:</p>
<p><code>priro_size(pq)</code>: get the element number</p>
<p><code>priro_append(pq,x)</code>: add new element <code>x</code> into prirority queue <code>pq</code></p>
<p><code>priro_serve(pq,x)</code>: set <code>x</code> to the highest prirority element in <code>pq</code></p>
</li>
</ul>
<p>和队列差不多的结构体</p>
<pre><code class="language-c">typedef char t_element_type;
struct priro_q
{
    t_element_type *pq;
    int n;
    int max_size;
}priro_q;
</code></pre>
<h3>向上调整算法</h3>
<p>​	由于每次添加元素到队列，都是添加到堆底，如果下一个出现元素打破队列，就需要调整下标了
​	根据堆的特性，出现这种情况就是当先优先级小于父节点，那么循环比较直到根节点就可以了</p>
<pre><code class="language-c">/**
 *          heap[(p-1)/2]                heap[(p-1)/2]
 *      heap[p]   heap[p+1]   or  heap[p-1]      heap[p]
 */
void adjust_up(element_type heap[], int cur){
    int p =cur;
    element_type tmp;
    while(p&gt;0){
        if(heap[p]&lt;heap[(p-1)/2]){
            tmp = heap[p];
            heap[p]=heap[(p-1)/2];
            heap[(p-1)/2]=tmp;
            /* or t_elemtn_type is int*/
            // heap[(p-1)/2]=heap[p]^0x10
            // heap[p]=heap[(p-1)/2]^0x10
            p=(p-1)/2;
        }
        else
            break;
    }
}
</code></pre>
<h3>prior_create</h3>
<p><code>prior_create(pq, max_size)</code>create a empty prirorityQueue</p>
<pre><code class="language-c">void prior_q_create(prior_q *pq,int max_size){
    pq-&gt;max_size = max_size;
    pq-&gt;n = 0;
    pq-&gt;q = (element_type *)malloc(max_size*sizeof(element_type));
    memset(pq-&gt;q,0,pq-&gt;max_size*sizeof(element_type));
}
</code></pre>
<h3>priro_destroy</h3>
<p><code>priro_destroy(pq)</code>: realese memroy space</p>
<pre><code class="language-c">void prior_q_destroy(prior_q *pq){
    free(pq-&gt;q);
    pq-&gt;n=0;
    pq-&gt;max_size=0;
}
</code></pre>
<h3>priro_append</h3>
<p><code>priro_append(pq,x)</code>: add new element <code>x</code> into prirority queue <code>pq</code></p>
<pre><code class="language-c">void prior_q_append(prior_q *pq, element_type x){
    if( prior_q_is_full(pq) ) return;
    pq-&gt;q[pq-&gt;n]=x;
    pq-&gt;n++;
    adjust_up(pq-&gt;q, pq-&gt;n-1);
}
</code></pre>
<h3>priro_serve</h3>
<p><code>priro_serve(pq,x)</code>: set <code>x</code> to the highest prirority element in <code>pq</code></p>
<pre><code class="language-c">void priro_q_serve(prior_q *pq, element_type *x){
    if(prior_q_is_empty(pq)) return;
    *x = pq-&gt;q[0];
    pq-&gt;n--;
    pq-&gt;q[0]=pq-&gt;q[pq-&gt;n];
    adjust_down(pq-&gt;q, 0, pq-&gt;n-1);
}
</code></pre>
<h3>main</h3>
<pre><code class="language-c">#include &lt;ADT/priority_queue.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    prior_q *pq=malloc(sizeof(prior_q));
    prior_q_create(pq,10);
    int test_case[]={71,74,2,72,54,93,52,28,'\0'};
    int i;
    
    for (i = 0; test_case[i]; i++)
        prior_q_append(pq, test_case[i]);
    while(pq-&gt;n&gt;0){
        element_type x;
        priro_q_serve(pq,&amp;x);
        printf(&quot;%d &quot;,x);
    }
    return 0;
}
</code></pre>
<p>output</p>
<pre><code>2 28 52 54 71 72 74 93 
</code></pre>
<h1>哈夫曼树和哈夫曼编码</h1>
<p>哈夫曼树要解决的问题是对字符串信息提供编码</p>
<h2>树的路径</h2>
<p><img src="https://img.joe1sn.top/uploads/big/5a6982a3b379bd27fece390d1c3d25ba.jpg" alt="" /></p>
<p><strong>内路径</strong>：根节点到非叶子节点的其他节点的路径和，上图 $I=1\times2+2=4$</p>
<p><strong>外路径</strong>：根节点到所有节点的路径和，上图$E=1\times3+2\times2+3\times2=13$</p>
<h2>哈夫曼树</h2>
<h3>概念</h3>
<p>哈夫曼树只一个加权扩充二叉树</p>
<p><img src="https://img.joe1sn.top/uploads/big/ebec59e497a1a713f726402872090a24.jpg" alt="" /></p>
<p><strong>两者之间有关系</strong> $E=I+2n$，其中 $n$ 为树的非叶节点总数</p>
<p>证明：</p>
<ul>
<li>上图中，设树的内路径为 $I_n$，外路径为 $E_n$，节点 <strong>J</strong> 的内路径为 $x$</li>
<li>假设定理存在 $E_k=I_k+2k$</li>
<li>如果删除节点 <strong>J</strong> 的子节点 <strong>AB</strong>，由节点 <strong>J</strong> 的内路径为 $x$
<ul>
<li>$I_{k-1}=I_k-x$</li>
<li>$E_{k-1}=E+k-2(x+1)+x=E_k-(x+2)$</li>
</ul>
</li>
<li>若定理存在 $E_k=I_k+2k$，则 $E_{k-1}=I_{k-1}+2(k-1)$ 依然成立
<ul>
<li>由上式可推 $E_{k-1}=I_{k-1}+2(k-1)$</li>
<li>证毕</li>
</ul>
</li>
</ul>
<p><strong>加权路径长度</strong>：</p>
<ul>
<li>叶节点：路径长度 X 权值</li>
<li><strong>树</strong>：所有叶节点的加权路径长度之和， $WPL=\sum_{k=1}^{m}W_kL_k$</li>
</ul>
<p>构建哈夫曼树的核心思想就是 <strong>为了使树的加权路径长度最小，权值越大，离根节点越近，路径越小，则最后的加权路径长度最小</strong></p>
<p><strong>这就像是构造一个最大堆，但仅仅像是</strong></p>
<h3>构造</h3>
<p>从一个序列开始构造，最后得到一个由扩充二叉树组成的森林</p>
<ol>
<li><strong>合并</strong>，选择序列中权值最小的两个节点<code>lchild</code> <code>rchild</code>和他们的和构成二叉树，和数为父节点，左节点为最小数；同时序列中两者合并为新的节点，权值是两个权值和</li>
<li>若队列只留下一个权值节点，即最后哈夫曼树的根节点，则构造完成</li>
</ol>
<h2>哈夫曼编码</h2>
<h3>编码</h3>
<p>哈夫曼编码要求任何集合中的元素的编码不能是其他元素编码的前缀，这种编码称为<strong>前缀编码</strong>。</p>
<p>例如，如字符集 $S={A,B,C,D}$ 权重 $W={6,4,2,3}$，一般来说使用频率越高那么权重越大(能更快被找到)，那么哈夫曼编码就为</p>
<p><img src="https://img.joe1sn.top/uploads/big/75dfca4260eadbd9d8fb728d50528ad3.jpg" alt="" /></p>
<p>假设现在有字符串序列 <code>ABACABDA</code>，那么对应的编码就为<code>01001100101110</code></p>
<h3>译码</h3>
<p>因为前缀没有相同的编码，所以只需要从哈夫曼树的头开始匹配就行了，一直匹配到叶子节点救赎</p>
<p>对于<code>01001100101110</code></p>
<p>0:A | 10:B | 0:A | 110:C | 0:A | 10:B | 111:D | 0:A</p>
<p>这样就还原了内容<code>ABACABDA</code></p>

</div>
</div></body>