<!DOCTYPE html>
<head>
<meta charset="UTF-8" /><title>PureWeb Blog-the Rust Book é›¶æ•£ç¬”è®°</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>  <script>    document.querySelectorAll('code').forEach((code) => {      if (!code.classList.length) {        code.classList.add('language-bash');      }    });  </script>	<script>		document.addEventListener('DOMContentLoaded', (event) => {			hljs.highlightAll();		});	</script><link rel="stylesheet" href="github.css">
<link rel="stylesheet" href="speciou.css"
</head><body>    <div class="container">        <header class="main-header">            <h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabinet</a></h1>            <nav class="main-header__nav">                <ul class="main-nav">                    <li class="main-nav__list"><a class="main-nav__list__link active" href="/" target="_self">HOME</a>                    </li>                    <li class="main-nav__list"><a class="main-nav__list__link" href="/archives/"                            target="_self">ARCHIVE</a>                    </li>                    <li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn"                            target="_blank">GITHUB</a></li>                </ul>            </nav>        </header>    </div><div class="typora-export os-windows"><div id="write" class>
<p><strong>2021-11-19 21:08</strong></p>
<p>åˆšå¥½æœ‰æ—¶é—´çœ‹ä¸‹</p>
<!-- more -->
<h1>1. Getting Started</h1>
<h2>Installation</h2>
<p>ç›´æ¥çœ‹å®˜æ–¹æ–‡æ¡£</p>
<p>https://doc.rust-lang.org/book/ch01-01-installation.html</p>
<h2>Hello, World!</h2>
<p>åœ¨windowså’ŒLinuxä¸Šåˆ†åˆ«åˆ›å»ºå¹¶è¿è¡Œhello worldé¡¹ç›®ç†Ÿæ‚‰RUSTè¯­è¨€ç‰¹æ€§</p>
<p>ä¸¤è€…å…±ç”¨æºä»£ç  hello_world.rs</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<h3>Windows</h3>
<p>ç¼–è¯‘</p>
<pre><code>rustc hello_world.rs
</code></pre>
<p>è¿è¡Œ</p>
<pre><code>.\main.exe
</code></pre>
<h3>Linux</h3>
<p>ç¼–è¯‘</p>
<pre><code>rustc hello_world.rs
</code></pre>
<p>è¿è¡Œ</p>
<pre><code>./main
</code></pre>
<h3>æ€»ç»“</h3>
<ul>
<li>
<p>åœ¨RUSTä¸­åˆ›å»ºå‡½æ•°</p>
<pre><code class="language-rust">fn main() {

}
</code></pre>
<ul>
<li>The <code>main</code> function is special: it is always the first code that runs in every executable Rust program</li>
</ul>
</li>
<li>
<p>åŠŸèƒ½å‡½æ•°</p>
<pre><code class="language-rust">    println!(&quot;Hello, world!&quot;);
</code></pre>
<ul>
<li>rustä½¿ç”¨å››ä¸ªç©ºæ ¼æ¥æ›¿ä»£Tab</li>
<li>è¿™é‡Œçš„<code>println</code>æ—¶è°ƒç”¨äº†ä¸€ä¸ªå®(macros)ï¼Œå½“è¦è°ƒç”¨<code>println</code>å‡½æ•°æ—¶ï¼Œä¸éœ€è¦æ·»åŠ æ„Ÿå¹å·</li>
<li>è¯­å¥ç»“æŸä½¿ç”¨<code>;</code></li>
</ul>
</li>
<li>
<p>rustc</p>
<p>ç›¸å½“äºrustçš„gccç¼–è¯‘å™¨</p>
</li>
</ul>
<h2>Cargo</h2>
<p>ç›¸å½“äºæ˜¯rustçš„<code>pip</code>ï¼Œæ˜¯ä¸€ä¸ªåŒ…ç®¡ç†å·¥å…·</p>
<h3>ä½¿ç”¨Cargoåˆ›å»ºé¡¹ç›®</h3>
<pre><code class="language-bash">cargo new hello_prog
cd hello_cargo
tree
.
â”œâ”€â”€ Getting Started.md
â”œâ”€â”€ hello_prog
â”‚Â Â  â”œâ”€â”€ Cargo.toml
â”‚Â Â  â””â”€â”€ src
â”‚Â Â      â””â”€â”€ main.rs
â”œâ”€â”€ hello_world
â”œâ”€â”€ hello_world.exe
â”œâ”€â”€ hello_world.pdb
â””â”€â”€ hello_world.rs
</code></pre>
<p>ä½¿ç”¨</p>
<pre><code>cargo new --vcs=git.
</code></pre>
<p>æ¥é¿å…åˆ›å»ºgitçš„gitignoreæ–‡ä»¶</p>
<p><code>Cargo.toml</code></p>
<pre><code class="language-toml">[package]
name = &quot;hello_prog&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>The first line, <code>[package]</code>, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, weâ€™ll add other sections.</p>
<p>The next three lines set the configuration information Cargo needs to compile your program: the name, the version, and the edition of Rust to use. Weâ€™ll talk about the <code>edition</code> key in <a href="https://doc.rust-lang.org/book/appendix-05-editions.html">Appendix E</a>.</p>
<p>The last line, <code>[dependencies]</code>, is the start of a section for you to list any of your projectâ€™s dependencies. In Rust, packages of code are referred to as <em>crates</em>. We wonâ€™t need any other crates for this project, but we will in the first project in Chapter 2, so weâ€™ll use this dependencies section then.</p>
<h3>ç¼–è¯‘è¿è¡Œ</h3>
<p>åœ¨æ–‡ä»¶å¤¹ä¸­</p>
<pre><code class="language-bash">cargo build
</code></pre>
<p>è¿è¡Œ</p>
<pre><code class="language-bash">./target/debug/hello_prog
</code></pre>
<p>ç¼–è¯‘å¹¶è¿è¡Œ</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>ç¼–è¯‘æµ‹è¯•</p>
<pre><code>cargo check
</code></pre>
<h2><a href="https://doc.rust-lang.org/book/ch01-03-hello-cargo.html#summary">Summary</a></h2>
<p>Youâ€™re already off to a great start on your Rust journey! In this chapter, youâ€™ve learned how to:</p>
<ul>
<li>Install the latest stable version of Rust using <code>rustup</code></li>
<li>Update to a newer Rust version</li>
<li>Open locally installed documentation</li>
<li>Write and run a â€œHello, world!â€ program using <code>rustc</code> directly</li>
<li>Create and run a new project using the conventions of Cargo</li>
</ul>
<p>This is a great time to build a more substantial program to get used to reading and writing Rust code. So, in Chapter 2, weâ€™ll build a guessing game program. If you would rather start by learning how common programming concepts work in Rust, see Chapter 3 and then return to Chapter 2.</p>
<h1>2-Programming a Guessing Game</h1>
<p>Youâ€™ll learn about <code>let</code>, <code>match</code>, methods, associated functions, using external crates, and more! The following chapters will explore these ideas in more detail</p>
<h2>åˆ›å»ºé¡¹ç›®</h2>
<pre><code>cargo new guessing_game
</code></pre>
<h2>å¤„ç†çŒœæµ‹</h2>
<p>è®©ç”¨æˆ·è¾“å…¥</p>
<pre><code class="language-rust">use std::io;	//pythonåº“

fn main() {
    println!(&quot;Guess a Number&quot;);
    print!(&quot;Please input your guess&gt; &quot;);

    let mut guess = String::new();
    
    io::stdin()							//è°ƒç”¨ioä¸­çš„stdinæ–¹æ³•
        .read_line(&amp;mut guess)			//pythonåº“ä¸­çš„åŠŸèƒ½
        .expect(&quot;Failed to readline&quot;);	//å¤±è´¥é¢„å¤„ç†
    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<ul>
<li><code>let</code> statement, which is used to create a <em>variable</em>.</li>
<li><code>mut</code>å˜é‡ç±»å‹ä¸å¯å˜</li>
<li>The <code>::</code> syntax in the <code>::new</code> line indicates that <code>new</code> is an <em>associated function</em> of the <code>String</code> type. An associated function is implemented on a type, in this case <code>String</code>.</li>
<li><code>read_line</code>å‡½æ•°è¿”å›ä¸€ä¸ª<code>io::Result</code>å€¼ï¼Œå€¼æ˜¯æšä¸¾çš„å˜é‡ï¼š<code>Ok</code>æˆ–<code>Err</code></li>
</ul>
<h2>äº§ç”Ÿéšæœºæ•°</h2>
<p>åœ¨é…ç½®æ–‡ä»¶ä¸­æ·»åŠ </p>
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
<p>The answer to this problem is the <em>Cargo.lock</em> file, which was created the first time you ran <code>cargo build</code> and is now in your <em>guessing_game</em> directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the <em>Cargo.lock</em> file. When you build your project in the future, Cargo will see that the <em>Cargo.lock</em> file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically.</p>
<p>your project will remain at <code>0.8.3</code> until you explicitly upgrade, thanks to the <em>Cargo.lock</em> file.</p>
<p>å¯ä»¥ä½¿ç”¨</p>
<pre><code class="language-rust">cargo update
</code></pre>
<p>è¿›è¡Œåº“æ›´æ–°</p>
<p>ç°åœ¨çš„æºä»£ç </p>
<pre><code class="language-rust">use std::io;	//pythonåº“
use rand::Rng;

fn main() {
    //1-äº§ç”Ÿéšæœºæ•°
    let secret_num = rand::thread_rng().gen_range(1..101);
    println!(&quot;Random number&gt; {}&quot;, secret_num);

    //2-è¾“å…¥
    println!(&quot;Guess a Number&quot;);
    print!(&quot;Please input your guess&gt; &quot;);

    let mut guess = String::new();
    
    io::stdin()							//è°ƒç”¨ioä¸­çš„stdinæ–¹æ³•
        .read_line(&amp;mut guess)			//pythonåº“ä¸­çš„åŠŸèƒ½
        .expect(&quot;Failed to readline&quot;);	//å¤±è´¥é¢„å¤„ç†
    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p>you can run the <code>cargo doc --open</code> command, which will build documentation provided by all of your dependencies locally and open it in your browser.</p>
<h2>æ¯”è¾ƒæ•°å­—</h2>
<p>we want to convert the <code>String</code> the program reads as input into a real number type so we can compare it numerically to the secret number. We can do that by adding another line to the <code>main</code> function body:</p>
<pre><code class="language-rust">    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
</code></pre>
<h2>åˆ›é€ å¾ªç¯ä½“</h2>
<pre><code class="language-rust">loop{
    
}
</code></pre>
<p>é€€å‡ºå¾ªç¯</p>
<pre><code class="language-rust">Ordering::xxx =&gt; {
    break;
}
</code></pre>
<h2>éæ³•è¾“å…¥å¤„ç†</h2>
<pre><code class="language-rust">use std::io;	//ç±»ä¼¼pythonåº“
use rand::Rng;  //éšæœºæ•°åº“
use std::cmp::Ordering; //æ¯”è¾ƒåŠŸèƒ½åº“

fn main() {
    //1-äº§ç”Ÿéšæœºæ•°
    let secret_num = rand::thread_rng().gen_range(1..101);
    println!(&quot;Random number&gt; {}&quot;, secret_num);

    //4-å¾ªç¯
    loop {
        //2-1è¾“å…¥
        println!(&quot;Please input your guess&gt; &quot;);

        let mut guess = String::new();
        
        io::stdin()							//è°ƒç”¨ioä¸­çš„stdinæ–¹æ³•
            .read_line(&amp;mut guess)			//pythonåº“ä¸­çš„åŠŸèƒ½
            .expect(&quot;Failed to readline&quot;);	//å¤±è´¥é¢„å¤„ç†

        //2-2è½¬æ¢ç±»å‹
        //5-å¤„ç†éæ³•è¾“å…¥
        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; {
                println!(&quot;Invalid input&quot;);
                continue;
            },
        };
        println!(&quot;You guessed: {}&quot;, guess);

        //3-æ¯”è¾ƒæ•°å­—å¤§å°
        match guess.cmp(&amp;secret_num) {
            Ordering::Less =&gt; println!(&quot;Too small&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win&quot;);
                break;
            }
        }
    }
}
</code></pre>
<h2>æ€»ç»“</h2>
<p>At this point, youâ€™ve successfully built the guessing game. Congratulations!</p>
<p>This project was a hands-on way to introduce you to many new Rust concepts: <code>let</code>, <code>match</code>, functions, the use of external crates, and more. In the next few chapters, youâ€™ll learn about these concepts in more detail. Chapter 3 covers concepts that most programming languages have, such as variables, data types, and functions, and shows how to use them in Rust. Chapter 4 explores ownership, a feature that makes Rust different from other languages. Chapter 5 discusses structs and method syntax, and Chapter 6 explains how enums work.</p>
<h1>3-Common Programming Concepts</h1>
<p>This chapter covers concepts that appear in almost every programming language and how they work in Rust. Many programming languages have much in common at their core. None of the concepts presented in this chapter are unique to Rust, but weâ€™ll discuss them in the context of Rust and explain the conventions around using these concepts.</p>
<p>Specifically, youâ€™ll learn about variables, basic types, functions, comments, and control flow. These foundations will be in every Rust program, and learning them early will give you a strong core to start from.</p>
<p><strong>RUSTå…³é”®å­—</strong></p>
<p>https://doc.rust-lang.org/book/appendix-01-keywords.html</p>
<h2>å˜é‡å’Œå¯å˜é‡</h2>
<ul>
<li>å˜é‡ç±»å‹é»˜è®¤æ˜¯ä¸å¯å˜çš„</li>
</ul>
<p>src/main.rs</p>
<pre><code class="language-rust">fn main() {
    let x= 5;
    println!(&quot;the value of x is {}&quot;, x);

    x=6;
    println!(&quot;the value of x is {}&quot;, x);
}
</code></pre>
<p>ä½¿ç”¨cargo runä¼šæŠ¥é”™</p>
<pre><code>5 |     x=6;
  |     ^^^ cannot assign twice to immutable variable
</code></pre>
<p>ä½¿ç”¨<code>mut</code>æ¥åˆ›é€ å¯å˜å˜é‡</p>
<pre><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;the value of x is {}&quot;, x);
    x = 6;
    println!(&quot;the value of x is {}&quot;, x);
}
</code></pre>
<ul>
<li>
<p>å˜é‡å’Œå¸¸é‡å¯¹æ¯”</p>
<ol>
<li>å¸¸é‡æ°¸è¿œä¸ºå¸¸ï¼Œä¸€ç›´ä¸å¯å˜</li>
<li>å®šä¹‰å¸¸é‡ä½¿ç”¨<code>const</code>è€Œä¸æ˜¯<code>let</code>ï¼ŒåŒæ—¶æŒ‡æ˜å˜é‡ç±»å‹</li>
<li>å¸¸é‡å®šä¹‰å°½é‡ä½¿ç”¨å¤§å†™</li>
<li>https://doc.rust-lang.org/reference/const_eval.html</li>
</ol>
</li>
<li>
<p>éšå¼å˜é‡</p>
<p>you can declare a new variable with the same name as a previous variableï¼ŒRustaceans say that the first variable is <em>shadowed</em> by the second, which means that the second variableâ€™s value is what the program sees when the variable is used.</p>
<pre><code class="language-rust">//å˜é‡çš„éšå¼èµ‹å€¼
fn shadow_value() {
    let x = 5;
    let x = x + 1;
    {
        let x = x * 2;
        println!(&quot;The value of x in the inner scope is {}&quot;, x);
    }
    println!(&quot;The value of x is {}&quot;,x);
}
</code></pre>
<p>è¾“å‡º</p>
<pre><code>The value of x in the inner scope is 12
The value of x is 6
</code></pre>
<p>This program first binds <code>x</code> to a value of <code>5</code>. Then it shadows <code>x</code> by repeating <code>let x =</code>, taking the original value and adding <code>1</code> so the value of <code>x</code> is then <code>6</code>.</p>
<p>Then, within an inner scope, the third <code>let</code> statement also shadows <code>x</code>, multiplying the previous value by <code>2</code> to give <code>x</code> a value of <code>12</code>.</p>
<p>When that scope is over, the inner shadowing ends and <code>x</code> returns to being <code>6</code></p>
<p>By using <code>let</code>, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed.</p>
</li>
</ul>
<h2>æ•°æ®ç±»å‹</h2>
<p>A <em>scalar</em> type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages.</p>
<h3>åŸºç¡€å˜é‡</h3>
<h4>Integer Types</h4>
<p>| Length  | Signed  | Unsigned |
| ------- | ------- | -------- |
| 8-bit   | <code>i8</code>    | <code>u8</code>     |
| 16-bit  | <code>i16</code>   | <code>u16</code>    |
| 32-bit  | <code>i32</code>   | <code>u32</code>    |
| 64-bit  | <code>i64</code>   | <code>u64</code>    |
| 128-bit | <code>i128</code>  | <code>u128</code>   |
| arch    | <code>isize</code> | <code>usize</code>  |</p>
<p>| Number literals  | Example       |
| ---------------- | ------------- |
| Decimal          | <code>98_222</code>      |
| Hex              | <code>0xff</code>        |
| Octal            | <code>0o77</code>        |
| Binary           | <code>0b1111_0000</code> |
| Byte (<code>u8</code> only) | <code>b'A'</code>        |</p>
<p>integer types default to <code>i32</code>. The primary situation in which youâ€™d use <code>isize</code> or <code>usize</code> is when indexing some sort of collection.</p>
<p><strong>rustèƒ½åœ¨ç¼–è¯‘ä¸­æ•´æ•°æº¢å‡ºå‘ç”Ÿæ—¶æ£€æµ‹åˆ°</strong>ï¼ˆPanicï¼‰</p>
<h4>Floating-Point Types</h4>
<pre><code class="language-rust">fn floating_tpyes() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32
}
</code></pre>
<p>æ•°å­—åŸºæœ¬åŠ å‡æ³•</p>
<pre><code class="language-rust">//åŸºç¡€çš„æ•°å­¦è¿ç®—
fn basic_math() {
    let sum = 5 + 10;
    let difference = 95 - 1;
    let product = 4 * 30;
    let floored = 2 / 3;
    let reminder = 43 % 5;
}
</code></pre>
<h4>The Boolean Type</h4>
<pre><code class="language-rust">fn boolean_test() {
    let t = true;
    
    let f: bool = false; // with explicit type annotation
}
</code></pre>
<h4>The Character Type</h4>
<p>So far weâ€™ve worked only with numbers, but Rust supports letters too. Rustâ€™s <code>char</code> type is the languageâ€™s most primitive alphabetic type, and the following code shows one way to use it. (Note that <code>char</code> literals are specified with single quotes, as opposed to string literals, which use double quotes.)</p>
<p>Filename: src/main.rs</p>
<pre><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'â„¤';
    let heart_eyed_cat = 'ğŸ˜»';
}
</code></pre>
<h3>ç¬¦åˆå˜é‡</h3>
<h4>å…ƒç»„ Tuple</h4>
<pre><code class="language-rust">let tup: (i32, f64, u8) = (500, 6.4, 1);
</code></pre>
<p>ä½ ç”šè‡³å¯ä»¥</p>
<pre><code class="language-rust">fn nice_tulpe() {
    let tup = (500,6.4,1);
    let (x,y,z) = tup;
    println!(&quot;The value of y is {}&quot;,y);
}
</code></pre>
<p>ä½¿ç”¨<code>.</code>è¿ç®—ç›´æ¥è¿›è¡Œä¸‹æ ‡è®¿é—®</p>
<pre><code class="language-rust">fn nice_tulpe() {
    let tup = (500,6.4,1);
    let (x,y,z) = tup;
    println!(&quot;The value of y is {}&quot;,y);
    println!(&quot;using . &gt; {}&quot;,tup.0);
}
</code></pre>
<h4>æ•°ç»„ç±»å‹ Array Type</h4>
<pre><code class="language-rust">let a = [1,2,3,4,5];
let a: [i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5];//let a = [3,3,3,3,3];
</code></pre>
<ul>
<li>
<p>æ•°ç»„è®¿é—®</p>
<pre><code class="language-rust">fn nice_array() {
    let a = [1, 2, 3, 4, 5];
    let first = a[0];
    let second = a[1];
    println!(&quot;fisrt&gt; {}\nsencond&gt; {}&quot;,first,second);
}
</code></pre>
</li>
<li>
<p>éæ³•æ•°ç»„è®¿é—®</p>
<pre><code class="language-rust">fn bad_array() {
    let a = [1,2,3,4,5];
    println!(&quot;enter the index&quot;);

    let mut idx = String::new();
    io::stdin()
        .read_line(&amp;mut idx)
        .expect(&quot;failed to readline&quot;);
    
    let idx: usize = idx
        .trim()
        .parse()
        .expect(&quot;Index enter was not a number&quot;);
    
    let elen = a[idx];
    println!(
        &quot;The value in a[{}] is {}&quot;,
        idx,a[idx]
    );
}
</code></pre>
<p>è¾“å…¥è¶…å‡ºèŒƒå›´æ—¶rustæŠ¥é”™</p>
<pre><code>enter the index
10
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:71:16
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>If the index is greater than or equal to the length, Rust will panic</p>
</li>
</ul>
<h2>å‡½æ•°</h2>
<p>ä¸å¸¦è¿”å›å€¼</p>
<pre><code class="language-rust">fn another_function(x: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>å¸¦è¿”å›å€¼</p>
<pre><code class="language-rust">fn five() -&gt; i32 {
    5
}
</code></pre>
<p>å‡½æ•°è¿”å›æœ€åä¸€ä¸ªå‡ºç°çš„æ‰€è¦æ±‚çš„ç±»å‹çš„æ•°æ®ï¼Œ<strong>åŒæ ·å¯ä»¥ä½¿ç”¨return è¿”å›å€¼</strong></p>
<p>å‡½æ•°è¡¨è¾¾å¼ä¸ç­‰åŒäºå‡½æ•°ç»“æ„ä½“ï¼Œä¸èƒ½æ˜¯ä½¿ç”¨return å…³é”®å­—</p>
<h2>é€»è¾‘åˆ¤æ–­ä¸å¾ªç¯</h2>
<h3><code>if</code> Expressions</h3>
<p>An <code>if</code> expression allows you to branch your code depending on conditions. You provide a condition and then state, â€œIf this condition is met, run this block of code. If the condition is not met, do not run this block of code.â€</p>
<p>Create a new project called <em>branches</em> in your <em>projects</em> directory to explore the <code>if</code> expression. In the <em>src/main.rs</em> file, input the following:</p>
<p>Filename: src/main.rs</p>
<pre><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
}
</code></pre>
<p>å¯ä»¥åˆ©ç”¨ifæ¡ä»¶è¿›è¡Œèµ‹å€¼ï¼ˆè¯­æ³•ç³–ï¼‰//æ³¨æ„ä¸¤ä¸ªå€¼çš„ç±»å‹è¦åŒ¹é…</p>
<pre><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre>
<h3><a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html#repetition-with-loops">Repetition with Loops</a></h3>
<p>Rust has three kinds of loops: <code>loop</code>, <code>while</code>, and <code>for</code>. Letâ€™s try each one.</p>
<h4>loop</h4>
<pre><code class="language-rust">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!(&quot;count = {}&quot;, count);
        let mut remaining = 10;

        loop {
            println!(&quot;remaining = {}&quot;, remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!(&quot;End count = {}&quot;, count);
}
</code></pre>
<p>åŒæ ·ä½¿ç”¨breaké€€å‡º</p>
<h4>Returning Values from Loops</h4>
<pre><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {}&quot;, result);
}
</code></pre>
<p>breakè¿”å›åé¢å€¼</p>
<h2><a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html#summary">Summary</a></h2>
<p>You made it! That was a sizable chapter: you learned about variables, scalar and compound data types, functions, comments, <code>if</code> expressions, and loops! If you want to practice with the concepts discussed in this chapter, try building programs to do the following:</p>
<ul>
<li>Convert temperatures between Fahrenheit and Celsius.</li>
<li>Generate the nth Fibonacci number.</li>
<li>Print the lyrics to the Christmas carol â€œThe Twelve Days of Christmas,â€ taking advantage of the repetition in the song.</li>
</ul>
<p>When youâ€™re ready to move on, weâ€™ll talk about a concept in Rust that <em>doesnâ€™t</em> commonly exist in other programming languages: ownership.</p>
<h1>4-Understanding Ownership</h1>
<h2>Feature represent</h2>
<p><strong>Rustâ€™s central feature is <em>ownership</em></strong></p>
<blockquote>
<p>All programs have to manage the way they use a computerâ€™s memory while running. Some languages have garbage collection that constantly looks for no longer used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while itâ€™s running.</p>
<p>......</p>
<p>Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you donâ€™t run out of space are all problems that ownership addresses.</p>
</blockquote>
<h3><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#ownership-rules">Ownership Rules</a></h3>
<ul>
<li>Each value in Rust has a variable thatâ€™s called its <em>owner</em>.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ul>
<h3><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#variable-scope">Variable Scope</a></h3>
<ul>
<li>åœ¨å‡½æ•°è¡¨è¾¾å¼ä¸­çš„å€¼ï¼Œåœ¨å‡½æ•°è¡¨è¾¾å®Œæˆåè‡ªåŠ¨åˆ é™¤</li>
</ul>
<p>ä½¿ç”¨<code>string</code>ç±»å‹ä¾‹å­ï¼Œä¸ºäº†æ›´å¥½çš„å­˜å‚¨å’Œä½¿ç”¨å­—ç¬¦ä¸²å€¼ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨<code>String</code>ç±»å‹</p>
<pre><code class="language-rust">let s = String::from(&quot;hello&quot;);
</code></pre>
<p>å…¶ä¸­<code>::</code>å‚è€ƒäº†c++å‘½åç©ºé—´</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    s.push_str(&quot;,Rust&quot;);
    println!(&quot;{}&quot;,s);
}
</code></pre>
<p>åœ¨<code>String</code>ä¸­ä¸ºäº†æ”¯æŒç±»å‹å¯å˜ã€é•¿åº¦å¯å˜ï¼Œåœ¨ç¼–è¯‘æ—¶é•¿åº¦ä¸å¯å˜</p>
<ul>
<li>åœ¨è¿è¡Œæ—¶å†…å­˜å¿…é¡»ç”±å†…å­˜åˆ†é…å™¨åˆ†é…</li>
<li>ç»“æŸä½¿ç”¨æ—¶è¦ç”¨æŸç§æ–¹å¼å‘Šè¯‰å†…å­˜</li>
</ul>
<p><strong>We need to pair exactly one <code>allocate</code> with exactly one <code>free</code>.</strong></p>
<p>Rustä½¿ç”¨äº†ä¸€ç§å’Œå…¶ä»–è¯­è¨€ä¸ä¸€æ ·çš„æ–¹å¼ï¼Œå½“å˜é‡è¶…å‡ºå…¶å®šä¹‰èŒƒå›´æ—¶GCè‡ªåŠ¨å›æ”¶è¿™å—å†…å­˜</p>
<p>å¦‚åœ¨4-1ä¸­æ‰€è®²çš„é‚£æ ·</p>
<pre><code class="language-rust">    let s = String::from(&quot;rust&quot;);
    {
        let s = String::from(&quot;hello&quot;);
        println!(&quot;{}&quot;,s);
    }
    println!(&quot;{}&quot;,s);
</code></pre>
<p>When a variable goes out of scope, Rust calls a special function for us. This function is called <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a>, and itâ€™s where the author of <code>String</code> can put the code to return the memory. Rust calls <code>drop</code> automatically at the closing curly bracket.</p>
<blockquote>
<p>Note: In C++, this pattern of deallocating resources at the end of an itemâ€™s lifetime is sometimes called <em>Resource Acquisition Is Initialization (RAII)</em>. The <code>drop</code> function in Rust will be familiar to you if youâ€™ve used RAII patterns.</p>
</blockquote>
<pre><code class="language-rust">    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;
    println!(&quot;{}&quot;,s1);
    println!(&quot;{}&quot;,s2);
</code></pre>
<pre><code>error[E0382]: borrow of moved value: `s1`
  --&gt; src/main.rs:18:19
   |
16 |     let s1 = String::from(&quot;hello&quot;);
   |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
17 |     let s2 = s1;
   |              -- value moved here
18 |     println!(&quot;{}&quot;,s1);
   |                   ^^ value borrowed here after move
</code></pre>
<p>åœ¨rustä¸­ï¼Œä¸€ä¸ª<code>string</code>ç»“æ„ä½“ä¸º</p>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-01.svg" alt="" /></p>
<p>åœ¨å¤åˆ¶æ—¶ï¼Œä»…ä»…å¤åˆ¶ç»“æ„ä½“ï¼Œè€Œä¸å¤åˆ¶å†…å­˜ä¸­çš„æ•°æ®</p>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-02.svg" alt="" /></p>
<p>ä½†æ˜¯rustå’Œå…¶å®ƒè¯­è¨€çš„æµ…æ‹·è´ä¸åŒï¼Œå®ƒæ˜¯å°†s1ç§»åŠ¨åˆ°äº†s2ï¼Œç›¸å½“äº</p>
<pre><code class="language-rust">let s = String::from(&quot;hello&quot;);
{
    let s = String::from(&quot;hello&quot;);
}
</code></pre>
<p>è¿™ç§ç±»ä¼¼çš„ç§»åŠ¨ï¼Œæ‰€ä»¥çœŸå®æƒ…å†µçœ‹ä¸Šå»å•Šåƒæ˜¯</p>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-04.svg" alt="" /></p>
<p>è¿™æ ·çš„ï¼Œæ‰€ä»¥åœ¨ä½¿ç”¨æ—¶ï¼Œæˆ‘ä»¬åªèƒ½ä½¿ç”¨s2</p>
<p>åŒæ—¶å¦‚æœæˆ‘ä»¬æƒ³è¦åšåˆ°<code>deep cpoy</code>ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨<code>clone</code>åŠŸèƒ½æ¥å®ç°</p>
<pre><code class="language-rust">    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1.clone();
    println!(&quot;s1 = {}&quot;,s1);
    println!(&quot;s2 = {}&quot;,s2);
</code></pre>
<p>Rust wonâ€™t let us annotate a type with the <code>Copy</code> trait if the type, or any of its parts, has implemented the <code>Drop</code> trait.</p>
<p>Here are some of the types that implement <code>Copy</code>:</p>
<ul>
<li>All the integer types, such as <code>u32</code>.</li>
<li>The Boolean type, <code>bool</code>, with values <code>true</code> and <code>false</code>.</li>
<li>All the floating point types, such as <code>f64</code>.</li>
<li>The character type, <code>char</code>.</li>
<li>Tuples, if they only contain types that also implement <code>Copy</code>. For example, <code>(i32, i32)</code> implements <code>Copy</code>, but <code>(i32, String)</code> does not.</li>
</ul>
<h3>Ownership and Functions</h3>
<p>The bookç›´æ¥ç»™å‡ºäº†ä¸€ä¸ªä¾‹å­</p>
<pre><code class="language-rust">fn main() {
    //5-ownership and functions
    let s = String::from(&quot;hello&quot;);
    takes_ownership(s);
    let x = 5;
    makes_copy(x);

}
//5-ownership and functions
fn takes_ownership(some_string: String) {
    println!(&quot;{}&quot;,some_string);
}

//5-ownership and functions
fn makes_copy(some_integar: i32) {
    println!(&quot;{}&quot;,some_integar);
}
</code></pre>
<p>æˆ‘ä»¬åœ¨<code>takes_ownership</code>ä¸­ä½¿ç”¨äº†åœ¨å †ä¸Šçš„å˜é‡<code>s</code>åï¼Œä¼šè°ƒç”¨<code>drop</code>è¿™ä¸ªåŠŸèƒ½é‡Šæ”¾<code>s</code>ï¼Œæ˜¯çš„åç»­ä¸èƒ½å†æ¬¡ä½¿ç”¨</p>
<p>è€Œæˆ‘ä»¬çš„<code>makes_copy</code>åœ¨æ ˆä¸Šé¢æ‰€ä»¥èƒ½å†æ¬¡ä½¿ç”¨</p>
<h3>Return Values and Scope</h3>
<pre><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from(&quot;hello&quot;);     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from(&quot;yours&quot;); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
</code></pre>
<p>The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by <code>drop</code> unless the data has been moved to be owned by another variable.</p>
<p><strong>What if we want to let a function use a value but not take ownership?</strong></p>
<p>ä½¿ç”¨å…ƒç»„ä¼ é€’ç»“æœ</p>
<pre><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
</code></pre>
<p>But this is too much ceremony and a lot of work for a concept that should be common. Luckily for us, Rust has a feature for this concept, called <em>references</em>.</p>
<h2>References and Borrowing</h2>
<p>å¯ä»¥å€Ÿé‰´c++ä¸­çš„ä¾‹å­ï¼Œrustä¸­ï¼ŒåŒæ ·ä½¿ç”¨<code>&amp;var</code>æ¥è¡¨ç¤ºå¯¹å‚æ•°çš„å¼•ç”¨ï¼Œthe bookåŒæ ·ç»™å‡ºäº†ä¸€ä¸ªä¾‹å­</p>
<pre><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let len: usize = calculate_lenth(&amp;s1);
    println!(&quot;{} lenth is {}&quot;,s1,len);
}

fn calculate_lenth(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-05.svg" alt="" /></p>
<p>åŒæ ·çš„ï¼Œrustå­˜åœ¨åå¼•ç”¨<code>*</code></p>
<pre><code class="language-rust">fn calculate_lenth(s: &amp;String) -&gt; usize {
    println!(&quot;{}&quot;,s.capacity());
    // println!(&quot;{}&quot;,*s.capacity()); false
    println!(&quot;{}&quot;,s);
    s.len()
}
</code></pre>
<p><strong>We call the action of creating a reference <em>borrowing</em></strong></p>
<p>é”™è¯¯ç¤ºä¾‹ä»£ç </p>
<pre><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p>åŸå› ï¼šJust as variables are immutable by default, so are references. Weâ€™re not allowed to modify something we have a reference to.</p>
<h3>Mutable References</h3>
<pre><code class="language-rust">fn main() {
    //2-mut reference
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
    println!(&quot;{}&quot;,s);
}

//2-mut reference
fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p>å¯å˜å¼•ç”¨æœ‰é™åˆ¶ï¼šä¸€ä¸ªå¯å˜å˜é‡åªèƒ½è¢«ä¸€ä¸ªå¯å˜å¼•ç”¨å æœ‰</p>
<p><strong>benefit</strong>: The restriction preventing multiple mutable references to the same data at the same time allows for mutation but in a very controlled fashion. Itâ€™s something that new Rustaceans struggle with, because most languages let you mutate whenever youâ€™d like.</p>
<p>å‡ ç§é”™è¯¯å¯å˜å¼•ç”¨ç¤ºä¾‹</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
}
</code></pre>
<pre><code>$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership`

To learn more, run the command again with --verbose.
</code></pre>
<p>ä¿®æ­£ï¼š</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &amp;mut s;
}
</code></pre>
<hr />
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    let r3 = &amp;mut s; // BIG PROBLEM

    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
}
</code></pre>
<pre><code>$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`

To learn more, run the command again with --verbose.
</code></pre>
<p>ä¿®æ­£</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    println!(&quot;{} and {}&quot;, r1, r2);
    // variables r1 and r2 will not be used after this point

    let r3 = &amp;mut s; // no problem
    println!(&quot;{}&quot;, r3);
}
</code></pre>
<h3>Dangling References</h3>
<p>rustå¼•èµ·çš„æŒ‡é’ˆæ‚¬ç©ºæ“ä½œä¼šè¢«ç¼–è¯‘å™¨å¯Ÿè§‰</p>
<pre><code class="language-rust">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<h3><a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#the-rules-of-references">The Rules of References</a></h3>
<p>Letâ€™s recap what weâ€™ve discussed about references:</p>
<ul>
<li>At any given time, you can have <em>either</em> one mutable reference <em>or</em> any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
<h2>The Slice Type</h2>
<p>Another data type that does not have ownership is the <em>slice</em>. Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection.</p>
<p>ä¾‹å­ï¼šä½¿ç”¨å¼•ç”¨æ¥åˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦ä¸ºå•è¯ï¼Œæ‰«æå­—ç¬¦ä¸²ï¼Œå‘ç°æœ‰ç©ºæ ¼åˆ™è¿”å›ç©ºæ ¼æ‰€åœ¨ä½ç½®ï¼Œæ²¡æœ‰åˆ™è¿”å›è¿™ä¸ªå•è¯</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello world&quot;);
    let word = first_word(&amp;s);
    println!(&quot;{}&quot;,word);
    s.clear();
}

fn first_word(s: &amp;String) -&gt; usize{
    let bytes = s.as_bytes();//å°†stråˆ‡æ¢ä¸ºbytesæ•°ç»„
    
    //enumerate wraps the result of iter and returns each element as part of a tuple instead. 
    for (i, &amp;item) in bytes.iter().enumerate() {
       if item == b' ' {
           return i;
       }
    }
    s.len()
}
</code></pre>
<p>ä¸ºäº†å¯¹è¯¥å•è¯è¿›è¡Œåˆ†æ®µï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæ–°çš„å‡½æ•°</p>
<pre><code class="language-rust">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<h3>String Slices</h3>
<p>A <em>string slice</em> is a reference to part of a <code>String</code>, and it looks like this:</p>
<pre><code class="language-rust">    let mut s = String::from(&quot;hello world&quot;);
 
    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
    println!(&quot;{}&quot;,hello);
    println!(&quot;{}&quot;,world);
</code></pre>
<p>åœ¨è¿‡ç¨‹ä¸­çš„ä¸¤ä¸ªå˜é‡ä¸º</p>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-06.svg" alt="" /></p>
<blockquote>
<p>Note: String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error. For the purposes of introducing string slices, we are assuming ASCII only in this section; a more thorough discussion of UTF-8 handling is in the <a href="https://doc.rust-lang.org/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">â€œStoring UTF-8 Encoded Text with Stringsâ€</a> section of Chapter 8.</p>
</blockquote>
<p>æ‰€ä»¥æˆ‘ä»¬å¯ä»¥é‡æ–°å†™ä¸Šä¸ªä¾‹å­ä¸º</p>
<pre><code class="language-rust">fn second_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();//å°†stråˆ‡æ¢ä¸ºbytesæ•°ç»„
    
    //enumerate wraps the result of iter and returns each element as part of a tuple instead. 
    for (i, &amp;item) in bytes.iter().enumerate() {
       if item == b' ' {
           return &amp;s[0..i];
       }
    }
    &amp;s[..]
}
</code></pre>
<p>é”™è¯¯è°ƒç”¨</p>
<pre><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}

fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!(&quot;the first word is: {}&quot;, word);
}
</code></pre>
<p><strong>Recall from the borrowing rules that if we have an immutable reference to something, we cannot also take a mutable reference.</strong></p>
<h4><a href="https://doc.rust-lang.org/book/ch04-03-slices.html#string-slices-as-parameters">String Slices as Parameters</a></h4>
<h3>Other Slices</h3>
<p>String slices, as you might imagine, are specific to strings. But thereâ€™s a more general slice type, too. Consider this array:</p>
<pre><code class="language-rust">let a = [1, 2, 3, 4, 5];
</code></pre>
<p>Just as we might want to refer to a part of a string, we might want to refer to part of an array. Weâ€™d do so like this:</p>
<pre><code class="language-rust">let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
</code></pre>
<p>This slice has the type <code>&amp;[i32]</code>. It works the same way as string slices do, by storing a reference to the first element and a length. Youâ€™ll use this kind of slice for all sorts of other collections. Weâ€™ll discuss these collections in detail when we talk about vectors in Chapter 8.</p>
<h2>Summary</h2>
<p>The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time. The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you donâ€™t have to write and debug extra code to get this control.</p>
<p>Ownership affects how lots of other parts of Rust work, so weâ€™ll talk about these concepts further throughout the rest of the book. Letâ€™s move on to Chapter 5 and look at grouping pieces of data together in a <code>struct</code>.</p>
<h1>5-Using Structs to Structure Related Data</h1>
<p>In this chapter, weâ€™ll compare and contrast tuples with structs. Weâ€™ll demonstrate how to define and instantiate structs. Weâ€™ll discuss how to define associated functions, especially the kind of associated functions called <em>methods</em>, to specify behavior associated with a struct type.</p>
<h2>Defining and Instantiating Structs</h2>
<blockquote>
<p>To define a struct, we enter the keyword <code>struct</code> and name the entire struct. A structâ€™s name should describe the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of the pieces of data, which we call <em>fields</em>. For example, Listing 5-1 shows a struct that stores information about a user account.</p>
</blockquote>
<pre><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
</code></pre>
<p>å®ä¾‹åŒ–ç»“æ„ä½“</p>
<pre><code class="language-rust">    let user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };
</code></pre>
<p>To get a specific value from a struct, we can use dot notation</p>
<pre><code class="language-rust">    //ä½¿ç”¨mutableç»“æ„ä½“
    let mut user2 = User {
        active: true,
        username: String::from(&quot;admin&quot;),
        sign_in_count: 0,
        email: String::from(&quot;admin@covteam.club&quot;),        
    };

    user2.email=String::from(&quot;admin@covteam.cn&quot;);
</code></pre>
<p>ä½¿ç”¨å‡½æ•°å®ä¾‹åŒ–ç»“æ„ä½“</p>
<pre><code class="language-rust">fn main() {
    let user3 = build_user(String::from(&quot;test@covteam.com&quot;), String::from(&quot;username&quot;));
    println!(&quot;user3 email&gt; {}&quot;,user3.email);
    println!(&quot;user3 username&gt; {}&quot;,user3.username);
}

fn build_user(email: String, username: String) -&gt; User{
    User{
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
</code></pre>
<p>å¯ä»¥çœç•¥çš„å¡«å…¥å‚æ•°å®ä¾‹åŒ–ç»“æ„ä½“</p>
<pre><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(
        String::from(&quot;someone@example.com&quot;),
        String::from(&quot;someusername123&quot;),
    );
}
</code></pre>
<h3>Creating Instances From Other Instances With Struct Update Syntax</h3>
<pre><code class="language-rust">    let user4 = User {
        active: user1.active,
        username: user2.username,
        email: String::from(&quot;some_one@qq.com&quot;),
        sign_in_count: user3.sign_in_count,
    };
</code></pre>
<p>The syntax <code>..</code> specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</p>
<pre><code class="language-rust">    let user5 = User {
        email: String::from(&quot;joe1sn@qq.com&quot;),
        ..user1
    };
</code></pre>
<p>ä½†æ˜¯å¦‚æœcopyçš„æ˜¯å¯å˜å˜é‡ï¼ˆå¦‚user2ï¼‰ï¼Œä¼šæŠ¥é”™</p>
<pre><code>error[E0382]: use of moved value: `user2.username`
  --&gt; src/main.rs:38:17
   |
33 |           username: user2.username,
   |                     -------------- value moved here
...
38 |       let user5 = User {
   |  _________________^
39 | |         email: String::from(&quot;joe1sn@qq.com&quot;),
40 | |         ..user2
41 | |     };
   | |_____^ value used here after move
   |
   = note: move occurs because `user2.username` has type `String`, which does 
not implement the `Copy` trait
</code></pre>
<p>å…¶ä¸­å¯ä»¥è¿™æ ·ç†è§£</p>
<p>**Note that the struct update syntax is like assignment with <code>=</code> because it moves the data, just as we saw in the <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#ways-variables-and-data-interact-move">â€œWays Variables and Data Interact: Moveâ€ section</a>. **</p>
<h3>Using Tuple Structs without Named Fields to Create Different Types</h3>
<p>å‚è€ƒgoçš„ç»“æ„ä½“æ„é€ å…¶å®ä¹Ÿæ˜¯å¦‚æ­¤</p>
<pre><code class="language-rust">    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
</code></pre>
<h3>Unit-Like Structs Without Any Fields</h3>
<p>åº”ç”¨æ–¹å¼ï¼šunit-like structs can be useful in situations in which you need to implement a trait on some type but donâ€™t have any data that you want to store in the type itself.</p>
<pre><code class="language-rust">fn main() {
    struct AlwaysEqual;

    let subject = AlwaysEqual;
}
</code></pre>
<p>without any curly brackets or parentheses. Imagine weâ€™ll be implementing behavior for this type that every instance is always equal to every instance of every other type</p>
<p><a href="">Youâ€™ll see in Chapter 10 how to define traits and implement them on any type, including unit-like structs.</a></p>
<blockquote>
<p>In the <code>User</code> struct definition in Listing 5-1, we used the owned <code>String</code> type rather than the <code>&amp;str</code> string slice type. This is a deliberate choice because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.</p>
<p>Itâ€™s possible for structs to store references to data owned by something else, but to do so requires the use of <em>lifetimes</em>, a Rust feature that weâ€™ll discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct is valid for as long as the struct is. Letâ€™s say you try to store a reference in a struct without specifying lifetimes, like this, which wonâ€™t work:</p>
<p>Filename: src/main.rs</p>
<pre><code class="language-rust">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>The compiler will complain that it needs lifetime specifiers:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:2:15
  |
2 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct User&lt;'a&gt; {
2 |     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:12
  |
3 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct User&lt;'a&gt; {
2 |     username: &amp;str,
3 |     email: &amp;'a str,
  |

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs`

To learn more, run the command again with --verbose.
</code></pre>
<p>In Chapter 10, weâ€™ll discuss how to fix these errors so you can store references in structs, but for now, weâ€™ll fix errors like these using owned types like <code>String</code> instead of references like <code>&amp;str</code>.</p>
</blockquote>
<h2>An Example Program Using Structs</h2>
<p><strong>letâ€™s write a program that calculates the area of a rectangle. Weâ€™ll start with single variables, and then refactor the program until weâ€™re using structs instead.</strong></p>
<p>1.åŠŸèƒ½çš„ç®€å•å®ç°</p>
<pre><code class="language-rust">fn main() {
    let w1: u32 = 30;
    let h1: u32 = 50;
    println!(&quot;the rectangle is {}&quot;, area(w1,h1) );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre>
<p>2.ä½¿ç”¨å…ƒç»„ä¼ å€¼</p>
<pre><code class="language-rust">fn area(wh_value: (u32, u32)) -&gt; u32 {
    wh_value.0 * wh_value.1
}
</code></pre>
<p>3.ä½¿ç”¨ç»“æ„ä½“</p>
<pre><code class="language-rust">fn main() {
    let tmp = tangel{width:30, height:50};
    println!(&quot;the rectangle is {}&quot;,  area(&amp;tmp));
    //    println!(&quot;the rectangle is {}&quot;,  area(
    //    &amp;tangel{width:30, height:50}
    //));
}
fn area( rectangle: &amp;tangel ) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre>
<h3>Adding Useful Functionality with Derived Traits</h3>
<p>å¦‚ä½•ç«‹å³æ‰“å°å‡ºç»“æ„ä½“çš„æ‰€æœ‰å€¼ï¼Œç›´æ¥æ‰“å°æŠ¥é”™ï¼šå’Œç±»å‹ä¸åŒ¹é…</p>
<p>Putting the specifier <code>:?</code> inside the curly brackets tells <code>println!</code> we want to use an output format called <code>Debug</code>. The <code>Debug</code> trait enables us to print our struct in a way that is useful for developers so we can see its value while weâ€™re debugging our code.</p>
<p>åœ¨ç¨‹åºå¤´éƒ¨åŠ ä¸Š<code>#[derive(Debug)]</code>è¿›å…¥debugç¨‹åºæ¨¡å¼</p>
<p>ä»£ç </p>
<pre><code class="language-rust">#[derive(Debug)]
struct tangel {
    width: u32,
    height: u32,
}

fn main() {
    let tmp = tangel{width:30, height:50};
    println!(&quot;debug print {:?}&quot;,tmp);
    println!(&quot;debug print {:#?}&quot;,tmp);
}
</code></pre>
<p>è¾“å‡º</p>
<pre><code>debug print tangel { width: 30, height: 50 }
debug print tangel {
    width: 30,
    height: 50,
}
</code></pre>
<p>åŒæ—¶å¯ä»¥ä½¿ç”¨<code>!dbg()</code>æ¥è¿›è¡Œè°ƒè¯•ä¿¡æ¯çš„è¾“å‡ºã€‚Calling the <code>dbg!</code> macro prints to the standard error console stream (<code>stderr</code>), as opposed to <code>println!</code> which prints to the standard output console stream (<code>stdout</code>).</p>
<p>ä»£ç </p>
<pre><code class="language-rust">#[derive(Debug)]
struct tangel {
    width: u32,
    height: u32,
}

fn main() {
    let tmp = tangel{width:30, height:50};
    println!(&quot;debug print {:?}&quot;,tmp);
    println!(&quot;debug print {:#?}&quot;,tmp);
}
</code></pre>
<p>è¾“å‡º</p>
<pre><code>[src/main.rs:30] 30 * t = 60
[src/main.rs:33] tmp = tangel {
    width: 60,
    height: 50,
}
</code></pre>
<p>In addition to the <code>Debug</code> trait, Rust has provided a number of traits for us to use with the <code>derive</code> attribute that can add useful behavior to our custom types. Those traits and their behaviors are listed in <a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">Appendix C</a>. Weâ€™ll cover how to implement these traits with custom behavior as well as how to create your own traits in Chapter 10. There are also many attributes other than <code>derive</code>; for more information, see <a href="https://doc.rust-lang.org/reference/attributes.html">the â€œAttributesâ€ section of the Rust Reference</a>.</p>
<p>å¦‚ä½•å°†areaä»å‡½æ•°å˜ä¸ºæ–¹æ³•</p>
<h2>Method Syntax</h2>
<p>However, methods are different from functions in that theyâ€™re defined within the context of a struct (or an enum or a trait object, which we cover in Chapters 6 and 17, respectively), and their first parameter is always <code>self</code>, which represents the instance of the struct the method is being called on.ï¼ˆå¯ä»¥å‚è€ƒpythonç±»çš„æ„å»ºæ–¹æ³•ï¼‰</p>
<h3>Defining Methods</h3>
<pre><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32{
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre>
<ul>
<li>The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.</li>
<li>Methods must have a parameter named <code>self</code> of type <code>Self</code> for their first parameter, so Rust lets you abbreviate this with only the name <code>self</code> in the first parameter spot.</li>
<li>If we wanted to change the instance that weâ€™ve called the method on as part of what the method does, weâ€™d use <code>&amp;mut self</code> as the first parameter.</li>
</ul>
<p>æ–¹æ³•ä¸­çš„å‡½æ•°åèƒ½å’Œæˆå‘˜åé‡åˆ</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    
    if rect1.width() {
        println!(&quot;The rectangle has a nonzero width; it is {}&quot;, rect1.width);
    }
}
</code></pre>
<p>[<strong>å‘½åè§„åˆ™</strong>]Often, but not always, methods with the same name as a field will be defined to only return the value in the field and do nothing else.</p>
<p><a href="">We will be discussing what public and private are and how to designate a field or method as public or private in Chapter 7.</a></p>
<blockquote>
<h3><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#wheres-the---operator">Whereâ€™s the <code>-&gt;</code> Operator?</a></h3>
<p>In C and C++, two different operators are used for calling methods: you use <code>.</code> if youâ€™re calling a method on the object directly and <code>-&gt;</code> if youâ€™re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if <code>object</code> is a pointer, <code>object-&gt;something()</code> is similar to <code>(*object).something()</code>.</p>
<p><strong>Rust doesnâ€™t have an equivalent to the <code>-&gt;</code> operator</strong>; instead, Rust has a feature called <em><strong>automatic referencing and dereferencing</strong></em>. Calling methods is one of the few places in Rust that has this behavior.</p>
<p>Hereâ€™s how it works: when you call a method with <code>object.something()</code>, Rust automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> so <code>object</code> matches the signature of the method. In other words, the following are the same:</p>
<pre><code class="language-rust">p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
</code></pre>
<p>The first one looks much cleaner. This automatic referencing behavior works <strong>because methods have a clear receiverâ€”the type of <code>self</code></strong>. Given the receiver and name of a method, Rust can figure out definitively whether the method is reading (<code>&amp;self</code>), mutating (<code>&amp;mut self</code>), or consuming (<code>self</code>). The fact that Rust makes borrowing implicit for method receivers is a big part of making ownership ergonomic in practice.</p>
</blockquote>
<h3>Methods with More Parameters</h3>
<p>ä¾‹å­ä»»åŠ¡ï¼š This time, we want an instance of <code>Rectangle</code> to take another instance of <code>Rectangle</code> and return <code>true</code> if the second <code>Rectangle</code> can fit completely within <code>self</code>; otherwise it should return <code>false</code>.</p>
<pre><code class="language-rust">impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<h3>Associated Functions</h3>
<p>All functions defined within an <code>impl</code> block are called <em>associated functions</em> because theyâ€™re associated with the type named after the <code>impl</code>.</p>
<p>We can define associated functions that donâ€™t have <code>self</code> as their first parameter (and thus are not methods) because they donâ€™t need an instance of the type to work with.å¦‚<code>String::from()</code></p>
<p>åˆ›å»ºä¸€ä¸ªå…³è”å‡½æ•°ï¼ˆä»»ç„¶è¦åœ¨implä¸­ï¼‰</p>
<pre><code class="language-rust">impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }

    fn square(size: u32) -&gt; Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
</code></pre>
<p>To call this associated function, we use the <code>::</code> syntax with the struct name;</p>
<h3>Multiple <code>impl</code> Blocks</h3>
<p>å¯ä»¥åœ¨ä¸åŒ<code>impl</code>ä¸­å¯¹åŒä¸€ç»“æ„ä½“å¯¹è±¡çš„æ–¹æ³•è¿›è¡Œå®šä¹‰ï¼Œè™½ç„¶æ²¡æœ‰å¿…è¦ï¼Œä½†æ˜¯åœ¨è¯­æ³•ä¸Šå¯è¡Œ</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<h2>Summary</h2>
<p>Structs let you create custom types that are meaningful for your domain. By using structs, you can keep associated pieces of data connected to each other and name each piece to make your code clear. In <code>impl</code> blocks, you can define functions that are associated with your type, and methods are a kind of associated function that let you specify the behavior that instances of your structs have.</p>
<p>But structs arenâ€™t the only way you can create custom types: letâ€™s turn to Rustâ€™s enum feature to add another tool to your toolbox.</p>
<h1>6-Enums and Pattern Matching</h1>
<ul>
<li>First, weâ€™ll define and use an enum to show how an enum can encode meaning along with data.</li>
<li>Next, weâ€™ll explore a particularly useful enum, called <code>Option</code>, which expresses that a value can be either something or nothing.</li>
<li>Then weâ€™ll look at how pattern matching in the <code>match</code> expression makes it easy to run different code for different values of an enum.</li>
<li>Finally, weâ€™ll cover how the <code>if let</code> construct is another convenient and concise idiom available to you to handle enums in your code.</li>
</ul>
<p><strong>Rustâ€™s enums are most similar to <em>algebraic data types</em> in functional languages, such as F#, OCaml, and Haskell.</strong></p>
<h2>Defining an Enum</h2>
<p>ä»ä¸€ä¸ªä¾‹å­æ¥è¯´æ˜ä¸ºä»€ä¹ˆæšä¸¾æ¯”ç»“æ„ä½“åœ¨æŸäº›æƒ…å†µä¸‹æ›´åŠ æ–¹ä¾¿</p>
<p>These are the only possibilities for an IP address that our program will come across: we can <em>enumerate</em> all possible variants, which is where enumeration gets its name.</p>
<p>ä»å®šä¹‰ä¸€ä¸ª<code>IpAddrKind</code>æšä¸¾å¼€å§‹æ¥åŒºåˆ†ipv4å’Œipv6</p>
<pre><code class="language-rust">enum  IpAddrKind {
    v4,
    v6
}
</code></pre>
<h3>Enum Values</h3>
<p>åˆ›å»ºæšä¸¾ç«‹å³å€¼</p>
<pre><code class="language-rust">fn main() {
    let four = IpAddrKind::v4;
    let six = IpAddrKind::v6;
}
</code></pre>
<p>åœ¨è¿™é‡Œ <code>IpAddrKind::V4</code> and <code>IpAddrKind::V6</code> éƒ½æ˜¯åŒä¸€ä¸ªç±»å‹<code>IpAddrKind</code></p>
<p>åˆ›å»º<code>route</code>å‡½æ•°æ¥è°ƒç”¨<code>IpAddrKind</code></p>
<pre><code class="language-rust">fn route(ip_kind: IpAddrKind) {}

fn main() {
    route(IpAddrKind::v4);
}
</code></pre>
<p><strong>at the moment we donâ€™t have a way to store the actual IP address <em>data</em>; we only know what <em>kind</em> it is.</strong></p>
<p>æ˜¾ç¤ºå°è¯•ä½¿ç”¨ç®€å•çš„ç»“æ„ä½“è§£å†³</p>
<pre><code class="language-rust">use std::net::IpAddr;

enum  IpAddrKind {
    v4,
    v6
}

struct MyIpAddr {
    kind: IpAddrKind,
    address: String,
}

fn main() {
    let home = MyIpAddr {
        kind: IpAddrKind::v4,
        address: String::from(&quot;127.0.0.1&quot;)
    };

    let loopback = MyIpAddr {
        kind: IpAddrKind::v6,
        address: String::from(&quot;::1&quot;),
    };
}
</code></pre>
<p>æˆ‘ä»¬å·²ç»ä½¿ç”¨ç»“æ„ä½“å°†ç§ç±»å’Œåœ°å€å€¼æ†ç»‘åœ¨ä¸€èµ·ï¼Œæ‰€ä»¥ç°åœ¨å˜ä½“ä¸å€¼ç›¸å…³è”ã€‚</p>
<p><strong>We can represent the same concept in a more concise way using just an enum, rather than an enum inside a struct, by putting data directly into each enum variant.</strong> åƒæ˜¯è¿™æ ·</p>
<pre><code class="language-rust">use std::net::IpAddr;

enum  IpAddrKind {
    v4,
    v6
}

enum MyIpAddr {
    v4(String),
    v6(String),
}

fn main() {
    let home = MyIpAddr::v4(String::from(&quot;127.0.0.1&quot;));
    let loopback = MyIpAddr::v6(String::from(&quot;::1&quot;));
}
</code></pre>
<p>Rustå¯ä»¥åªèƒ½å¯¹å€¼è¿›è¡Œå¡«å……</p>
<pre><code class="language-rust">fn main() {
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
}
</code></pre>
<p>Rustçš„å®˜æ–¹åŒ…å¯¹<code>IpAdd</code>è¿™æ ·å®šä¹‰</p>
<pre><code class="language-rust">pub enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
</code></pre>
<p>example</p>
<pre><code class="language-rust">use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};

let localhost_v4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));
let localhost_v6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));

assert_eq!(&quot;127.0.0.1&quot;.parse(), Ok(localhost_v4));
assert_eq!(&quot;::1&quot;.parse(), Ok(localhost_v6));

assert_eq!(localhost_v4.is_ipv6(), false);
assert_eq!(localhost_v4.is_ipv4(), true);
</code></pre>
<p>This code illustrates that you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example.</p>
<p>åˆ©ç”¨æšä¸¾ç®€åŒ–ç»“æ„ä½“</p>
<pre><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
</code></pre>
<p>åŠŸèƒ½ç­‰ä»·äº</p>
<pre><code class="language-rust">struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct

fn main() {}
</code></pre>
<p>There is one more similarity between enums and structs: just as weâ€™re able to define methods on structs using <code>impl</code>, weâ€™re also able to define methods on enums.</p>
<pre><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&amp;self) {
        // println!(&quot;world&quot;);
    }
}
fn main() {
    let m = Message::Write(String::from(&quot;hello&quot;));
    m.call();
}
</code></pre>
<h3>The <code>Option</code> Enum and Its Advantages Over Null Values</h3>
<p>This section explores a case study of <code>Option</code>, which is another enum defined by the standard library. The <code>Option</code> type is used in many places because it encodes the very common scenario in which a value could be something or it could be nothing.</p>
<p>this functionality can prevent bugs that are extremely common in other programming languages.</p>
<p><strong>Rust doesnâ€™t have the null feature that many other languages have.</strong></p>
<blockquote>
<p>I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldnâ€™t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p>
</blockquote>
<p><strong>Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is <code>Option&lt;T&gt;</code>, and it is <a href="https://doc.rust-lang.org/std/option/enum.Option.html">defined by the standard library</a> as follows:</strong></p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}
</code></pre>
<p>ä½¿ç”¨å«nullçš„æšä¸¾</p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}


fn main() {
    //using null enum
    let some_number = Some(5);
    let some_string = Some(&quot;a string&quot;);

    let absent_number: Option&lt;i32&gt; = None;
}
</code></pre>
<p>å…¶ä¸­<code>&lt;T&gt;</code>æ˜¯ç±»ä¼¼äºC++ä¸­çš„æ³›å‹</p>
<p>In short, because <code>Option&lt;T&gt;</code> and <code>T</code> (where <code>T</code> can be any type) are different types, the compiler wonâ€™t let us use an <code>Option&lt;T&gt;</code> value as if it were definitely a valid value. For example, this code wonâ€™t compile because itâ€™s trying to add an <code>i8</code> to an <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust">    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
</code></pre>
<p><strong>In other words, you have to convert an <code>Option&lt;T&gt;</code> to a <code>T</code> before you can perform <code>T</code> operations with it.</strong></p>
<p>So, how do you get the <code>T</code> value out of a <code>Some</code> variant when you have a value of type <code>Option&lt;T&gt;</code> so you can use that value? The <code>Option&lt;T&gt;</code> enum has a large number of methods that are useful in a variety of situations; you can check them out in <a href="https://doc.rust-lang.org/std/option/enum.Option.html">its documentation</a>. Becoming familiar with the methods on <code>Option&lt;T&gt;</code> will be extremely useful in your journey with Rust.</p>
<p><strong>In general,</strong> in order to use an <code>Option&lt;T&gt;</code> value, you want to have code that will handle each variant. You want some code that will run only when you have a <code>Some(T)</code> value, and this code is allowed to use the inner <code>T</code>. You want some other code to run if you have a <code>None</code> value, and that code doesnâ€™t have a <code>T</code> value available. The <code>match</code> expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</p>
<h2>The <code>match</code> Control Flow Operator</h2>
<p><strong>Rust has an extremely powerful control flow operator called <code>match</code> that allows you to compare a value against a series of patterns and then execute code based on which pattern matches.</strong></p>
<p>å¦‚ä½•å…·ä½“åŒ–<code>match</code>çš„æ€æƒ³</p>
<pre><code>Think of a match expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a match, and at the first pattern the value â€œfits,â€ the value falls into the associated code block to be used during execution.
</code></pre>
<p>ç„¶åå°±æœ‰äº†ä¸‹é¢è¿™æ®µä»£ç </p>
<pre><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}

fn main() {
    // let coin = Coin::Penny;
    println!(&quot;Penny {}&quot;,value_in_cents(Coin::Penny));
    println!(&quot;Nickel {}&quot;,value_in_cents(Coin::Nickel));
    println!(&quot;Dime {}&quot;,value_in_cents(Coin::Dime));
    println!(&quot;Quarter {}&quot;,value_in_cents(Coin::Quarter));
}
</code></pre>
<p>Next are the <code>match</code> arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value <code>Coin::Penny</code> and then the <code>=&gt;</code> operator that separates the pattern and the code to run. The code in this case is just the value <code>1</code>. Each arm is separated from the next with a comma.</p>
<p><strong>If that pattern doesnâ€™t match the value, execution continues to the next arm, much as in a coin-sorting machine.</strong></p>
<h3>Patterns that Bind to Values</h3>
<p>å¯¹æšä¸¾å€¼è¿›è¡Œé”®å€¼ç»‘å®š</p>
<pre><code class="language-rust">#[derive(Debug)]
// enum Coin {
//     Penny,
//     Nickel,
//     Dime,
//     Quarter,
// }
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State Quarter from {:?}!&quot;,state);
            25
        },
    }
}

fn main() {

    // let coin = Coin::Penny;
    println!(&quot;Penny {}&quot;,value_in_cents(Coin::Penny));
    println!(&quot;Nickel {}&quot;,value_in_cents(Coin::Nickel));
    println!(&quot;Dime {}&quot;,value_in_cents(Coin::Dime));
    println!(&quot;Quarter {}&quot;,value_in_cents(Coin::Quarter(UsState::Alaska)));
}
</code></pre>
<h3>Matching with <code>Option</code></h3>
<p>we can also handle <code>Option&lt;T&gt;</code> using <code>match</code> as we did with the <code>Coin</code> enum! Instead of comparing coins, weâ€™ll compare the variants of <code>Option&lt;T&gt;</code>, but the way that the <code>match</code> expression works remains the same.</p>
<pre><code class="language-rust">fn main() {
    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}
</code></pre>
<h3>Matches Are Exhaustive</h3>
<p>Thereâ€™s one other aspect of <code>match</code> we need to discuss. Consider this version of our <code>plus_one</code> function that has a bug and wonâ€™t compile:</p>
<pre><code class="language-rust">fn main() {
    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}
</code></pre>
<p><strong>We didnâ€™t handle the <code>None</code> case, so this code will cause a bug.</strong></p>
<p>ä½¿ç”¨<code>_</code>æ¥æ¥å—å…¶ä»–æƒ…å†µ</p>
<pre><code class="language-rust">fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
}
</code></pre>
<p>ç­‰äº</p>
<pre><code class="language-rust">fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
}
</code></pre>
<h2>Concise Control Flow with <code>if let</code></h2>
<p>å¦‚æœæœ‰å¦‚ä¸‹ä»£ç </p>
<pre><code class="language-rust">fn main() {
    let config_max = Some(3u8);
    match config_max {
        Some(max) =&gt; println!(&quot;The maximum is configured to be {}&quot;, max),
        _ =&gt; (),
    }
}
</code></pre>
<p>å¯ä»¥è¢«<code>if let </code>ç®€åŒ–ä¸º</p>
<pre><code class="language-rust">fn main() {
    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!(&quot;The maximum is configured to be {}&quot;, max);
    }
}
</code></pre>
<p>If we wanted to count all non-quarter coins we see while also announcing the state of the quarters, we could do that with a <code>match</code> expression like this:</p>
<pre><code class="language-rust">#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn main() {
    let coin = Coin::Penny;
    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
        _ =&gt; count += 1,
    }
}
</code></pre>
<p>Or we could use an <code>if let</code> and <code>else</code> expression like this:</p>
<pre><code class="language-rust">#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn main() {
    let coin = Coin::Penny;
    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!(&quot;State quarter from {:?}!&quot;, state);
    } else {
        count += 1;
    }
}
</code></pre>
<h2><a href="https://doc.rust-lang.org/book/ch06-03-if-let.html#summary">Summary</a></h2>
<p>Weâ€™ve now covered how to use enums to create custom types that can be one of a set of enumerated values. Weâ€™ve shown how the standard libraryâ€™s <code>Option&lt;T&gt;</code> type helps you use the type system to prevent errors. When enum values have data inside them, you can use <code>match</code> or <code>if let</code> to extract and use those values, depending on how many cases you need to handle.</p>
<p>Your Rust programs can now express concepts in your domain using structs and enums. Creating custom types to use in your API ensures type safety: the compiler will make certain your functions get only values of the type each function expects.</p>
<p>In order to provide a well-organized API to your users that is straightforward to use and only exposes exactly what your users will need, letâ€™s now turn to Rustâ€™s modules.</p>
<h1>7-Managing Growing Projects with Packages, Crates, and Modules</h1>
<p>The programs weâ€™ve written so far have been in one module in one file.</p>
<p>once youâ€™ve implemented an operation, other code can call that code via the codeâ€™s public interface without knowing how the implementation works.</p>
<p>These features, sometimes collectively referred to as the <em>module system</em>æ¨¡å—ç³»ç»Ÿ, include:</p>
<ul>
<li><strong>Packages:</strong> A Cargo feature that lets you build, test, and share crates</li>
<li><strong>Crates:</strong> A tree of modules that produces a library or executable</li>
<li><strong>Modules</strong> and <strong>use:</strong> Let you control the organization, scope, and privacy of paths</li>
<li><strong>Paths:</strong> A way of naming an item, such as a struct, function, or module</li>
</ul>
<h2>Packages and Crates</h2>
<p>Letâ€™s walk through what happens when we create a package. First, we enter the command <code>cargo new</code>:</p>
<ul>
<li>Cargo.toml
<ul>
<li>Cargo follows a convention that <em>src/main.rs</em> is the crate root of a binary crate with the same name as the package.</li>
<li>Likewise, Cargo knows that if the package directory contains <em>src/lib.rs</em>, the package contains a library crate with the same name as the package, and <em>src/lib.rs</em> is its crate root.</li>
<li>Here, we have a package that only contains <em>src/main.rs</em>, meaning it only contains a binary crate named <code>my-project</code>.</li>
<li>A package can have multiple binary crates by placing files in the <em>src/bin</em> directory: each file will be a separate binary crate.</li>
</ul>
</li>
</ul>
<h2>Defining Modules to Control Scope and Privacy</h2>
<p>src/lib.rs</p>
<pre><code class="language-rust">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
</code></pre>
<p>We define a module by starting with the <code>mod</code> keyword and then specify the name of the module (in this case, <code>front_of_house</code>)</p>
<p><strong>By using modules, we can group related definitions together and name why theyâ€™re related.</strong></p>
<p>Listing 7-2 shows the module tree for the structure in Listing 7-1.</p>
<pre><code>crate
 â””â”€â”€ front_of_house
     â”œâ”€â”€ hosting
     â”‚   â”œâ”€â”€ add_to_waitlist
     â”‚   â””â”€â”€ seat_at_table
     â””â”€â”€ serving
         â”œâ”€â”€ take_order
         â”œâ”€â”€ serve_order
         â””â”€â”€ take_payment
</code></pre>
<p>è¿™ä¸ªè¯´æ˜äº†æ¨¡å¼æ˜¯å¯ä»¥åµŒå¥—çš„ï¼Œå¯ä»¥ç±»æ¯”è®¡ç®—æœºçš„æ–‡ä»¶ç³»ç»Ÿ</p>
<h2>Paths for Referring to an Item in the Module Tree</h2>
<p>A path can take two forms:</p>
<ul>
<li>An <em>absolute path</em> starts from a crate root by using a crate name or a literal <code>crate</code>.</li>
<li>A <em>relative path</em> starts from the current module and uses <code>self</code>, <code>super</code>, or an identifier in the current module.</li>
</ul>
<p><strong>Letâ€™s return to the example in Listing 7-1. How do we call the <code>add_to_waitlist</code> function?</strong></p>
<p>using the <code>crate</code> name to start from the crate root is like using <code>/</code> to start from the filesystem root in your shell.</p>
<p>è¯¥ç¨‹åºæ˜¯æœ‰é—®é¢˜çš„</p>
<pre><code class="language-rust">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><strong>Our preference is to specify absolute paths because itâ€™s more likely to move code definitions and item calls independently of each other</strong></p>
<p><strong>The <code>pub</code> keyword on a module only lets code in its ancestor modules refer to it.</strong></p>
<p><strong>rusté»˜è®¤æ¨¡å¼æ˜¯ç§æœ‰çš„</strong></p>
<p>å¦‚ä½•è®¿é—®</p>
<pre><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<h3>Starting Relative Paths with <code>super</code></h3>
<p>We can also construct relative paths that begin in the parent module by using <code>super</code> at the start of the path. <code>super</code>è®¿é—®ä¸Šçº§ç›®å½•çš„å‡½æ•°ï¼Œæœ‰ç‚¹åƒ<code>..</code>çš„è®¿é—®</p>
<pre><code class="language-rust">fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
</code></pre>
<h3>Making Structs and Enums Public</h3>
<p>åŒæ ·ä¹Ÿæ˜¯<code>pub</code>çš„ç”¨æ³•</p>
<pre><code class="language-rust">mod back_of_house {
    pub struct Breakfast {
        pub toast: String, 
        seasonal_fruit: String,
    }
    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;Peaches&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;);
    meal.toast = String::from(&quot;Wheat&quot;);
    println!(&quot;I'd like {} toast please&quot;,meal.toast);
}
</code></pre>
<h2>Bringing Paths into Scope with the <code>use</code> Keyword</h2>
<p>å¯¹æ¯æ¬¡éƒ½è¦è°ƒç”¨çš„å‡½æ•°ï¼Œæœ‰æ›´ç®€å•çš„æ–¹æ³•æ¥é¿å…rustçš„é‡å¤å¯»å€</p>
<p>åƒæ˜¯ä»</p>
<pre><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    front_of_house::hosting::add_to_waitlist();
    front_of_house::hosting::add_to_waitlist();
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p>å¯ä»¥ä½¿ç”¨<code>use</code>å…³é”®å­—å˜ä¸º</p>
<pre><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre>
<h3>Creating Idiomatic <code>use</code> Paths</h3>
<p>Bringing the functionâ€™s parent module into scope with <code>use</code> means we have to specify the parent module when calling the function.</p>
<pre><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
</code></pre>
<p>å¦‚æœæœ‰å¤šä¸ªç±»ä¸­å®šä¹‰äº†<code>add_to_waitlist</code>å‡½æ•°ï¼Œä¸Šé¢çš„ä½¿ç”¨ä¼šè®©æˆ‘ä»¬ä¸çŸ¥é“<code>eat_at_restaurant</code>çš„ä¸­çš„æ˜¯å±äºå“ªä¸ªç±»</p>
<p>ä¸‹é¢çš„ä¾‹å­ä½¿ç”¨æ ‡å‡†åº“ä¸­çš„å“ˆå¸Œå‡½æ•°è®¡ç®—æ¥ä½¿ç”¨æƒ¯ç”¨æ–¹å¼ç®¡ç†hashç»“æ„ä½“</p>
<p>src/main.rs</p>
<pre><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 1);
}
</code></pre>
<p>Thereâ€™s no strong reason behind this idiom: itâ€™s just the convention that has emerged, and folks have gotten used to reading and writing Rust code this way.</p>
<p>Listing 7-15 shows how to bring two <code>Result</code> types into scope that have the same name but different parent modules and how to refer to them.</p>
<pre><code class="language-rust">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
    Ok(())
}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
    Ok(())
}
</code></pre>
<h3>Providing New Names with the <code>as</code> Keyword</h3>
<p>å’Œpythonçš„<code>as</code>å…³é”®å­—ç”¨æ³•å·®ä¸å¤š</p>
<h3>Re-exporting Names with <code>pub use</code></h3>
<p>To enable the code that calls our code to refer to that name as if it had been defined in that codeâ€™s scope, we can combine <code>pub</code> and <code>use</code>.</p>
<pre><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre>
<p>Re-exporting is useful when the internal structure of your code is different from how programmers calling your code would think about the domain.</p>
<h3>Using External Packages</h3>
<p>å°±åƒç« èŠ‚2ä¸­è¯´åˆ°çš„é‚£æ ·,éœ€è¦åœ¨<code>toml</code>ä¸­åŠ å…¥åº“</p>
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
<p>ä¹‹åå°±å¯ä»¥ä½¿ç”¨äº†</p>
<h3>Using Nested Paths to Clean Up Large <code>use</code> Lists</h3>
<p>å½“ä½ ä¸€æ¬¡è¦å¯¼å…¥å¤šä¸ªmodä¸­çš„fnæ—¶ï¼Œå¯ä»¥ä½¿ç”¨å¦‚ä¸‹åµŒå¥—(GoæŠ„äº†å±äºæ˜¯)</p>
<pre><code class="language-rust">use rand::Rng;
// --snip--
use std::{cmp::Ordering, io};
// --snip--

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p>ç”šè‡³å¯ä»¥æŠŠè‡ªèº«åµŒå¥—ä½¿ç”¨</p>
<pre><code class="language-rust">use std::io::{self, Write};
</code></pre>
<h3>The Glob Operator</h3>
<p>ä½¿ç”¨modä¸­çš„å…¨éƒ¨å†…å®¹ï¼Œç±»ä¼¼pythonçš„<code>from libs import *</code>,rustæœ‰</p>
<pre><code class="language-rust">#![allow(unused)]
fn main() {
use std::collections::*;
}
</code></pre>
<h2>Separating Modules into Different Files</h2>
<p>For example, letâ€™s start from the code in Listing 7-17 and move the <code>front_of_house</code> module to its own file <em>src/front_of_house.rs</em> by changing the crate root file so it contains the code shown in Listing 7-21. In <strong>this case, the crate root file is <em>src/lib.rs</em>, but this procedure also works with binary crates whose crate root file is <em>src/main.rs</em>.</strong></p>
<p>é¦–å…ˆæ˜¯src/lib.rs</p>
<pre><code class="language-rust">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre>
<p>æ¥ç€æ˜¯src/front_of_house.rs</p>
<pre><code class="language-rust">pub mod hosting {
    pub fn add_to_waitlist() {}
}
</code></pre>
<p>æœ€ååœ¨åœ¨src/front_of_house/hosting.rsä¸­å®ç°<code>add_to_waitlist</code></p>
<pre><code class="language-rust">#![allow(unused)]
fn main() {
pub fn add_to_waitlist() {}
}
</code></pre>
<h2>Summary</h2>
<p>Rust lets you split a package into multiple crates and a crate into modules so you can refer to items defined in one module from another module. You can do this by specifying absolute or relative paths. These paths can be brought into scope with a <code>use</code> statement so you can use a shorter path for multiple uses of the item in that scope. Module code is private by default, but you can make definitions public by adding the <code>pub</code> keyword.</p>
<p>In the next chapter, weâ€™ll look at some collection data structures in the standard library that you can use in your neatly organized code.</p>
<h1>8-Common Collections</h1>
<p>rustå®˜æ–¹åº“æœ‰äº›å¾ˆæœ‰ç”¨çš„æ•°æ®ç»“æ„è¢«ç§°ä½œä¸º'collections'.</p>
<p>è¿™äº›collectionsæŒ‡é’ˆæ˜¯è¢«å­˜å‚¨åœ¨heapä¸­çš„</p>
<p>æ„Ÿè§‰ç±»ä¼¼äºc++çš„STLä¸­çš„å®¹å™¨</p>
<ul>
<li>A <em>vector</em> allows you to store a variable number of values next to each other.</li>
<li>A <em>string</em> is a collection of characters. Weâ€™ve mentioned the <code>String</code> type previously, but in this chapter weâ€™ll talk about it in depth.</li>
<li>A <em>hash map</em> allows you to associate a value with a particular key. Itâ€™s a particular implementation of the more general data structure called a <em>map</em>.</li>
</ul>
<h2>Storing Lists of Values with Vectors</h2>
<p>æœ¬èŠ‚æ•™ç¨‹æ•™å­¦<code>vector</code>å®¹å™¨</p>
<pre><code class="language-rust">fn main() {
	let v: Vec&lt;i32&gt; = Vec::new();
}
</code></pre>
<p><strong>Vectors are implemented using generics</strong>ï¼Œç›¸å½“äºåˆ›å»ºäº†ä¸€ä¸ªvectoræŒ‡é’ˆ</p>
<pre><code class="language-rust">    //ç»™vectoråˆ›å»ºåˆå§‹å€¼
    let v2 = vec![1,2,3];
</code></pre>
<h3>Updating a Vector</h3>
<p>ä½¿ç”¨<code>push</code>å‡½æ•°</p>
<pre><code class="language-rust">    //Update a Vector
    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
</code></pre>
<p><strong>if we want to be able to change its value, we need to make it mutable using the <code>mut</code> keyword, as discussed in Chapter 3.</strong></p>
<h3>Dropping a Vector Drops Its Elements</h3>
<p>Like any other <code>struct</code>, a vector is freed when it goes out of scope, as annotated in Listing 8-4.</p>
<p>å½“ä¸€ä¸ªvectorè¢«é‡Šæ”¾æ—¶ï¼Œå®ƒçš„æˆå‘˜ä¹Ÿä¼šè¢«é‡Šæ”¾æ‰</p>
<h3>Reading Elements of Vectors</h3>
<p>ä¸¤ç§è®¿é—®vectorå…ƒç´ çš„æ–¹æ³•</p>
<pre><code class="language-rust">    let v2 = vec![1,2,3,4,5];
    let third: &amp;i32 = &amp;v2[2];
    println!(&quot;the third ele is {}&quot;,third);

    match v2.get(2) {
        Some(third) =&gt; println!(&quot;The third ele is {}&quot;,third),
        None =&gt; println!(&quot;no third ele&quot;),
    }
</code></pre>
<ol>
<li>
<p>ä½¿ç”¨ç›´æ¥å¼•ç”¨<code>&amp;v2[idx]</code></p>
</li>
<li>
<p>ä½¿ç”¨<code>get</code>æ–¹æ³•åï¼Œä½¿ç”¨matchæ¥åˆ¤æ–­å…ƒç´ ä¸å­˜</p>
</li>
</ol>
<p>å½“ç›´æ¥ä¸‹æ ‡è®¿é—®æ—¶ï¼Œè‹¥å…ƒç´ ä¸å­˜åœ¨ï¼Œä¼šç›´æ¥æŠ¥é”™</p>
<p>å…³äºvectorå¼•ç”¨ï¼ŒåŒæ ·ä¼šå› ä¸ºreference å’Œ borrowåŸåˆ™å‡ºç°æŠ¥é”™ï¼Œå¦‚</p>
<pre><code class="language-rust">fn main() {
    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!(&quot;The first element is: {}&quot;, first);
}
</code></pre>
<p>åŸå› æ—¶firståˆ›å»ºäº†ä¸€ä¸ª<strong>ä¸å¯å˜</strong>çš„borrowï¼ŒåŒæ—¶v.pushæ–¹æ³•æœ‰ä½¿ç”¨äº†<strong>å¯å˜</strong>çš„borrowã€‚</p>
<h3>Iterating over the Values in a Vector</h3>
<p>åˆ©ç”¨è¿­ä»£å™¨è®¿é—®å®¹å™¨</p>
<p>æœ€ç®€å•çš„æ˜¯ä½¿ç”¨<code>for</code>è¯­å¥</p>
<pre><code class="language-rust">    {
        let v = vec![100,32,57];
        for i in &amp;v{
            println!(&quot;{}&quot;,i);
        }

        let mut v = vec![100,32,57];
        for i in &amp;mut v {
            *i += 50;
        }
    }
</code></pre>
<p>è¿™é‡Œè¦å¯¹vä¸­å…ƒç´ å€¼è¿›è¡Œä¿®æ”¹ï¼Œè¦ä½¿ç”¨<code>*</code>è§£å¼•ç”¨æ‰èƒ½è®¿é—®åˆ°æ•°å€¼å¹¶ä¿®æ”¹</p>
<p>Weâ€™ll talk more about the dereference operator in the <a href="https://doc.rust-lang.org/book/ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">â€œFollowing the Pointer to the Value with the Dereference Operatorâ€</a></p>
<h3>Using an Enum to Store Multiple Types</h3>
<p>say we want to get values from a row in a spreadsheet in which some of the columns in the row contain integers, some floating-point numbers, and some strings. We can define an enum whose variants will hold the different value types, and then all the enum variants will be considered the same type: that of the enum. Then we can create a vector that holds that enum and so, ultimately, holds different types.</p>
<pre><code class="language-rust">    //Part`3: Using an Enum to Store Multiple Types
    {
        enum SperateSheetCell {
            Int(i32),
            Float(f64),
            Text(String),
        }

        let row = vec![
            SperateSheetCell::Int(3),
            SperateSheetCell::Float(30.0),
            SperateSheetCell::Text(String::from(&quot;hello&quot;)),
        ]
    }
</code></pre>
<p>Rust needs to know what types will be in the vector at compile time so it knows exactly how much memory on the heap will be needed to store each element.</p>
<h2>Storing UTF-8 Encoded Text with Strings</h2>
<blockquote>
<h3><a href="https://doc.rust-lang.org/book/ch08-02-strings.html#what-is-a-string">What Is a String?</a></h3>
<p>Weâ€™ll first define what we mean by the term <em>string</em>. Rust has only one string type in the core language, which is the string slice <code>str</code> that is usually seen in its borrowed form <code>&amp;str</code>. In Chapter 4, we talked about <em>string slices</em>, which are references to some UTF-8 encoded string data stored elsewhere. String literals, for example, are stored in the programâ€™s binary and are therefore string slices.</p>
<p>The <code>String</code> type, which is provided by Rustâ€™s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to â€œstringsâ€ in Rust, they usually mean the <code>String</code> and the string slice <code>&amp;str</code> types, not just one of those types. Although this section is largely about <code>String</code>, both types are used heavily in Rustâ€™s standard library, and both <code>String</code> and string slices are UTF-8 encoded.</p>
<p>Rustâ€™s standard library also includes a number of other string types, such as <code>OsString</code>, <code>OsStr</code>, <code>CString</code>, and <code>CStr</code>. Library crates can provide even more options for storing string data. See how those names all end in <code>String</code> or <code>Str</code>? They refer to owned and borrowed variants, just like the <code>String</code> and <code>str</code> types youâ€™ve seen previously. These string types can store text in different encodings or be represented in memory in a different way, for example. We wonâ€™t discuss these other string types in this chapter; see their API documentation for more about how to use them and when each is appropriate.</p>
</blockquote>
<p>ä»€ä¹ˆæ˜¯å­—ç¬¦ä¸²ï¼Ÿ
æˆ‘ä»¬å°†é¦–å…ˆå®šä¹‰æœ¯è¯­å­—ç¬¦ä¸²çš„å«ä¹‰ã€‚ Rust åœ¨æ ¸å¿ƒè¯­è¨€ä¸­åªæœ‰ä¸€ç§å­—ç¬¦ä¸²ç±»å‹ï¼Œå³é€šå¸¸ä»¥å€Ÿç”¨å½¢å¼ &amp;str çœ‹åˆ°çš„å­—ç¬¦ä¸²åˆ‡ç‰‡ strã€‚åœ¨ç¬¬ 4 ç« ä¸­ï¼Œæˆ‘ä»¬è®¨è®ºäº†å­—ç¬¦ä¸²åˆ‡ç‰‡ï¼Œå®ƒæ˜¯å¯¹å­˜å‚¨åœ¨å…¶ä»–åœ°æ–¹çš„ä¸€äº› UTF-8 ç¼–ç å­—ç¬¦ä¸²æ•°æ®çš„å¼•ç”¨ã€‚ä¾‹å¦‚ï¼Œå­—ç¬¦ä¸²æ–‡å­—å­˜å‚¨åœ¨ç¨‹åºçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œå› æ­¤æ˜¯å­—ç¬¦ä¸²åˆ‡ç‰‡ã€‚</p>
<p>String ç±»å‹ç”± Rust çš„æ ‡å‡†åº“æä¾›è€Œä¸æ˜¯ç¼–ç åˆ°æ ¸å¿ƒè¯­è¨€ä¸­ï¼Œå®ƒæ˜¯ä¸€ç§å¯å¢é•¿ã€å¯å˜ã€æ‹¥æœ‰ã€UTF-8 ç¼–ç çš„å­—ç¬¦ä¸²ç±»å‹ã€‚å½“ Rustaceans åœ¨ Rust ä¸­æåˆ°â€œå­—ç¬¦ä¸²â€æ—¶ï¼Œä»–ä»¬é€šå¸¸æŒ‡çš„æ˜¯ String å’Œå­—ç¬¦ä¸² slice &amp;str ç±»å‹ï¼Œè€Œä¸ä»…ä»…æ˜¯è¿™äº›ç±»å‹ä¸­çš„ä¸€ç§ã€‚è™½ç„¶æœ¬èŠ‚ä¸»è¦æ˜¯å…³äºå­—ç¬¦ä¸²ï¼Œä½†è¿™ä¸¤ç§ç±»å‹åœ¨ Rust çš„æ ‡å‡†åº“ä¸­éƒ½è¢«å¤§é‡ä½¿ç”¨ï¼Œå¹¶ä¸”å­—ç¬¦ä¸²å’Œå­—ç¬¦ä¸²åˆ‡ç‰‡éƒ½æ˜¯ UTF-8 ç¼–ç çš„ã€‚</p>
<p>Rust çš„æ ‡å‡†åº“è¿˜åŒ…æ‹¬è®¸å¤šå…¶ä»–å­—ç¬¦ä¸²ç±»å‹ï¼Œä¾‹å¦‚ <code>OsString</code>ã€<code>OsStr</code>ã€<code>CString </code>å’Œ <code>CStr</code>ã€‚ Library crate å¯ä»¥æä¾›æ›´å¤šé€‰é¡¹æ¥å­˜å‚¨å­—ç¬¦ä¸²æ•°æ®ã€‚çœ‹çœ‹è¿™äº›åå­—éƒ½æ˜¯å¦‚ä½•ä»¥ String æˆ– Str ç»“å°¾çš„ï¼Ÿå®ƒä»¬æŒ‡çš„æ˜¯æ‹¥æœ‰å’Œå€Ÿç”¨çš„å˜ä½“ï¼Œå°±åƒæ‚¨ä¹‹å‰çœ‹åˆ°çš„ <code>String </code>å’Œ <code>str </code>ç±»å‹ä¸€æ ·ã€‚ä¾‹å¦‚ï¼Œè¿™äº›å­—ç¬¦ä¸²ç±»å‹å¯ä»¥ä»¥ä¸åŒçš„ç¼–ç å­˜å‚¨æ–‡æœ¬æˆ–ä»¥ä¸åŒçš„æ–¹å¼åœ¨å†…å­˜ä¸­è¡¨ç¤ºã€‚æˆ‘ä»¬ä¸ä¼šåœ¨æœ¬ç« ä¸­è®¨è®ºè¿™äº›å…¶ä»–å­—ç¬¦ä¸²ç±»å‹ï¼›è¯·å‚é˜…ä»–ä»¬çš„ API æ–‡æ¡£ï¼Œäº†è§£æœ‰å…³å¦‚ä½•ä½¿ç”¨å®ƒä»¬ä»¥åŠä½•æ—¶ä½¿ç”¨å®ƒä»¬çš„æ›´å¤šä¿¡æ¯ã€‚</p>
<h3><a href="https://doc.rust-lang.org/book/ch08-02-strings.html#creating-a-new-string">Creating a New String</a></h3>
<p>å’Œåˆ›å»ºvectorå·®ä¸å¤š</p>
<pre><code class="language-rust">let mut s = String::new();
</code></pre>
<p>This line creates a new empty string called <code>s</code>, which we can then load data into.</p>
<pre><code class="language-rust">    {
        //åˆ›å»ºä¸€ä¸ªå­—ç¬¦ä¸²ç±»å‹
        let mut s = String::new();//sç±»å‹æ˜¯String

        //strè½¬String
        let data = &quot;initial contents&quot;;

        let s = data.to_string();

        let s = &quot;initial contents2&quot;.to_string();
    }
</code></pre>
<p>è¿˜æœ‰å°±æ˜¯æœ€å¸¸ç”¨çš„<code>String::from()</code></p>
<h3>Updating a String</h3>
<p>if you push more data into it. In addition, you can conveniently use the <code>+</code> operator or the <code>format!</code> macro to concatenate <code>String</code> values.</p>
<h4>Appending to a String with <code>push_str</code> and <code>push</code></h4>
<ul>
<li>
<p>We can grow a <code>String</code> by using the <code>push_str</code> method to append a string slice</p>
<pre><code class="language-rust">    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
</code></pre>
<p>The <code>push_str</code> method takes a string slice because we donâ€™t necessarily want to take ownership of the parameter.</p>
<p>å…³äºä»å±å…³ç³»</p>
<pre><code class="language-rust">fn main() {
    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = &quot;bar&quot;;
    s1.push_str(s2);
    println!(&quot;s2 is {}&quot;, s2);
}
</code></pre>
</li>
<li>
<p>The <code>push</code> method takes a single character as a parameter and adds it to the <code>String</code>.</p>
<pre><code class="language-rust">    let mut s = String::from(&quot;lo&quot;);
    s.push('l');
</code></pre>
</li>
</ul>
<h4>Concatenation with the <code>+</code> Operator or the <code>format!</code> Macro</h4>
<ul>
<li>
<p>ä½¿ç”¨<code>+</code>è¿æ¥ä¸¤ä¸ªå­—ç¬¦ä¸²</p>
<pre><code class="language-rust">            let s1 = String::from(&quot;Hello, &quot;);
            let s2 = String::from(&quot;world!&quot;);
            let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
</code></pre>
<p>æ­¤æ—¶çš„s3å°±æ˜¯åŸæ¥çš„s1ï¼ŒåŸå› å¦‚ä¸‹</p>
<p><strong>The reason <code>s1</code> is no longer valid after the addition and the reason we used a reference to <code>s2</code> has to do with the signature of the method that gets called when we use the <code>+</code> operator. The <code>+</code> operator uses the <code>add</code> method, whose signature looks something like this:</strong></p>
<pre><code class="language-rust">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>But waitâ€”the type of <code>&amp;s2</code> is <code>&amp;String</code>, not <code>&amp;str</code>, as specified in the second parameter to <code>add</code>. So why does Listing 8-18 compile?</p>
<p>the compiler can <em>coerce</em> the <code>&amp;String</code> argument into a <code>&amp;str</code>.//å¼ºåˆ¶è½¬æ¢</p>
<p>we can see in the signature that <code>add</code> takes ownership of <code>self</code>, because <code>self</code> does <em>not</em> have an <code>&amp;</code>. This means <code>s1</code> in Listing 8-18 will be moved into the <code>add</code> call and no longer be valid after that.</p>
</li>
<li>
<p>If we need to concatenate multiple strings, the behavior of the <code>+</code> operator gets unwieldy:</p>
<pre><code class="language-rust">fn main() {
    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
}
</code></pre>
</li>
</ul>
<h3>Indexing into Strings</h3>
<p><strong>Rust strings donâ€™t support indexing.</strong></p>
<h4>Internal Representation</h4>
<p>åœ¨rustä¸­ï¼ŒStringå¯ä»¥å­˜å‚¨unicodeç±»å‹ï¼Œä¸åŒç±»å‹çš„å­˜å‚¨é•¿åº¦å¯¼è‡´æ— æ³•æ‰¾åˆ°ä½ç½®</p>
<p>What should the value of <code>answer</code> be? Should it be <code>Ğ—</code>, the first letter? When encoded in UTF-8, the first byte of <code>Ğ—</code> is <code>208</code> and the second is <code>151</code>, so <code>answer</code> should in fact be <code>208</code>, but <code>208</code> is not a valid character on its own. Returning <code>208</code> is likely not what a user would want if they asked for the first letter of this string; however, thatâ€™s the only data that Rust has at byte index 0. Users generally donâ€™t want the byte value returned, even if the string contains only Latin letters: if <code>&amp;&quot;hello&quot;[0]</code> were valid code that returned the byte value, it would return <code>104</code>, not <code>h</code>. To avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesnâ€™t compile this code at all and prevents misunderstandings early in the development process.</p>
<h4>Bytes and Scalar Values and Grapheme Clusters! Oh My!</h4>
<p>Another point about UTF-8 is that there are actually three relevant ways to look at strings from Rustâ€™s perspective: as <strong>bytes</strong>, <strong>scalar values</strong>, and <strong>grapheme clusters</strong></p>
<p>Rust provides different ways of interpreting the raw string data that computers store so that each program can choose the interpretation it needs, no matter what human language the data is in.</p>
<h3>Slicing Strings</h3>
<p>Rust asks you to be more specific if you really need to use indices to create string slices. To be more specific in your indexing and indicate that you want a string slice, rather than indexing using <code>[]</code> with a single number, you can use <code>[]</code> with a range to create a string slice containing particular bytes:</p>
<pre><code class="language-rust">            let hello = &quot;Ğ—Ğ´Ñ€Ğ°Ğ²ÑÑ‚Ğ²ÑƒĞ¹Ñ‚Ğµ&quot;;
            let s = &amp;hello[0..4];
</code></pre>
<h3>Methods for Iterating Over Strings</h3>
<p>If you need to perform operations on individual Unicode scalar values, the best way to do so is to use the <code>chars</code> method.</p>
<p>ä½¿ç”¨<code>chars</code>å‡½æ•°</p>
<pre><code class="language-rust">for c in &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
</code></pre>
<p>The <code>bytes</code> method returns each raw byte, which might be appropriate for your domain:</p>
<pre><code class="language-rust">for b in &quot;à¤¨à¤®à¤¸à¥à¤¤à¥‡&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
</code></pre>
<p>ç»“æœ</p>
<pre><code>224
164
// --snip--
165
135
</code></pre>
<h3>Strings Are Not So Simple</h3>
<p>To summarize, strings are complicated. Different programming languages make different choices about how to present this complexity to the programmer. Rust has chosen to make the correct handling of <code>String</code> data the default behavior for all Rust programs, which means programmers have to put more thought into handling UTF-8 data upfront. This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle.</p>
<h2>Storing Keys with Associated Values in Hash Maps</h2>
<h3>Creating a New Hash Map</h3>
<p>åŒä¸Šé¢ä¸¤ä¸ªå·®ä¸å¤šï¼Œä½¿ç”¨<code>new</code>åˆ›å»ºï¼Œ<code>insert</code>åŠ å…¥å€¼</p>
<pre><code class="language-rust">        use std::collections::HashMap;
        let mut socers = HashMap::new();

        socers.insert(String::from(&quot;Blue&quot;),10);
        socers.insert(String::from(&quot;Yellow&quot;), 50);
</code></pre>
<p>åˆ›å»ºäº†Buel:10ï¼ŒYellow:50ï¼Œä¸¤ä¸ªkv</p>
<p>ä½¿ç”¨iterators and the <code>collect</code> method on a vector of tuples, where each tuple consists of a key and its value.</p>
<pre><code class="language-rust">        use std::collections::HashMap;
        let teams = vec![String::from(&quot;Bule&quot;),String::from(&quot;Yellow&quot;)];
        let initial_scores = vec![10,50];

        let mut scores: HashMap&lt;_,_&gt; = 
            teams.into_iter().zip(initial_scores.into_iter()).collect();
</code></pre>
<h3>Hash Maps and Ownership</h3>
<pre><code class="language-rust">        use std::collections::HashMap;

        let field_name = String::from(&quot;Favorite color&quot;);
        let field_value = String::from(&quot;Blue&quot;);
    
        let mut map = HashMap::new();
        map.insert(field_name, field_value);
        // field_name and field_value are invalid at this point, try using them and
        // see what compiler error you get!
</code></pre>
<p>è¿™æ ·çš„è¯ï¼Œ<code>field_name</code>å’Œ<code>field_value</code>ä¼šå˜æˆmapçš„ä»å±ï¼Œå°±ä¸èƒ½å†è¢«è®¿é—®åˆ°äº†</p>
<h3>Accessing Values in a Hash Map</h3>
<p>ä½¿ç”¨<code>get</code>æ–¹æ³•</p>
<pre><code class="language-rust">    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    let team_name = String::from(&quot;Blue&quot;);
    let score = scores.get(&amp;team_name);
</code></pre>
<p>the result will be <code>Some(&amp;10)</code>. The result is wrapped in <code>Some</code> because <code>get</code> returns an <code>Option&lt;&amp;V&gt;</code>; if thereâ€™s no value for that key in the hash map, <code>get</code> will return <code>None</code>. The program will need to handle the <code>Option</code> in one of the ways that we covered in Chapter 6.</p>
<p>ä½¿ç”¨<code>for</code>å¾ªç¯è®¿é—®</p>
<pre><code class="language-rust">    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    for (key, value) in &amp;scores {
        println!(&quot;{}: {}&quot;, key, value);
    }
</code></pre>
<p>ç›´æ¥ä½¿ç”¨å¼•ç”¨è®¿é—®</p>
<h3>Updating a Hash Map</h3>
<h4>Overwriting a Value</h4>
<p>ç›´æ¥ä½¿ç”¨<code>insert</code>å³å¯è¦†ç›–</p>
<pre><code class="language-rust">    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Blue&quot;), 25);
</code></pre>
<h4>Only Inserting a Value If the Key Has No Value</h4>
<p><strong>Hash maps have a special API for this called <code>entry</code> that takes the key you want to check as a parameter.</strong></p>
<pre><code class="language-rust">    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from(&quot;Blue&quot;), 10);

    scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
    scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

    println!(&quot;{:?}&quot;, scores);
</code></pre>
<h4>Updating a Value Based on the Old Value</h4>
<p>Listing 8-26 shows code that counts how many times each word appears in some text.</p>
<pre><code class="language-rust">        //update based on old value
        use std::collections::HashMap;

        let text = &quot;hello world wonderful world&quot;;
    
        let mut map = HashMap::new();
    
        for word in text.split_whitespace() {
            let count = map.entry(word).or_insert(0);
            *count += 1;
        }
    
        println!(&quot;{:?}&quot;, map);
</code></pre>
<h3>Hashing Functions</h3>
<p>By default, <code>HashMap</code> uses a hashing function called SipHash that can provide resistance to Denial of Service (DoS) attacks involving hash tables<a href="https://doc.rust-lang.org/book/ch08-03-hash-maps.html#siphash">1</a>. This is not the fastest hashing algorithm available, but the trade-off for better security that comes with the drop in performance is worth it. If you profile your code and find that the default hash function is too slow for your purposes, you can switch to another function by specifying a different <em>hasher</em>. A hasher is a type that implements the <code>BuildHasher</code> trait. Weâ€™ll talk about traits and how to implement them in Chapter 10. You donâ€™t necessarily have to implement your own hasher from scratch; <a href="https://crates.io/">crates.io</a> has libraries shared by other Rust users that provide hashers implementing many common hashing algorithms.</p>
<h2>Summary</h2>
<p>Vectors, strings, and hash maps will provide a large amount of functionality necessary in programs when you need to store, access, and modify data. Here are some exercises you should now be equipped to solve:</p>
<ul>
<li>Given a list of integers, use a vector and return the mean (the average value), median (when sorted, the value in the middle position), and mode (the value that occurs most often; a hash map will be helpful here) of the list.</li>
<li>Convert strings to pig latin. The first consonant of each word is moved to the end of the word and â€œayâ€ is added, so â€œfirstâ€ becomes â€œirst-fay.â€ Words that start with a vowel have â€œhayâ€ added to the end instead (â€œappleâ€ becomes â€œapple-hayâ€). Keep in mind the details about UTF-8 encoding!</li>
<li>Using a hash map and vectors, create a text interface to allow a user to add employee names to a department in a company. For example, â€œAdd Sally to Engineeringâ€ or â€œAdd Amir to Sales.â€ Then let the user retrieve a list of all people in a department or all people in the company by department, sorted alphabetically.</li>
</ul>
<p>The standard library API documentation describes methods that vectors, strings, and hash maps have that will be helpful for these exercises!</p>
<p>Weâ€™re getting into more complex programs in which operations can fail, so, itâ€™s a perfect time to discuss error handling. Weâ€™ll do that next!</p>
<h1>9-Error Handling</h1>
<p>In many cases, Rust requires you to acknowledge the possibility of an error and take some action before your code will compile.</p>
<p>Rust groups errors into two major categories: <em>recoverable</em> and <em>unrecoverable</em> errors.</p>
<ul>
<li>
<p>recoverable</p>
<p>such as a file not found error, itâ€™s reasonable to report the problem to the user and retry the operation.</p>
</li>
<li>
<p>Unrecoverable</p>
<p>always symptoms of bugs, like trying to access a location beyond the end of an array.</p>
</li>
</ul>
<p>Rust doesnâ€™t have exceptions. Instead, it has the type <code>Result&lt;T, E&gt;</code> for recoverable errors and the <code>panic!</code> macro that stops execution when the program encounters an unrecoverable error.</p>
<h2>Unrecoverable Errors with <code>panic!</code></h2>
<p>When the <code>panic!</code> macro executes, your program will print a failure message, unwind and clean up the stack, and then quit.</p>
<pre><code class="language-rust">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre>
<pre><code>thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>The first line shows our panic message and the place in our source code where the panic occurred: <em>src/main.rs:2:5</em> indicates that itâ€™s the second line, fifth character of our <em>src/main.rs</em> file.</p>
<p>In other cases, the <code>panic!</code> call might be in code that our code calls, and the filename and line number reported by the <strong>error message will be someone elseâ€™s code where the <code>panic!</code> macro is called, not the line of our code that eventually led to the <code>panic!</code> call.</strong></p>
<h3>Using a <code>panic!</code> Backtrace</h3>
<p>åˆ©ç”¨é”™è¯¯ä»£ç å®ç°å‡½æ•°åè¿½è¸ª</p>
<pre><code class="language-rust">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre>
<pre><code>thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 
99', src/main.rs:3:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>A <em>backtrace</em> is a list of all the functions that have been called to get to this point.</p>
<p><strong>RUST_BACKTRACE</strong></p>
<pre><code class="language-shell">joe1sn@MSI:/mnt/d/Programming/Rust/The Rust Programming Language/9-Error Handling/unrecoverable_error$ RUST_BACKTRACE=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.09s
     Running `target/debug/unrecoverable_error`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 
99', src/main.rs:3:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/std/src/panicking.rs:517:5
   1: core::panicking::panic_fmt
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:101:14
   2: core::panicking::panic_bounds_check
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:77:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:184:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index    
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:15:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/alloc/src/vec/mod.rs:2465:9
   6: unrecoverable_error::main
             at ./src/main.rs:3:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p><strong>Debug symbols are enabled by default when using <code>cargo build</code> or <code>cargo run</code> without the <code>--release</code> flag, as we have here.</strong></p>
<p>Weâ€™ll come back to <code>panic!</code> and when we should and should not use <code>panic!</code> to handle error conditions in the <a href="https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">â€œTo <code>panic!</code> or Not to <code>panic!</code>â€</a> section later in this chapter. Next, weâ€™ll look at how to recover from an error using <code>Result</code>.</p>
<h2>Recoverable Errors with <code>Result</code></h2>
<p>Recall from <a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">â€œHandling Potential Failure with the <code>Result</code> Typeâ€</a> in Chapter 2 that the <code>Result</code> enum is defined as having two variants, <code>Ok</code> and <code>Err</code>, as follows:</p>
<pre><code class="language-rust">fn main() {
    enum Result&lt;T, E&gt; {
        Ok(T),
        Err(E),
    }
}
</code></pre>
<p>åˆ›å»ºä¸€ä¸ªä¸€å®šä¼šå‡ºé”™çš„ç¨‹åº</p>
<pre><code class="language-rust">let f = File::open(&quot;hello.txt&quot;);
</code></pre>
<p>matchçš„éªŒè¯ä»£ç </p>
<pre><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;Problem opening the file: {:?}&quot;, error),
    };
}
</code></pre>
<pre><code>thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace 
</code></pre>
<h3>Matching on Different Errors</h3>
<p>if <code>File::open</code> failed because the file doesnâ€™t exist, we want to create the file and return the handle to the new file.</p>
<p>If <code>File::open</code> failed for any other reasonâ€”for example, because we didnâ€™t have permission to open the fileâ€”we still want the code to <code>panic!</code> in the same way as it did in Listing 9-4.</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem creating new file&quot;),
            },
            other_error =&gt; {
                panic!(&quot;Problem opening the file: {:?}&quot;, other_error)
            }
        },
    };
}
</code></pre>
<p>In Chapter 13, youâ€™ll learn about closures; the <code>Result&lt;T, E&gt;</code> type has many methods that accept a closure and are implemented using <code>match</code> expressions. Using those methods will make your code more concise. A more seasoned Rustacean might write this code instead of Listing 9-5:</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Problem creating the file: {:?}&quot;, error);
            })
        } else {
            panic!(&quot;Problem opening the file: {:?}&quot;, error);
        }
    });
}
</code></pre>
<h3>Shortcuts for Panic on Error: <code>unwrap</code> and <code>expect</code></h3>
<p><strong>unwrap</strong></p>
<pre><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre>
<p>If we run this code without a <em>hello.txt</em> file, weâ€™ll see an error message from the <code>panic!</code> call that the <code>unwrap</code> method makes:</p>
<p><strong>expect</strong></p>
<p>Using <code>expect</code> instead of <code>unwrap</code> and providing good error messages can convey your intent and make tracking down the source of a panic easier.</p>
<pre><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}
</code></pre>
<h3>Propagating Errors</h3>
<p>instead of handling the error within this function, you can return the error to the calling code so that it can decide what to do. This is known as <em>propagating</em> the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.</p>
<p>For example, Listing 9-6 shows a function that reads a username from a file. If the file doesnâ€™t exist or canâ€™t be read, this function will return those errors to the code that called this function.</p>
<pre><code class="language-rust">fn main() {
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
}
</code></pre>
<h4>A Shortcut for Propagating Errors: the <code>?</code> Operator</h4>
<pre><code class="language-rust">fn main() {
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
}
</code></pre>
<pre><code class="language-rust">fn main() {
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
}
</code></pre>
<pre><code class="language-rust">fn main() {
use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
}
</code></pre>
<h4>The <code>?</code> Operator Can Be Used in Functions That Return <code>Result</code></h4>
<p>æŠ¥é”™ç¨‹åº</p>
<pre><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<pre><code>$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:36
  |
3 | / fn main() {
4 | |     let f = File::open(&quot;hello.txt&quot;)?;
  | |                                    ^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`
  = note: required by `from_residual`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling`

To learn more, run the command again with --verbose.
</code></pre>
<p>The <code>main</code> function is special, and there are restrictions on what its return type must be. One valid return type for main is <code>()</code>, and conveniently, another valid return type is <code>Result&lt;T, E&gt;</code>, as shown here:</p>
<pre><code class="language-rust">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let f = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}
</code></pre>
<h2><a href="https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">To <code>panic!</code> or Not to <code>panic!</code></a></h2>
<h2><a href="https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#summary">Summary</a></h2>
<p>Rustâ€™s error handling features are designed to help you write more robust code. The <code>panic!</code> macro signals that your program is in a state it canâ€™t handle and lets you tell the process to stop instead of trying to proceed with invalid or incorrect values. The <code>Result</code> enum uses Rustâ€™s type system to indicate that operations might fail in a way that your code could recover from. You can use <code>Result</code> to tell code that calls your code that it needs to handle potential success or failure as well. Using <code>panic!</code> and <code>Result</code> in the appropriate situations will make your code more reliable in the face of inevitable problems.</p>
<p>Now that youâ€™ve seen useful ways that the standard library uses generics with the <code>Option</code> and <code>Result</code> enums, weâ€™ll talk about how generics work and how you can use them in your code.</p>
<h1>10-Generic Types, Traits, and Lifetimes</h1>
<p>rustä½¿ç”¨æ³›å‹æ¥å¯¹ duplication of concepts å¤„ç†</p>
<p>When weâ€™re writing code, we can express the behavior of generics or how they relate to other generics without knowing what will be in their place when compiling and running the code.</p>
<p>ä¸€äº›ä¹‹å‰ä½¿ç”¨è¿‡çš„ä¾‹å­</p>
<p>like <code>i32</code> or <code>String</code>. In fact, weâ€™ve already used generics in Chapter 6 with <code>Option&lt;T&gt;</code>, Chapter 8 with <code>Vec&lt;T&gt;</code> and <code>HashMap&lt;K, V&gt;</code>, and Chapter 9 with <code>Result&lt;T, E&gt;</code>.</p>
<p>rustä½¿ç”¨ç‰¹å¾<em>traits</em> æ¥å®šä¹‰æ³›å‹çš„è¡Œä¸º</p>
<ul>
<li>First, weâ€™ll review how to extract a function to reduce code duplication.</li>
<li>Then youâ€™ll learn how to use <em>traits</em> to define behavior in a generic way.</li>
<li>Finally, weâ€™ll discuss <em>lifetimes</em>, a variety of generics that give the compiler information about how references relate to each other.</li>
</ul>
<h2>Removing Duplication by Extracting a Function</h2>
<p>Before diving into generics syntax, letâ€™s first look at how to <strong>remove duplication that doesnâ€™t involve generic types by extracting a function</strong>.</p>
<p>src/main.rs</p>
<pre><code class="language-rust">fn main() {
    let number_list = vec![34,35,654,234,12,23];
    let mut largest = number_list[0];
    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre>
<p>ç°åœ¨è¦å¾—åˆ°ä¸¤ä¸ªæ•°åˆ—ä¸­çš„æœ€å¤§æ•°</p>
<pre><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre>
<p>å…¶ä¸­æœ€å¼€å§‹çš„</p>
<pre><code class="language-rust">    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];
</code></pre>
<p>ä¼šè¢«é‡å¤å®šä¹‰</p>
<p>è¿™ä¸ªæ—¶å€™å®šä¹‰æˆå‡½æ•°</p>
<pre><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
    assert_eq!(result, 100);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
    assert_eq!(result, 6000);
}
</code></pre>
<p>In sum, here are the steps we took to change the code from Listing 10-2 to Listing 10-3:</p>
<ol>
<li>Identify duplicate code.</li>
<li>Extract the duplicate code into the body of the function and specify the inputs and return values of that code in the function signature.</li>
<li>Update the two instances of duplicated code to call the function instead.</li>
</ol>
<h2>Generic Data Types</h2>
<p>ç¬¬ä¸€æ—¶é—´æƒ³åˆ°çš„è‚¯å®šæ˜¯c++é‡Œé¢çš„æ³›å‹</p>
<p>æµ‹è¯•ç¨‹åºå¦‚ä¸‹</p>
<pre><code class="language-rust">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<pre><code>error[E0369]: binary operation `&gt;` cannot be applied to type `T`
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ++++++++++++++++++++++

</code></pre>
<p>å…¶ä¸­<code>std::cmp::PartialOrd</code>å°±æ˜¯æ³›å‹çš„ä¸€ä¸ªç‰¹å¾</p>
<p><strong>Because we want to compare values of type <code>T</code> in the body, we can only use types whose values can be ordered. To enable comparisons, the standard library has the <code>std::cmp::PartialOrd</code> trait that you can implement on types (see Appendix C for more on this trait).</strong></p>
<h3>In Struct Definitions</h3>
<p>æ³›å‹ç»“æ„ä½“</p>
<pre><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre>
<p>If we create an instance of a <code>Point&lt;T&gt;</code> that has values of different types, as in Listing 10-7, our code wonâ€™t compile.</p>
<p>è§£å†³è¿™ä¸ªé—®é¢˜å¯ä»¥ä½¿ç”¨</p>
<pre><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}
</code></pre>
<h3><a href="https://doc.rust-lang.org/book/ch10-01-syntax.html#in-enum-definitions">In Enum Definitions</a></h3>
<p>ç•¥ã€‚ã€‚ã€‚</p>
<h2>Traits: Defining Shared Behavior</h2>
<p>We want to make a media aggregator library that can display summaries of data that might be stored in a <code>NewsArticle</code> or <code>Tweet</code> instance. To do this, we need a summary from each type, and we need to request that summary by calling a <code>summarize</code> method on an instance. Listing 10-12 shows the definition of a <code>Summary</code> trait that expresses this behavior.</p>
<pre><code class="language-rust">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
</code></pre>
<p>Each type implementing this trait must provide its own custom behavior for the body of the method. The compiler will enforce that any type that has the <code>Summary</code> trait will have the method <code>summarize</code> defined with this signature exactly.</p>
<h3>Implementing a Trait on a Type</h3>
<pre><code class="language-rust">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
</code></pre>
<h2><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">Validating References with Lifetimes</a></h2>
<h2><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#summary">Summary</a></h2>
<p>We covered a lot in this chapter! Now that you know about generic type parameters, traits and trait bounds, and generic lifetime parameters, youâ€™re ready to write code without repetition that works in many different situations. Generic type parameters let you apply the code to different types. Traits and trait bounds ensure that even though the types are generic, theyâ€™ll have the behavior the code needs. You learned how to use lifetime annotations to ensure that this flexible code wonâ€™t have any dangling references. And all of this analysis happens at compile time, which doesnâ€™t affect runtime performance!</p>
<p>Believe it or not, there is much more to learn on the topics we discussed in this chapter: Chapter 17 discusses trait objects, which are another way to use traits. There are also more complex scenarios involving lifetime annotations that you will only need in very advanced scenarios; for those, you should read the <a href="https://doc.rust-lang.org/reference/index.html">Rust Reference</a>. But next, youâ€™ll learn how to write tests in Rust so you can make sure your code is working the way it should.</p>
<h1>åé¢çš„åŸºæœ¬ä¸Šå°±è·³è€…æ¥äº†ï¼Œä»é¡¹ç›®ä¸­å­¦ä»£ç </h1>

</div>
</div></body>