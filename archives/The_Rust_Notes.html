<!DOCTYPE html>
<head>
<meta charset="UTF-8" /><title>PureWeb Blog-the Rust Book 零散笔记</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>  <script>    document.querySelectorAll('code').forEach((code) => {      if (!code.classList.length) {        code.classList.add('language-bash');      }    });  </script>	<script>		document.addEventListener('DOMContentLoaded', (event) => {			hljs.highlightAll();		});	</script><link rel="stylesheet" href="github.css">
<link rel="stylesheet" href="speciou.css"
</head><body>    <div class="container">        <header class="main-header">            <h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabinet</a></h1>            <nav class="main-header__nav">                <ul class="main-nav">                    <li class="main-nav__list"><a class="main-nav__list__link active" href="/" target="_self">HOME</a>                    </li>                    <li class="main-nav__list"><a class="main-nav__list__link" href="/archives/"                            target="_self">ARCHIVE</a>                    </li>                    <li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn"                            target="_blank">GITHUB</a></li>                </ul>            </nav>        </header>    </div><div class="typora-export os-windows"><div id="write" class>
<p><strong>2021-11-19 21:08</strong></p>
<p>刚好有时间看下</p>
<!-- more -->
<h1>1. Getting Started</h1>
<h2>Installation</h2>
<p>直接看官方文档</p>
<p>https://doc.rust-lang.org/book/ch01-01-installation.html</p>
<h2>Hello, World!</h2>
<p>在windows和Linux上分别创建并运行hello world项目熟悉RUST语言特性</p>
<p>两者共用源代码 hello_world.rs</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<h3>Windows</h3>
<p>编译</p>
<pre><code>rustc hello_world.rs
</code></pre>
<p>运行</p>
<pre><code>.\main.exe
</code></pre>
<h3>Linux</h3>
<p>编译</p>
<pre><code>rustc hello_world.rs
</code></pre>
<p>运行</p>
<pre><code>./main
</code></pre>
<h3>总结</h3>
<ul>
<li>
<p>在RUST中创建函数</p>
<pre><code class="language-rust">fn main() {

}
</code></pre>
<ul>
<li>The <code>main</code> function is special: it is always the first code that runs in every executable Rust program</li>
</ul>
</li>
<li>
<p>功能函数</p>
<pre><code class="language-rust">    println!(&quot;Hello, world!&quot;);
</code></pre>
<ul>
<li>rust使用四个空格来替代Tab</li>
<li>这里的<code>println</code>时调用了一个宏(macros)，当要调用<code>println</code>函数时，不需要添加感叹号</li>
<li>语句结束使用<code>;</code></li>
</ul>
</li>
<li>
<p>rustc</p>
<p>相当于rust的gcc编译器</p>
</li>
</ul>
<h2>Cargo</h2>
<p>相当于是rust的<code>pip</code>，是一个包管理工具</p>
<h3>使用Cargo创建项目</h3>
<pre><code class="language-bash">cargo new hello_prog
cd hello_cargo
tree
.
├── Getting Started.md
├── hello_prog
│   ├── Cargo.toml
│   └── src
│       └── main.rs
├── hello_world
├── hello_world.exe
├── hello_world.pdb
└── hello_world.rs
</code></pre>
<p>使用</p>
<pre><code>cargo new --vcs=git.
</code></pre>
<p>来避免创建git的gitignore文件</p>
<p><code>Cargo.toml</code></p>
<pre><code class="language-toml">[package]
name = &quot;hello_prog&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<p>The first line, <code>[package]</code>, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, we’ll add other sections.</p>
<p>The next three lines set the configuration information Cargo needs to compile your program: the name, the version, and the edition of Rust to use. We’ll talk about the <code>edition</code> key in <a href="https://doc.rust-lang.org/book/appendix-05-editions.html">Appendix E</a>.</p>
<p>The last line, <code>[dependencies]</code>, is the start of a section for you to list any of your project’s dependencies. In Rust, packages of code are referred to as <em>crates</em>. We won’t need any other crates for this project, but we will in the first project in Chapter 2, so we’ll use this dependencies section then.</p>
<h3>编译运行</h3>
<p>在文件夹中</p>
<pre><code class="language-bash">cargo build
</code></pre>
<p>运行</p>
<pre><code class="language-bash">./target/debug/hello_prog
</code></pre>
<p>编译并运行</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>编译测试</p>
<pre><code>cargo check
</code></pre>
<h2><a href="https://doc.rust-lang.org/book/ch01-03-hello-cargo.html#summary">Summary</a></h2>
<p>You’re already off to a great start on your Rust journey! In this chapter, you’ve learned how to:</p>
<ul>
<li>Install the latest stable version of Rust using <code>rustup</code></li>
<li>Update to a newer Rust version</li>
<li>Open locally installed documentation</li>
<li>Write and run a “Hello, world!” program using <code>rustc</code> directly</li>
<li>Create and run a new project using the conventions of Cargo</li>
</ul>
<p>This is a great time to build a more substantial program to get used to reading and writing Rust code. So, in Chapter 2, we’ll build a guessing game program. If you would rather start by learning how common programming concepts work in Rust, see Chapter 3 and then return to Chapter 2.</p>
<h1>2-Programming a Guessing Game</h1>
<p>You’ll learn about <code>let</code>, <code>match</code>, methods, associated functions, using external crates, and more! The following chapters will explore these ideas in more detail</p>
<h2>创建项目</h2>
<pre><code>cargo new guessing_game
</code></pre>
<h2>处理猜测</h2>
<p>让用户输入</p>
<pre><code class="language-rust">use std::io;	//python库

fn main() {
    println!(&quot;Guess a Number&quot;);
    print!(&quot;Please input your guess&gt; &quot;);

    let mut guess = String::new();
    
    io::stdin()							//调用io中的stdin方法
        .read_line(&amp;mut guess)			//python库中的功能
        .expect(&quot;Failed to readline&quot;);	//失败预处理
    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<ul>
<li><code>let</code> statement, which is used to create a <em>variable</em>.</li>
<li><code>mut</code>变量类型不可变</li>
<li>The <code>::</code> syntax in the <code>::new</code> line indicates that <code>new</code> is an <em>associated function</em> of the <code>String</code> type. An associated function is implemented on a type, in this case <code>String</code>.</li>
<li><code>read_line</code>函数返回一个<code>io::Result</code>值，值是枚举的变量：<code>Ok</code>或<code>Err</code></li>
</ul>
<h2>产生随机数</h2>
<p>在配置文件中添加</p>
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
<p>The answer to this problem is the <em>Cargo.lock</em> file, which was created the first time you ran <code>cargo build</code> and is now in your <em>guessing_game</em> directory. When you build a project for the first time, Cargo figures out all the versions of the dependencies that fit the criteria and then writes them to the <em>Cargo.lock</em> file. When you build your project in the future, Cargo will see that the <em>Cargo.lock</em> file exists and use the versions specified there rather than doing all the work of figuring out versions again. This lets you have a reproducible build automatically.</p>
<p>your project will remain at <code>0.8.3</code> until you explicitly upgrade, thanks to the <em>Cargo.lock</em> file.</p>
<p>可以使用</p>
<pre><code class="language-rust">cargo update
</code></pre>
<p>进行库更新</p>
<p>现在的源代码</p>
<pre><code class="language-rust">use std::io;	//python库
use rand::Rng;

fn main() {
    //1-产生随机数
    let secret_num = rand::thread_rng().gen_range(1..101);
    println!(&quot;Random number&gt; {}&quot;, secret_num);

    //2-输入
    println!(&quot;Guess a Number&quot;);
    print!(&quot;Please input your guess&gt; &quot;);

    let mut guess = String::new();
    
    io::stdin()							//调用io中的stdin方法
        .read_line(&amp;mut guess)			//python库中的功能
        .expect(&quot;Failed to readline&quot;);	//失败预处理
    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p>you can run the <code>cargo doc --open</code> command, which will build documentation provided by all of your dependencies locally and open it in your browser.</p>
<h2>比较数字</h2>
<p>we want to convert the <code>String</code> the program reads as input into a real number type so we can compare it numerically to the secret number. We can do that by adding another line to the <code>main</code> function body:</p>
<pre><code class="language-rust">    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
</code></pre>
<h2>创造循环体</h2>
<pre><code class="language-rust">loop{
    
}
</code></pre>
<p>退出循环</p>
<pre><code class="language-rust">Ordering::xxx =&gt; {
    break;
}
</code></pre>
<h2>非法输入处理</h2>
<pre><code class="language-rust">use std::io;	//类似python库
use rand::Rng;  //随机数库
use std::cmp::Ordering; //比较功能库

fn main() {
    //1-产生随机数
    let secret_num = rand::thread_rng().gen_range(1..101);
    println!(&quot;Random number&gt; {}&quot;, secret_num);

    //4-循环
    loop {
        //2-1输入
        println!(&quot;Please input your guess&gt; &quot;);

        let mut guess = String::new();
        
        io::stdin()							//调用io中的stdin方法
            .read_line(&amp;mut guess)			//python库中的功能
            .expect(&quot;Failed to readline&quot;);	//失败预处理

        //2-2转换类型
        //5-处理非法输入
        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; {
                println!(&quot;Invalid input&quot;);
                continue;
            },
        };
        println!(&quot;You guessed: {}&quot;, guess);

        //3-比较数字大小
        match guess.cmp(&amp;secret_num) {
            Ordering::Less =&gt; println!(&quot;Too small&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win&quot;);
                break;
            }
        }
    }
}
</code></pre>
<h2>总结</h2>
<p>At this point, you’ve successfully built the guessing game. Congratulations!</p>
<p>This project was a hands-on way to introduce you to many new Rust concepts: <code>let</code>, <code>match</code>, functions, the use of external crates, and more. In the next few chapters, you’ll learn about these concepts in more detail. Chapter 3 covers concepts that most programming languages have, such as variables, data types, and functions, and shows how to use them in Rust. Chapter 4 explores ownership, a feature that makes Rust different from other languages. Chapter 5 discusses structs and method syntax, and Chapter 6 explains how enums work.</p>
<h1>3-Common Programming Concepts</h1>
<p>This chapter covers concepts that appear in almost every programming language and how they work in Rust. Many programming languages have much in common at their core. None of the concepts presented in this chapter are unique to Rust, but we’ll discuss them in the context of Rust and explain the conventions around using these concepts.</p>
<p>Specifically, you’ll learn about variables, basic types, functions, comments, and control flow. These foundations will be in every Rust program, and learning them early will give you a strong core to start from.</p>
<p><strong>RUST关键字</strong></p>
<p>https://doc.rust-lang.org/book/appendix-01-keywords.html</p>
<h2>变量和可变量</h2>
<ul>
<li>变量类型默认是不可变的</li>
</ul>
<p>src/main.rs</p>
<pre><code class="language-rust">fn main() {
    let x= 5;
    println!(&quot;the value of x is {}&quot;, x);

    x=6;
    println!(&quot;the value of x is {}&quot;, x);
}
</code></pre>
<p>使用cargo run会报错</p>
<pre><code>5 |     x=6;
  |     ^^^ cannot assign twice to immutable variable
</code></pre>
<p>使用<code>mut</code>来创造可变变量</p>
<pre><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;the value of x is {}&quot;, x);
    x = 6;
    println!(&quot;the value of x is {}&quot;, x);
}
</code></pre>
<ul>
<li>
<p>变量和常量对比</p>
<ol>
<li>常量永远为常，一直不可变</li>
<li>定义常量使用<code>const</code>而不是<code>let</code>，同时指明变量类型</li>
<li>常量定义尽量使用大写</li>
<li>https://doc.rust-lang.org/reference/const_eval.html</li>
</ol>
</li>
<li>
<p>隐式变量</p>
<p>you can declare a new variable with the same name as a previous variable，Rustaceans say that the first variable is <em>shadowed</em> by the second, which means that the second variable’s value is what the program sees when the variable is used.</p>
<pre><code class="language-rust">//变量的隐式赋值
fn shadow_value() {
    let x = 5;
    let x = x + 1;
    {
        let x = x * 2;
        println!(&quot;The value of x in the inner scope is {}&quot;, x);
    }
    println!(&quot;The value of x is {}&quot;,x);
}
</code></pre>
<p>输出</p>
<pre><code>The value of x in the inner scope is 12
The value of x is 6
</code></pre>
<p>This program first binds <code>x</code> to a value of <code>5</code>. Then it shadows <code>x</code> by repeating <code>let x =</code>, taking the original value and adding <code>1</code> so the value of <code>x</code> is then <code>6</code>.</p>
<p>Then, within an inner scope, the third <code>let</code> statement also shadows <code>x</code>, multiplying the previous value by <code>2</code> to give <code>x</code> a value of <code>12</code>.</p>
<p>When that scope is over, the inner shadowing ends and <code>x</code> returns to being <code>6</code></p>
<p>By using <code>let</code>, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed.</p>
</li>
</ul>
<h2>数据类型</h2>
<p>A <em>scalar</em> type represents a single value. Rust has four primary scalar types: integers, floating-point numbers, Booleans, and characters. You may recognize these from other programming languages.</p>
<h3>基础变量</h3>
<h4>Integer Types</h4>
<p>| Length  | Signed  | Unsigned |
| ------- | ------- | -------- |
| 8-bit   | <code>i8</code>    | <code>u8</code>     |
| 16-bit  | <code>i16</code>   | <code>u16</code>    |
| 32-bit  | <code>i32</code>   | <code>u32</code>    |
| 64-bit  | <code>i64</code>   | <code>u64</code>    |
| 128-bit | <code>i128</code>  | <code>u128</code>   |
| arch    | <code>isize</code> | <code>usize</code>  |</p>
<p>| Number literals  | Example       |
| ---------------- | ------------- |
| Decimal          | <code>98_222</code>      |
| Hex              | <code>0xff</code>        |
| Octal            | <code>0o77</code>        |
| Binary           | <code>0b1111_0000</code> |
| Byte (<code>u8</code> only) | <code>b'A'</code>        |</p>
<p>integer types default to <code>i32</code>. The primary situation in which you’d use <code>isize</code> or <code>usize</code> is when indexing some sort of collection.</p>
<p><strong>rust能在编译中整数溢出发生时检测到</strong>（Panic）</p>
<h4>Floating-Point Types</h4>
<pre><code class="language-rust">fn floating_tpyes() {
    let x = 2.0; // f64
    let y: f32 = 3.0; // f32
}
</code></pre>
<p>数字基本加减法</p>
<pre><code class="language-rust">//基础的数学运算
fn basic_math() {
    let sum = 5 + 10;
    let difference = 95 - 1;
    let product = 4 * 30;
    let floored = 2 / 3;
    let reminder = 43 % 5;
}
</code></pre>
<h4>The Boolean Type</h4>
<pre><code class="language-rust">fn boolean_test() {
    let t = true;
    
    let f: bool = false; // with explicit type annotation
}
</code></pre>
<h4>The Character Type</h4>
<p>So far we’ve worked only with numbers, but Rust supports letters too. Rust’s <code>char</code> type is the language’s most primitive alphabetic type, and the following code shows one way to use it. (Note that <code>char</code> literals are specified with single quotes, as opposed to string literals, which use double quotes.)</p>
<p>Filename: src/main.rs</p>
<pre><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
</code></pre>
<h3>符合变量</h3>
<h4>元组 Tuple</h4>
<pre><code class="language-rust">let tup: (i32, f64, u8) = (500, 6.4, 1);
</code></pre>
<p>你甚至可以</p>
<pre><code class="language-rust">fn nice_tulpe() {
    let tup = (500,6.4,1);
    let (x,y,z) = tup;
    println!(&quot;The value of y is {}&quot;,y);
}
</code></pre>
<p>使用<code>.</code>运算直接进行下标访问</p>
<pre><code class="language-rust">fn nice_tulpe() {
    let tup = (500,6.4,1);
    let (x,y,z) = tup;
    println!(&quot;The value of y is {}&quot;,y);
    println!(&quot;using . &gt; {}&quot;,tup.0);
}
</code></pre>
<h4>数组类型 Array Type</h4>
<pre><code class="language-rust">let a = [1,2,3,4,5];
let a: [i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5];//let a = [3,3,3,3,3];
</code></pre>
<ul>
<li>
<p>数组访问</p>
<pre><code class="language-rust">fn nice_array() {
    let a = [1, 2, 3, 4, 5];
    let first = a[0];
    let second = a[1];
    println!(&quot;fisrt&gt; {}\nsencond&gt; {}&quot;,first,second);
}
</code></pre>
</li>
<li>
<p>非法数组访问</p>
<pre><code class="language-rust">fn bad_array() {
    let a = [1,2,3,4,5];
    println!(&quot;enter the index&quot;);

    let mut idx = String::new();
    io::stdin()
        .read_line(&amp;mut idx)
        .expect(&quot;failed to readline&quot;);
    
    let idx: usize = idx
        .trim()
        .parse()
        .expect(&quot;Index enter was not a number&quot;);
    
    let elen = a[idx];
    println!(
        &quot;The value in a[{}] is {}&quot;,
        idx,a[idx]
    );
}
</code></pre>
<p>输入超出范围时rust报错</p>
<pre><code>enter the index
10
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:71:16
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>If the index is greater than or equal to the length, Rust will panic</p>
</li>
</ul>
<h2>函数</h2>
<p>不带返回值</p>
<pre><code class="language-rust">fn another_function(x: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>带返回值</p>
<pre><code class="language-rust">fn five() -&gt; i32 {
    5
}
</code></pre>
<p>函数返回最后一个出现的所要求的类型的数据，<strong>同样可以使用return 返回值</strong></p>
<p>函数表达式不等同于函数结构体，不能是使用return 关键字</p>
<h2>逻辑判断与循环</h2>
<h3><code>if</code> Expressions</h3>
<p>An <code>if</code> expression allows you to branch your code depending on conditions. You provide a condition and then state, “If this condition is met, run this block of code. If the condition is not met, do not run this block of code.”</p>
<p>Create a new project called <em>branches</em> in your <em>projects</em> directory to explore the <code>if</code> expression. In the <em>src/main.rs</em> file, input the following:</p>
<p>Filename: src/main.rs</p>
<pre><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
}
</code></pre>
<p>可以利用if条件进行赋值（语法糖）//注意两个值的类型要匹配</p>
<pre><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre>
<h3><a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html#repetition-with-loops">Repetition with Loops</a></h3>
<p>Rust has three kinds of loops: <code>loop</code>, <code>while</code>, and <code>for</code>. Let’s try each one.</p>
<h4>loop</h4>
<pre><code class="language-rust">fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!(&quot;count = {}&quot;, count);
        let mut remaining = 10;

        loop {
            println!(&quot;remaining = {}&quot;, remaining);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!(&quot;End count = {}&quot;, count);
}
</code></pre>
<p>同样使用break退出</p>
<h4>Returning Values from Loops</h4>
<pre><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {}&quot;, result);
}
</code></pre>
<p>break返回后面值</p>
<h2><a href="https://doc.rust-lang.org/book/ch03-05-control-flow.html#summary">Summary</a></h2>
<p>You made it! That was a sizable chapter: you learned about variables, scalar and compound data types, functions, comments, <code>if</code> expressions, and loops! If you want to practice with the concepts discussed in this chapter, try building programs to do the following:</p>
<ul>
<li>Convert temperatures between Fahrenheit and Celsius.</li>
<li>Generate the nth Fibonacci number.</li>
<li>Print the lyrics to the Christmas carol “The Twelve Days of Christmas,” taking advantage of the repetition in the song.</li>
</ul>
<p>When you’re ready to move on, we’ll talk about a concept in Rust that <em>doesn’t</em> commonly exist in other programming languages: ownership.</p>
<h1>4-Understanding Ownership</h1>
<h2>Feature represent</h2>
<p><strong>Rust’s central feature is <em>ownership</em></strong></p>
<blockquote>
<p>All programs have to manage the way they use a computer’s memory while running. Some languages have garbage collection that constantly looks for no longer used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it’s running.</p>
<p>......</p>
<p>Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don’t run out of space are all problems that ownership addresses.</p>
</blockquote>
<h3><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#ownership-rules">Ownership Rules</a></h3>
<ul>
<li>Each value in Rust has a variable that’s called its <em>owner</em>.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ul>
<h3><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#variable-scope">Variable Scope</a></h3>
<ul>
<li>在函数表达式中的值，在函数表达完成后自动删除</li>
</ul>
<p>使用<code>string</code>类型例子，为了更好的存储和使用字符串值，我们可以使用<code>String</code>类型</p>
<pre><code class="language-rust">let s = String::from(&quot;hello&quot;);
</code></pre>
<p>其中<code>::</code>参考了c++命名空间</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    s.push_str(&quot;,Rust&quot;);
    println!(&quot;{}&quot;,s);
}
</code></pre>
<p>在<code>String</code>中为了支持类型可变、长度可变，在编译时长度不可变</p>
<ul>
<li>在运行时内存必须由内存分配器分配</li>
<li>结束使用时要用某种方式告诉内存</li>
</ul>
<p><strong>We need to pair exactly one <code>allocate</code> with exactly one <code>free</code>.</strong></p>
<p>Rust使用了一种和其他语言不一样的方式，当变量超出其定义范围时GC自动回收这块内存</p>
<p>如在4-1中所讲的那样</p>
<pre><code class="language-rust">    let s = String::from(&quot;rust&quot;);
    {
        let s = String::from(&quot;hello&quot;);
        println!(&quot;{}&quot;,s);
    }
    println!(&quot;{}&quot;,s);
</code></pre>
<p>When a variable goes out of scope, Rust calls a special function for us. This function is called <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop"><code>drop</code></a>, and it’s where the author of <code>String</code> can put the code to return the memory. Rust calls <code>drop</code> automatically at the closing curly bracket.</p>
<blockquote>
<p>Note: In C++, this pattern of deallocating resources at the end of an item’s lifetime is sometimes called <em>Resource Acquisition Is Initialization (RAII)</em>. The <code>drop</code> function in Rust will be familiar to you if you’ve used RAII patterns.</p>
</blockquote>
<pre><code class="language-rust">    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;
    println!(&quot;{}&quot;,s1);
    println!(&quot;{}&quot;,s2);
</code></pre>
<pre><code>error[E0382]: borrow of moved value: `s1`
  --&gt; src/main.rs:18:19
   |
16 |     let s1 = String::from(&quot;hello&quot;);
   |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
17 |     let s2 = s1;
   |              -- value moved here
18 |     println!(&quot;{}&quot;,s1);
   |                   ^^ value borrowed here after move
</code></pre>
<p>在rust中，一个<code>string</code>结构体为</p>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-01.svg" alt="" /></p>
<p>在复制时，仅仅复制结构体，而不复制内存中的数据</p>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-02.svg" alt="" /></p>
<p>但是rust和其它语言的浅拷贝不同，它是将s1移动到了s2，相当于</p>
<pre><code class="language-rust">let s = String::from(&quot;hello&quot;);
{
    let s = String::from(&quot;hello&quot;);
}
</code></pre>
<p>这种类似的移动，所以真实情况看上去啊像是</p>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-04.svg" alt="" /></p>
<p>这样的，所以在使用时，我们只能使用s2</p>
<p>同时如果我们想要做到<code>deep cpoy</code>，我们可以使用<code>clone</code>功能来实现</p>
<pre><code class="language-rust">    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1.clone();
    println!(&quot;s1 = {}&quot;,s1);
    println!(&quot;s2 = {}&quot;,s2);
</code></pre>
<p>Rust won’t let us annotate a type with the <code>Copy</code> trait if the type, or any of its parts, has implemented the <code>Drop</code> trait.</p>
<p>Here are some of the types that implement <code>Copy</code>:</p>
<ul>
<li>All the integer types, such as <code>u32</code>.</li>
<li>The Boolean type, <code>bool</code>, with values <code>true</code> and <code>false</code>.</li>
<li>All the floating point types, such as <code>f64</code>.</li>
<li>The character type, <code>char</code>.</li>
<li>Tuples, if they only contain types that also implement <code>Copy</code>. For example, <code>(i32, i32)</code> implements <code>Copy</code>, but <code>(i32, String)</code> does not.</li>
</ul>
<h3>Ownership and Functions</h3>
<p>The book直接给出了一个例子</p>
<pre><code class="language-rust">fn main() {
    //5-ownership and functions
    let s = String::from(&quot;hello&quot;);
    takes_ownership(s);
    let x = 5;
    makes_copy(x);

}
//5-ownership and functions
fn takes_ownership(some_string: String) {
    println!(&quot;{}&quot;,some_string);
}

//5-ownership and functions
fn makes_copy(some_integar: i32) {
    println!(&quot;{}&quot;,some_integar);
}
</code></pre>
<p>我们在<code>takes_ownership</code>中使用了在堆上的变量<code>s</code>后，会调用<code>drop</code>这个功能释放<code>s</code>，是的后续不能再次使用</p>
<p>而我们的<code>makes_copy</code>在栈上面所以能再次使用</p>
<h3>Return Values and Scope</h3>
<pre><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from(&quot;hello&quot;);     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from(&quot;yours&quot;); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
</code></pre>
<p>The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by <code>drop</code> unless the data has been moved to be owned by another variable.</p>
<p><strong>What if we want to let a function use a value but not take ownership?</strong></p>
<p>使用元组传递结果</p>
<pre><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
</code></pre>
<p>But this is too much ceremony and a lot of work for a concept that should be common. Luckily for us, Rust has a feature for this concept, called <em>references</em>.</p>
<h2>References and Borrowing</h2>
<p>可以借鉴c++中的例子，rust中，同样使用<code>&amp;var</code>来表示对参数的引用，the book同样给出了一个例子</p>
<pre><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let len: usize = calculate_lenth(&amp;s1);
    println!(&quot;{} lenth is {}&quot;,s1,len);
}

fn calculate_lenth(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-05.svg" alt="" /></p>
<p>同样的，rust存在反引用<code>*</code></p>
<pre><code class="language-rust">fn calculate_lenth(s: &amp;String) -&gt; usize {
    println!(&quot;{}&quot;,s.capacity());
    // println!(&quot;{}&quot;,*s.capacity()); false
    println!(&quot;{}&quot;,s);
    s.len()
}
</code></pre>
<p><strong>We call the action of creating a reference <em>borrowing</em></strong></p>
<p>错误示例代码</p>
<pre><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p>原因：Just as variables are immutable by default, so are references. We’re not allowed to modify something we have a reference to.</p>
<h3>Mutable References</h3>
<pre><code class="language-rust">fn main() {
    //2-mut reference
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
    println!(&quot;{}&quot;,s);
}

//2-mut reference
fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p>可变引用有限制：一个可变变量只能被一个可变引用占有</p>
<p><strong>benefit</strong>: The restriction preventing multiple mutable references to the same data at the same time allows for mutation but in a very controlled fashion. It’s something that new Rustaceans struggle with, because most languages let you mutate whenever you’d like.</p>
<p>几种错误可变引用示例</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
}
</code></pre>
<pre><code>$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership`

To learn more, run the command again with --verbose.
</code></pre>
<p>修正：</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &amp;mut s;
}
</code></pre>
<hr />
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    let r3 = &amp;mut s; // BIG PROBLEM

    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
}
</code></pre>
<pre><code>$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`

To learn more, run the command again with --verbose.
</code></pre>
<p>修正</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    println!(&quot;{} and {}&quot;, r1, r2);
    // variables r1 and r2 will not be used after this point

    let r3 = &amp;mut s; // no problem
    println!(&quot;{}&quot;, r3);
}
</code></pre>
<h3>Dangling References</h3>
<p>rust引起的指针悬空操作会被编译器察觉</p>
<pre><code class="language-rust">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<h3><a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#the-rules-of-references">The Rules of References</a></h3>
<p>Let’s recap what we’ve discussed about references:</p>
<ul>
<li>At any given time, you can have <em>either</em> one mutable reference <em>or</em> any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
<h2>The Slice Type</h2>
<p>Another data type that does not have ownership is the <em>slice</em>. Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection.</p>
<p>例子：使用引用来判断字符串是否为单词，扫描字符串，发现有空格则返回空格所在位置，没有则返回这个单词</p>
<pre><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello world&quot;);
    let word = first_word(&amp;s);
    println!(&quot;{}&quot;,word);
    s.clear();
}

fn first_word(s: &amp;String) -&gt; usize{
    let bytes = s.as_bytes();//将str切换为bytes数组
    
    //enumerate wraps the result of iter and returns each element as part of a tuple instead. 
    for (i, &amp;item) in bytes.iter().enumerate() {
       if item == b' ' {
           return i;
       }
    }
    s.len()
}
</code></pre>
<p>为了对该单词进行分段，我们定义一个新的函数</p>
<pre><code class="language-rust">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<h3>String Slices</h3>
<p>A <em>string slice</em> is a reference to part of a <code>String</code>, and it looks like this:</p>
<pre><code class="language-rust">    let mut s = String::from(&quot;hello world&quot;);
 
    let hello = &amp;s[0..5];
    let world = &amp;s[6..11];
    println!(&quot;{}&quot;,hello);
    println!(&quot;{}&quot;,world);
</code></pre>
<p>在过程中的两个变量为</p>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-06.svg" alt="" /></p>
<blockquote>
<p>Note: String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error. For the purposes of introducing string slices, we are assuming ASCII only in this section; a more thorough discussion of UTF-8 handling is in the <a href="https://doc.rust-lang.org/book/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“Storing UTF-8 Encoded Text with Strings”</a> section of Chapter 8.</p>
</blockquote>
<p>所以我们可以重新写上个例子为</p>
<pre><code class="language-rust">fn second_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();//将str切换为bytes数组
    
    //enumerate wraps the result of iter and returns each element as part of a tuple instead. 
    for (i, &amp;item) in bytes.iter().enumerate() {
       if item == b' ' {
           return &amp;s[0..i];
       }
    }
    &amp;s[..]
}
</code></pre>
<p>错误调用</p>
<pre><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}

fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!(&quot;the first word is: {}&quot;, word);
}
</code></pre>
<p><strong>Recall from the borrowing rules that if we have an immutable reference to something, we cannot also take a mutable reference.</strong></p>
<h4><a href="https://doc.rust-lang.org/book/ch04-03-slices.html#string-slices-as-parameters">String Slices as Parameters</a></h4>
<h3>Other Slices</h3>
<p>String slices, as you might imagine, are specific to strings. But there’s a more general slice type, too. Consider this array:</p>
<pre><code class="language-rust">let a = [1, 2, 3, 4, 5];
</code></pre>
<p>Just as we might want to refer to a part of a string, we might want to refer to part of an array. We’d do so like this:</p>
<pre><code class="language-rust">let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];

assert_eq!(slice, &amp;[2, 3]);
</code></pre>
<p>This slice has the type <code>&amp;[i32]</code>. It works the same way as string slices do, by storing a reference to the first element and a length. You’ll use this kind of slice for all sorts of other collections. We’ll discuss these collections in detail when we talk about vectors in Chapter 8.</p>
<h2>Summary</h2>
<p>The concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time. The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don’t have to write and debug extra code to get this control.</p>
<p>Ownership affects how lots of other parts of Rust work, so we’ll talk about these concepts further throughout the rest of the book. Let’s move on to Chapter 5 and look at grouping pieces of data together in a <code>struct</code>.</p>
<h1>5-Using Structs to Structure Related Data</h1>
<p>In this chapter, we’ll compare and contrast tuples with structs. We’ll demonstrate how to define and instantiate structs. We’ll discuss how to define associated functions, especially the kind of associated functions called <em>methods</em>, to specify behavior associated with a struct type.</p>
<h2>Defining and Instantiating Structs</h2>
<blockquote>
<p>To define a struct, we enter the keyword <code>struct</code> and name the entire struct. A struct’s name should describe the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of the pieces of data, which we call <em>fields</em>. For example, Listing 5-1 shows a struct that stores information about a user account.</p>
</blockquote>
<pre><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
</code></pre>
<p>实例化结构体</p>
<pre><code class="language-rust">    let user1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;someusername123&quot;),
        active: true,
        sign_in_count: 1,
    };
</code></pre>
<p>To get a specific value from a struct, we can use dot notation</p>
<pre><code class="language-rust">    //使用mutable结构体
    let mut user2 = User {
        active: true,
        username: String::from(&quot;admin&quot;),
        sign_in_count: 0,
        email: String::from(&quot;admin@covteam.club&quot;),        
    };

    user2.email=String::from(&quot;admin@covteam.cn&quot;);
</code></pre>
<p>使用函数实例化结构体</p>
<pre><code class="language-rust">fn main() {
    let user3 = build_user(String::from(&quot;test@covteam.com&quot;), String::from(&quot;username&quot;));
    println!(&quot;user3 email&gt; {}&quot;,user3.email);
    println!(&quot;user3 username&gt; {}&quot;,user3.username);
}

fn build_user(email: String, username: String) -&gt; User{
    User{
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
</code></pre>
<p>可以省略的填入参数实例化结构体</p>
<pre><code class="language-rust">struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}

fn main() {
    let user1 = build_user(
        String::from(&quot;someone@example.com&quot;),
        String::from(&quot;someusername123&quot;),
    );
}
</code></pre>
<h3>Creating Instances From Other Instances With Struct Update Syntax</h3>
<pre><code class="language-rust">    let user4 = User {
        active: user1.active,
        username: user2.username,
        email: String::from(&quot;some_one@qq.com&quot;),
        sign_in_count: user3.sign_in_count,
    };
</code></pre>
<p>The syntax <code>..</code> specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.</p>
<pre><code class="language-rust">    let user5 = User {
        email: String::from(&quot;joe1sn@qq.com&quot;),
        ..user1
    };
</code></pre>
<p>但是如果copy的是可变变量（如user2），会报错</p>
<pre><code>error[E0382]: use of moved value: `user2.username`
  --&gt; src/main.rs:38:17
   |
33 |           username: user2.username,
   |                     -------------- value moved here
...
38 |       let user5 = User {
   |  _________________^
39 | |         email: String::from(&quot;joe1sn@qq.com&quot;),
40 | |         ..user2
41 | |     };
   | |_____^ value used here after move
   |
   = note: move occurs because `user2.username` has type `String`, which does 
not implement the `Copy` trait
</code></pre>
<p>其中可以这样理解</p>
<p>**Note that the struct update syntax is like assignment with <code>=</code> because it moves the data, just as we saw in the <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#ways-variables-and-data-interact-move">“Ways Variables and Data Interact: Move” section</a>. **</p>
<h3>Using Tuple Structs without Named Fields to Create Different Types</h3>
<p>参考go的结构体构造其实也是如此</p>
<pre><code class="language-rust">    struct Color(i32, i32, i32);
    struct Point(i32, i32, i32);

    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
</code></pre>
<h3>Unit-Like Structs Without Any Fields</h3>
<p>应用方式：unit-like structs can be useful in situations in which you need to implement a trait on some type but don’t have any data that you want to store in the type itself.</p>
<pre><code class="language-rust">fn main() {
    struct AlwaysEqual;

    let subject = AlwaysEqual;
}
</code></pre>
<p>without any curly brackets or parentheses. Imagine we’ll be implementing behavior for this type that every instance is always equal to every instance of every other type</p>
<p><a href="">You’ll see in Chapter 10 how to define traits and implement them on any type, including unit-like structs.</a></p>
<blockquote>
<p>In the <code>User</code> struct definition in Listing 5-1, we used the owned <code>String</code> type rather than the <code>&amp;str</code> string slice type. This is a deliberate choice because we want instances of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.</p>
<p>It’s possible for structs to store references to data owned by something else, but to do so requires the use of <em>lifetimes</em>, a Rust feature that we’ll discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct is valid for as long as the struct is. Let’s say you try to store a reference in a struct without specifying lifetimes, like this, which won’t work:</p>
<p>Filename: src/main.rs</p>
<pre><code class="language-rust">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>The compiler will complain that it needs lifetime specifiers:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:2:15
  |
2 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct User&lt;'a&gt; {
2 |     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:12
  |
3 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
1 | struct User&lt;'a&gt; {
2 |     username: &amp;str,
3 |     email: &amp;'a str,
  |

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs`

To learn more, run the command again with --verbose.
</code></pre>
<p>In Chapter 10, we’ll discuss how to fix these errors so you can store references in structs, but for now, we’ll fix errors like these using owned types like <code>String</code> instead of references like <code>&amp;str</code>.</p>
</blockquote>
<h2>An Example Program Using Structs</h2>
<p><strong>let’s write a program that calculates the area of a rectangle. We’ll start with single variables, and then refactor the program until we’re using structs instead.</strong></p>
<p>1.功能的简单实现</p>
<pre><code class="language-rust">fn main() {
    let w1: u32 = 30;
    let h1: u32 = 50;
    println!(&quot;the rectangle is {}&quot;, area(w1,h1) );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre>
<p>2.使用元组传值</p>
<pre><code class="language-rust">fn area(wh_value: (u32, u32)) -&gt; u32 {
    wh_value.0 * wh_value.1
}
</code></pre>
<p>3.使用结构体</p>
<pre><code class="language-rust">fn main() {
    let tmp = tangel{width:30, height:50};
    println!(&quot;the rectangle is {}&quot;,  area(&amp;tmp));
    //    println!(&quot;the rectangle is {}&quot;,  area(
    //    &amp;tangel{width:30, height:50}
    //));
}
fn area( rectangle: &amp;tangel ) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre>
<h3>Adding Useful Functionality with Derived Traits</h3>
<p>如何立即打印出结构体的所有值，直接打印报错：和类型不匹配</p>
<p>Putting the specifier <code>:?</code> inside the curly brackets tells <code>println!</code> we want to use an output format called <code>Debug</code>. The <code>Debug</code> trait enables us to print our struct in a way that is useful for developers so we can see its value while we’re debugging our code.</p>
<p>在程序头部加上<code>#[derive(Debug)]</code>进入debug程序模式</p>
<p>代码</p>
<pre><code class="language-rust">#[derive(Debug)]
struct tangel {
    width: u32,
    height: u32,
}

fn main() {
    let tmp = tangel{width:30, height:50};
    println!(&quot;debug print {:?}&quot;,tmp);
    println!(&quot;debug print {:#?}&quot;,tmp);
}
</code></pre>
<p>输出</p>
<pre><code>debug print tangel { width: 30, height: 50 }
debug print tangel {
    width: 30,
    height: 50,
}
</code></pre>
<p>同时可以使用<code>!dbg()</code>来进行调试信息的输出。Calling the <code>dbg!</code> macro prints to the standard error console stream (<code>stderr</code>), as opposed to <code>println!</code> which prints to the standard output console stream (<code>stdout</code>).</p>
<p>代码</p>
<pre><code class="language-rust">#[derive(Debug)]
struct tangel {
    width: u32,
    height: u32,
}

fn main() {
    let tmp = tangel{width:30, height:50};
    println!(&quot;debug print {:?}&quot;,tmp);
    println!(&quot;debug print {:#?}&quot;,tmp);
}
</code></pre>
<p>输出</p>
<pre><code>[src/main.rs:30] 30 * t = 60
[src/main.rs:33] tmp = tangel {
    width: 60,
    height: 50,
}
</code></pre>
<p>In addition to the <code>Debug</code> trait, Rust has provided a number of traits for us to use with the <code>derive</code> attribute that can add useful behavior to our custom types. Those traits and their behaviors are listed in <a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">Appendix C</a>. We’ll cover how to implement these traits with custom behavior as well as how to create your own traits in Chapter 10. There are also many attributes other than <code>derive</code>; for more information, see <a href="https://doc.rust-lang.org/reference/attributes.html">the “Attributes” section of the Rust Reference</a>.</p>
<p>如何将area从函数变为方法</p>
<h2>Method Syntax</h2>
<p>However, methods are different from functions in that they’re defined within the context of a struct (or an enum or a trait object, which we cover in Chapters 6 and 17, respectively), and their first parameter is always <code>self</code>, which represents the instance of the struct the method is being called on.（可以参考python类的构建方法）</p>
<h3>Defining Methods</h3>
<pre><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32{
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre>
<ul>
<li>The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.</li>
<li>Methods must have a parameter named <code>self</code> of type <code>Self</code> for their first parameter, so Rust lets you abbreviate this with only the name <code>self</code> in the first parameter spot.</li>
<li>If we wanted to change the instance that we’ve called the method on as part of what the method does, we’d use <code>&amp;mut self</code> as the first parameter.</li>
</ul>
<p>方法中的函数名能和成员名重合</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    
    if rect1.width() {
        println!(&quot;The rectangle has a nonzero width; it is {}&quot;, rect1.width);
    }
}
</code></pre>
<p>[<strong>命名规则</strong>]Often, but not always, methods with the same name as a field will be defined to only return the value in the field and do nothing else.</p>
<p><a href="">We will be discussing what public and private are and how to designate a field or method as public or private in Chapter 7.</a></p>
<blockquote>
<h3><a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#wheres-the---operator">Where’s the <code>-&gt;</code> Operator?</a></h3>
<p>In C and C++, two different operators are used for calling methods: you use <code>.</code> if you’re calling a method on the object directly and <code>-&gt;</code> if you’re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if <code>object</code> is a pointer, <code>object-&gt;something()</code> is similar to <code>(*object).something()</code>.</p>
<p><strong>Rust doesn’t have an equivalent to the <code>-&gt;</code> operator</strong>; instead, Rust has a feature called <em><strong>automatic referencing and dereferencing</strong></em>. Calling methods is one of the few places in Rust that has this behavior.</p>
<p>Here’s how it works: when you call a method with <code>object.something()</code>, Rust automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> so <code>object</code> matches the signature of the method. In other words, the following are the same:</p>
<pre><code class="language-rust">p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
</code></pre>
<p>The first one looks much cleaner. This automatic referencing behavior works <strong>because methods have a clear receiver—the type of <code>self</code></strong>. Given the receiver and name of a method, Rust can figure out definitively whether the method is reading (<code>&amp;self</code>), mutating (<code>&amp;mut self</code>), or consuming (<code>self</code>). The fact that Rust makes borrowing implicit for method receivers is a big part of making ownership ergonomic in practice.</p>
</blockquote>
<h3>Methods with More Parameters</h3>
<p>例子任务： This time, we want an instance of <code>Rectangle</code> to take another instance of <code>Rectangle</code> and return <code>true</code> if the second <code>Rectangle</code> can fit completely within <code>self</code>; otherwise it should return <code>false</code>.</p>
<pre><code class="language-rust">impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<h3>Associated Functions</h3>
<p>All functions defined within an <code>impl</code> block are called <em>associated functions</em> because they’re associated with the type named after the <code>impl</code>.</p>
<p>We can define associated functions that don’t have <code>self</code> as their first parameter (and thus are not methods) because they don’t need an instance of the type to work with.如<code>String::from()</code></p>
<p>创建一个关联函数（任然要在impl中）</p>
<pre><code class="language-rust">impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }

    fn square(size: u32) -&gt; Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
</code></pre>
<p>To call this associated function, we use the <code>::</code> syntax with the struct name;</p>
<h3>Multiple <code>impl</code> Blocks</h3>
<p>可以在不同<code>impl</code>中对同一结构体对象的方法进行定义，虽然没有必要，但是在语法上可行</p>
<pre><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<h2>Summary</h2>
<p>Structs let you create custom types that are meaningful for your domain. By using structs, you can keep associated pieces of data connected to each other and name each piece to make your code clear. In <code>impl</code> blocks, you can define functions that are associated with your type, and methods are a kind of associated function that let you specify the behavior that instances of your structs have.</p>
<p>But structs aren’t the only way you can create custom types: let’s turn to Rust’s enum feature to add another tool to your toolbox.</p>
<h1>6-Enums and Pattern Matching</h1>
<ul>
<li>First, we’ll define and use an enum to show how an enum can encode meaning along with data.</li>
<li>Next, we’ll explore a particularly useful enum, called <code>Option</code>, which expresses that a value can be either something or nothing.</li>
<li>Then we’ll look at how pattern matching in the <code>match</code> expression makes it easy to run different code for different values of an enum.</li>
<li>Finally, we’ll cover how the <code>if let</code> construct is another convenient and concise idiom available to you to handle enums in your code.</li>
</ul>
<p><strong>Rust’s enums are most similar to <em>algebraic data types</em> in functional languages, such as F#, OCaml, and Haskell.</strong></p>
<h2>Defining an Enum</h2>
<p>从一个例子来说明为什么枚举比结构体在某些情况下更加方便</p>
<p>These are the only possibilities for an IP address that our program will come across: we can <em>enumerate</em> all possible variants, which is where enumeration gets its name.</p>
<p>从定义一个<code>IpAddrKind</code>枚举开始来区分ipv4和ipv6</p>
<pre><code class="language-rust">enum  IpAddrKind {
    v4,
    v6
}
</code></pre>
<h3>Enum Values</h3>
<p>创建枚举立即值</p>
<pre><code class="language-rust">fn main() {
    let four = IpAddrKind::v4;
    let six = IpAddrKind::v6;
}
</code></pre>
<p>在这里 <code>IpAddrKind::V4</code> and <code>IpAddrKind::V6</code> 都是同一个类型<code>IpAddrKind</code></p>
<p>创建<code>route</code>函数来调用<code>IpAddrKind</code></p>
<pre><code class="language-rust">fn route(ip_kind: IpAddrKind) {}

fn main() {
    route(IpAddrKind::v4);
}
</code></pre>
<p><strong>at the moment we don’t have a way to store the actual IP address <em>data</em>; we only know what <em>kind</em> it is.</strong></p>
<p>显示尝试使用简单的结构体解决</p>
<pre><code class="language-rust">use std::net::IpAddr;

enum  IpAddrKind {
    v4,
    v6
}

struct MyIpAddr {
    kind: IpAddrKind,
    address: String,
}

fn main() {
    let home = MyIpAddr {
        kind: IpAddrKind::v4,
        address: String::from(&quot;127.0.0.1&quot;)
    };

    let loopback = MyIpAddr {
        kind: IpAddrKind::v6,
        address: String::from(&quot;::1&quot;),
    };
}
</code></pre>
<p>我们已经使用结构体将种类和地址值捆绑在一起，所以现在变体与值相关联。</p>
<p><strong>We can represent the same concept in a more concise way using just an enum, rather than an enum inside a struct, by putting data directly into each enum variant.</strong> 像是这样</p>
<pre><code class="language-rust">use std::net::IpAddr;

enum  IpAddrKind {
    v4,
    v6
}

enum MyIpAddr {
    v4(String),
    v6(String),
}

fn main() {
    let home = MyIpAddr::v4(String::from(&quot;127.0.0.1&quot;));
    let loopback = MyIpAddr::v6(String::from(&quot;::1&quot;));
}
</code></pre>
<p>Rust可以只能对值进行填充</p>
<pre><code class="language-rust">fn main() {
    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
}
</code></pre>
<p>Rust的官方包对<code>IpAdd</code>这样定义</p>
<pre><code class="language-rust">pub enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
</code></pre>
<p>example</p>
<pre><code class="language-rust">use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};

let localhost_v4 = IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1));
let localhost_v6 = IpAddr::V6(Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));

assert_eq!(&quot;127.0.0.1&quot;.parse(), Ok(localhost_v4));
assert_eq!(&quot;::1&quot;.parse(), Ok(localhost_v6));

assert_eq!(localhost_v4.is_ipv6(), false);
assert_eq!(localhost_v4.is_ipv4(), true);
</code></pre>
<p>This code illustrates that you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example.</p>
<p>利用枚举简化结构体</p>
<pre><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
</code></pre>
<p>功能等价于</p>
<pre><code class="language-rust">struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct

fn main() {}
</code></pre>
<p>There is one more similarity between enums and structs: just as we’re able to define methods on structs using <code>impl</code>, we’re also able to define methods on enums.</p>
<pre><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&amp;self) {
        // println!(&quot;world&quot;);
    }
}
fn main() {
    let m = Message::Write(String::from(&quot;hello&quot;));
    m.call();
}
</code></pre>
<h3>The <code>Option</code> Enum and Its Advantages Over Null Values</h3>
<p>This section explores a case study of <code>Option</code>, which is another enum defined by the standard library. The <code>Option</code> type is used in many places because it encodes the very common scenario in which a value could be something or it could be nothing.</p>
<p>this functionality can prevent bugs that are extremely common in other programming languages.</p>
<p><strong>Rust doesn’t have the null feature that many other languages have.</strong></p>
<blockquote>
<p>I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p>
</blockquote>
<p><strong>Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is <code>Option&lt;T&gt;</code>, and it is <a href="https://doc.rust-lang.org/std/option/enum.Option.html">defined by the standard library</a> as follows:</strong></p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}
</code></pre>
<p>使用含null的枚举</p>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}


fn main() {
    //using null enum
    let some_number = Some(5);
    let some_string = Some(&quot;a string&quot;);

    let absent_number: Option&lt;i32&gt; = None;
}
</code></pre>
<p>其中<code>&lt;T&gt;</code>是类似于C++中的泛型</p>
<p>In short, because <code>Option&lt;T&gt;</code> and <code>T</code> (where <code>T</code> can be any type) are different types, the compiler won’t let us use an <code>Option&lt;T&gt;</code> value as if it were definitely a valid value. For example, this code won’t compile because it’s trying to add an <code>i8</code> to an <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust">    let x: i8 = 5;
    let y: Option&lt;i8&gt; = Some(5);

    let sum = x + y;
</code></pre>
<p><strong>In other words, you have to convert an <code>Option&lt;T&gt;</code> to a <code>T</code> before you can perform <code>T</code> operations with it.</strong></p>
<p>So, how do you get the <code>T</code> value out of a <code>Some</code> variant when you have a value of type <code>Option&lt;T&gt;</code> so you can use that value? The <code>Option&lt;T&gt;</code> enum has a large number of methods that are useful in a variety of situations; you can check them out in <a href="https://doc.rust-lang.org/std/option/enum.Option.html">its documentation</a>. Becoming familiar with the methods on <code>Option&lt;T&gt;</code> will be extremely useful in your journey with Rust.</p>
<p><strong>In general,</strong> in order to use an <code>Option&lt;T&gt;</code> value, you want to have code that will handle each variant. You want some code that will run only when you have a <code>Some(T)</code> value, and this code is allowed to use the inner <code>T</code>. You want some other code to run if you have a <code>None</code> value, and that code doesn’t have a <code>T</code> value available. The <code>match</code> expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</p>
<h2>The <code>match</code> Control Flow Operator</h2>
<p><strong>Rust has an extremely powerful control flow operator called <code>match</code> that allows you to compare a value against a series of patterns and then execute code based on which pattern matches.</strong></p>
<p>如何具体化<code>match</code>的思想</p>
<pre><code>Think of a match expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a match, and at the first pattern the value “fits,” the value falls into the associated code block to be used during execution.
</code></pre>
<p>然后就有了下面这段代码</p>
<pre><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}

fn main() {
    // let coin = Coin::Penny;
    println!(&quot;Penny {}&quot;,value_in_cents(Coin::Penny));
    println!(&quot;Nickel {}&quot;,value_in_cents(Coin::Nickel));
    println!(&quot;Dime {}&quot;,value_in_cents(Coin::Dime));
    println!(&quot;Quarter {}&quot;,value_in_cents(Coin::Quarter));
}
</code></pre>
<p>Next are the <code>match</code> arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value <code>Coin::Penny</code> and then the <code>=&gt;</code> operator that separates the pattern and the code to run. The code in this case is just the value <code>1</code>. Each arm is separated from the next with a comma.</p>
<p><strong>If that pattern doesn’t match the value, execution continues to the next arm, much as in a coin-sorting machine.</strong></p>
<h3>Patterns that Bind to Values</h3>
<p>对枚举值进行键值绑定</p>
<pre><code class="language-rust">#[derive(Debug)]
// enum Coin {
//     Penny,
//     Nickel,
//     Dime,
//     Quarter,
// }
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State Quarter from {:?}!&quot;,state);
            25
        },
    }
}

fn main() {

    // let coin = Coin::Penny;
    println!(&quot;Penny {}&quot;,value_in_cents(Coin::Penny));
    println!(&quot;Nickel {}&quot;,value_in_cents(Coin::Nickel));
    println!(&quot;Dime {}&quot;,value_in_cents(Coin::Dime));
    println!(&quot;Quarter {}&quot;,value_in_cents(Coin::Quarter(UsState::Alaska)));
}
</code></pre>
<h3>Matching with <code>Option</code></h3>
<p>we can also handle <code>Option&lt;T&gt;</code> using <code>match</code> as we did with the <code>Coin</code> enum! Instead of comparing coins, we’ll compare the variants of <code>Option&lt;T&gt;</code>, but the way that the <code>match</code> expression works remains the same.</p>
<pre><code class="language-rust">fn main() {
    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            None =&gt; None,
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}
</code></pre>
<h3>Matches Are Exhaustive</h3>
<p>There’s one other aspect of <code>match</code> we need to discuss. Consider this version of our <code>plus_one</code> function that has a bug and won’t compile:</p>
<pre><code class="language-rust">fn main() {
    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
        match x {
            Some(i) =&gt; Some(i + 1),
        }
    }

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);
}
</code></pre>
<p><strong>We didn’t handle the <code>None</code> case, so this code will cause a bug.</strong></p>
<p>使用<code>_</code>来接受其他情况</p>
<pre><code class="language-rust">fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        other =&gt; move_player(other),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn move_player(num_spaces: u8) {}
}
</code></pre>
<p>等于</p>
<pre><code class="language-rust">fn main() {
    let dice_roll = 9;
    match dice_roll {
        3 =&gt; add_fancy_hat(),
        7 =&gt; remove_fancy_hat(),
        _ =&gt; reroll(),
    }

    fn add_fancy_hat() {}
    fn remove_fancy_hat() {}
    fn reroll() {}
}
</code></pre>
<h2>Concise Control Flow with <code>if let</code></h2>
<p>如果有如下代码</p>
<pre><code class="language-rust">fn main() {
    let config_max = Some(3u8);
    match config_max {
        Some(max) =&gt; println!(&quot;The maximum is configured to be {}&quot;, max),
        _ =&gt; (),
    }
}
</code></pre>
<p>可以被<code>if let </code>简化为</p>
<pre><code class="language-rust">fn main() {
    let config_max = Some(3u8);
    if let Some(max) = config_max {
        println!(&quot;The maximum is configured to be {}&quot;, max);
    }
}
</code></pre>
<p>If we wanted to count all non-quarter coins we see while also announcing the state of the quarters, we could do that with a <code>match</code> expression like this:</p>
<pre><code class="language-rust">#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn main() {
    let coin = Coin::Penny;
    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
        _ =&gt; count += 1,
    }
}
</code></pre>
<p>Or we could use an <code>if let</code> and <code>else</code> expression like this:</p>
<pre><code class="language-rust">#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn main() {
    let coin = Coin::Penny;
    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!(&quot;State quarter from {:?}!&quot;, state);
    } else {
        count += 1;
    }
}
</code></pre>
<h2><a href="https://doc.rust-lang.org/book/ch06-03-if-let.html#summary">Summary</a></h2>
<p>We’ve now covered how to use enums to create custom types that can be one of a set of enumerated values. We’ve shown how the standard library’s <code>Option&lt;T&gt;</code> type helps you use the type system to prevent errors. When enum values have data inside them, you can use <code>match</code> or <code>if let</code> to extract and use those values, depending on how many cases you need to handle.</p>
<p>Your Rust programs can now express concepts in your domain using structs and enums. Creating custom types to use in your API ensures type safety: the compiler will make certain your functions get only values of the type each function expects.</p>
<p>In order to provide a well-organized API to your users that is straightforward to use and only exposes exactly what your users will need, let’s now turn to Rust’s modules.</p>
<h1>7-Managing Growing Projects with Packages, Crates, and Modules</h1>
<p>The programs we’ve written so far have been in one module in one file.</p>
<p>once you’ve implemented an operation, other code can call that code via the code’s public interface without knowing how the implementation works.</p>
<p>These features, sometimes collectively referred to as the <em>module system</em>模块系统, include:</p>
<ul>
<li><strong>Packages:</strong> A Cargo feature that lets you build, test, and share crates</li>
<li><strong>Crates:</strong> A tree of modules that produces a library or executable</li>
<li><strong>Modules</strong> and <strong>use:</strong> Let you control the organization, scope, and privacy of paths</li>
<li><strong>Paths:</strong> A way of naming an item, such as a struct, function, or module</li>
</ul>
<h2>Packages and Crates</h2>
<p>Let’s walk through what happens when we create a package. First, we enter the command <code>cargo new</code>:</p>
<ul>
<li>Cargo.toml
<ul>
<li>Cargo follows a convention that <em>src/main.rs</em> is the crate root of a binary crate with the same name as the package.</li>
<li>Likewise, Cargo knows that if the package directory contains <em>src/lib.rs</em>, the package contains a library crate with the same name as the package, and <em>src/lib.rs</em> is its crate root.</li>
<li>Here, we have a package that only contains <em>src/main.rs</em>, meaning it only contains a binary crate named <code>my-project</code>.</li>
<li>A package can have multiple binary crates by placing files in the <em>src/bin</em> directory: each file will be a separate binary crate.</li>
</ul>
</li>
</ul>
<h2>Defining Modules to Control Scope and Privacy</h2>
<p>src/lib.rs</p>
<pre><code class="language-rust">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
</code></pre>
<p>We define a module by starting with the <code>mod</code> keyword and then specify the name of the module (in this case, <code>front_of_house</code>)</p>
<p><strong>By using modules, we can group related definitions together and name why they’re related.</strong></p>
<p>Listing 7-2 shows the module tree for the structure in Listing 7-1.</p>
<pre><code>crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p>这个说明了模式是可以嵌套的，可以类比计算机的文件系统</p>
<h2>Paths for Referring to an Item in the Module Tree</h2>
<p>A path can take two forms:</p>
<ul>
<li>An <em>absolute path</em> starts from a crate root by using a crate name or a literal <code>crate</code>.</li>
<li>A <em>relative path</em> starts from the current module and uses <code>self</code>, <code>super</code>, or an identifier in the current module.</li>
</ul>
<p><strong>Let’s return to the example in Listing 7-1. How do we call the <code>add_to_waitlist</code> function?</strong></p>
<p>using the <code>crate</code> name to start from the crate root is like using <code>/</code> to start from the filesystem root in your shell.</p>
<p>该程序是有问题的</p>
<pre><code class="language-rust">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><strong>Our preference is to specify absolute paths because it’s more likely to move code definitions and item calls independently of each other</strong></p>
<p><strong>The <code>pub</code> keyword on a module only lets code in its ancestor modules refer to it.</strong></p>
<p><strong>rust默认模式是私有的</strong></p>
<p>如何访问</p>
<pre><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<h3>Starting Relative Paths with <code>super</code></h3>
<p>We can also construct relative paths that begin in the parent module by using <code>super</code> at the start of the path. <code>super</code>访问上级目录的函数，有点像<code>..</code>的访问</p>
<pre><code class="language-rust">fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
</code></pre>
<h3>Making Structs and Enums Public</h3>
<p>同样也是<code>pub</code>的用法</p>
<pre><code class="language-rust">mod back_of_house {
    pub struct Breakfast {
        pub toast: String, 
        seasonal_fruit: String,
    }
    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;Peaches&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;);
    meal.toast = String::from(&quot;Wheat&quot;);
    println!(&quot;I'd like {} toast please&quot;,meal.toast);
}
</code></pre>
<h2>Bringing Paths into Scope with the <code>use</code> Keyword</h2>
<p>对每次都要调用的函数，有更简单的方法来避免rust的重复寻址</p>
<p>像是从</p>
<pre><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    front_of_house::hosting::add_to_waitlist();
    front_of_house::hosting::add_to_waitlist();
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p>可以使用<code>use</code>关键字变为</p>
<pre><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre>
<h3>Creating Idiomatic <code>use</code> Paths</h3>
<p>Bringing the function’s parent module into scope with <code>use</code> means we have to specify the parent module when calling the function.</p>
<pre><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
</code></pre>
<p>如果有多个类中定义了<code>add_to_waitlist</code>函数，上面的使用会让我们不知道<code>eat_at_restaurant</code>的中的是属于哪个类</p>
<p>下面的例子使用标准库中的哈希函数计算来使用惯用方式管理hash结构体</p>
<p>src/main.rs</p>
<pre><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 1);
}
</code></pre>
<p>There’s no strong reason behind this idiom: it’s just the convention that has emerged, and folks have gotten used to reading and writing Rust code this way.</p>
<p>Listing 7-15 shows how to bring two <code>Result</code> types into scope that have the same name but different parent modules and how to refer to them.</p>
<pre><code class="language-rust">use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
    Ok(())
}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
    Ok(())
}
</code></pre>
<h3>Providing New Names with the <code>as</code> Keyword</h3>
<p>和python的<code>as</code>关键字用法差不多</p>
<h3>Re-exporting Names with <code>pub use</code></h3>
<p>To enable the code that calls our code to refer to that name as if it had been defined in that code’s scope, we can combine <code>pub</code> and <code>use</code>.</p>
<pre><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre>
<p>Re-exporting is useful when the internal structure of your code is different from how programmers calling your code would think about the domain.</p>
<h3>Using External Packages</h3>
<p>就像章节2中说到的那样,需要在<code>toml</code>中加入库</p>
<pre><code class="language-toml">rand = &quot;0.8.3&quot;
</code></pre>
<p>之后就可以使用了</p>
<h3>Using Nested Paths to Clean Up Large <code>use</code> Lists</h3>
<p>当你一次要导入多个mod中的fn时，可以使用如下嵌套(Go抄了属于是)</p>
<pre><code class="language-rust">use rand::Rng;
// --snip--
use std::{cmp::Ordering, io};
// --snip--

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1..101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin()
        .read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p>甚至可以把自身嵌套使用</p>
<pre><code class="language-rust">use std::io::{self, Write};
</code></pre>
<h3>The Glob Operator</h3>
<p>使用mod中的全部内容，类似python的<code>from libs import *</code>,rust有</p>
<pre><code class="language-rust">#![allow(unused)]
fn main() {
use std::collections::*;
}
</code></pre>
<h2>Separating Modules into Different Files</h2>
<p>For example, let’s start from the code in Listing 7-17 and move the <code>front_of_house</code> module to its own file <em>src/front_of_house.rs</em> by changing the crate root file so it contains the code shown in Listing 7-21. In <strong>this case, the crate root file is <em>src/lib.rs</em>, but this procedure also works with binary crates whose crate root file is <em>src/main.rs</em>.</strong></p>
<p>首先是src/lib.rs</p>
<pre><code class="language-rust">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre>
<p>接着是src/front_of_house.rs</p>
<pre><code class="language-rust">pub mod hosting {
    pub fn add_to_waitlist() {}
}
</code></pre>
<p>最后在在src/front_of_house/hosting.rs中实现<code>add_to_waitlist</code></p>
<pre><code class="language-rust">#![allow(unused)]
fn main() {
pub fn add_to_waitlist() {}
}
</code></pre>
<h2>Summary</h2>
<p>Rust lets you split a package into multiple crates and a crate into modules so you can refer to items defined in one module from another module. You can do this by specifying absolute or relative paths. These paths can be brought into scope with a <code>use</code> statement so you can use a shorter path for multiple uses of the item in that scope. Module code is private by default, but you can make definitions public by adding the <code>pub</code> keyword.</p>
<p>In the next chapter, we’ll look at some collection data structures in the standard library that you can use in your neatly organized code.</p>
<h1>8-Common Collections</h1>
<p>rust官方库有些很有用的数据结构被称作为'collections'.</p>
<p>这些collections指针是被存储在heap中的</p>
<p>感觉类似于c++的STL中的容器</p>
<ul>
<li>A <em>vector</em> allows you to store a variable number of values next to each other.</li>
<li>A <em>string</em> is a collection of characters. We’ve mentioned the <code>String</code> type previously, but in this chapter we’ll talk about it in depth.</li>
<li>A <em>hash map</em> allows you to associate a value with a particular key. It’s a particular implementation of the more general data structure called a <em>map</em>.</li>
</ul>
<h2>Storing Lists of Values with Vectors</h2>
<p>本节教程教学<code>vector</code>容器</p>
<pre><code class="language-rust">fn main() {
	let v: Vec&lt;i32&gt; = Vec::new();
}
</code></pre>
<p><strong>Vectors are implemented using generics</strong>，相当于创建了一个vector指针</p>
<pre><code class="language-rust">    //给vector创建初始值
    let v2 = vec![1,2,3];
</code></pre>
<h3>Updating a Vector</h3>
<p>使用<code>push</code>函数</p>
<pre><code class="language-rust">    //Update a Vector
    v.push(5);
    v.push(6);
    v.push(7);
    v.push(8);
</code></pre>
<p><strong>if we want to be able to change its value, we need to make it mutable using the <code>mut</code> keyword, as discussed in Chapter 3.</strong></p>
<h3>Dropping a Vector Drops Its Elements</h3>
<p>Like any other <code>struct</code>, a vector is freed when it goes out of scope, as annotated in Listing 8-4.</p>
<p>当一个vector被释放时，它的成员也会被释放掉</p>
<h3>Reading Elements of Vectors</h3>
<p>两种访问vector元素的方法</p>
<pre><code class="language-rust">    let v2 = vec![1,2,3,4,5];
    let third: &amp;i32 = &amp;v2[2];
    println!(&quot;the third ele is {}&quot;,third);

    match v2.get(2) {
        Some(third) =&gt; println!(&quot;The third ele is {}&quot;,third),
        None =&gt; println!(&quot;no third ele&quot;),
    }
</code></pre>
<ol>
<li>
<p>使用直接引用<code>&amp;v2[idx]</code></p>
</li>
<li>
<p>使用<code>get</code>方法后，使用match来判断元素不存</p>
</li>
</ol>
<p>当直接下标访问时，若元素不存在，会直接报错</p>
<p>关于vector引用，同样会因为reference 和 borrow原则出现报错，如</p>
<pre><code class="language-rust">fn main() {
    let mut v = vec![1, 2, 3, 4, 5];

    let first = &amp;v[0];

    v.push(6);

    println!(&quot;The first element is: {}&quot;, first);
}
</code></pre>
<p>原因时first创建了一个<strong>不可变</strong>的borrow，同时v.push方法有使用了<strong>可变</strong>的borrow。</p>
<h3>Iterating over the Values in a Vector</h3>
<p>利用迭代器访问容器</p>
<p>最简单的是使用<code>for</code>语句</p>
<pre><code class="language-rust">    {
        let v = vec![100,32,57];
        for i in &amp;v{
            println!(&quot;{}&quot;,i);
        }

        let mut v = vec![100,32,57];
        for i in &amp;mut v {
            *i += 50;
        }
    }
</code></pre>
<p>这里要对v中元素值进行修改，要使用<code>*</code>解引用才能访问到数值并修改</p>
<p>We’ll talk more about the dereference operator in the <a href="https://doc.rust-lang.org/book/ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">“Following the Pointer to the Value with the Dereference Operator”</a></p>
<h3>Using an Enum to Store Multiple Types</h3>
<p>say we want to get values from a row in a spreadsheet in which some of the columns in the row contain integers, some floating-point numbers, and some strings. We can define an enum whose variants will hold the different value types, and then all the enum variants will be considered the same type: that of the enum. Then we can create a vector that holds that enum and so, ultimately, holds different types.</p>
<pre><code class="language-rust">    //Part`3: Using an Enum to Store Multiple Types
    {
        enum SperateSheetCell {
            Int(i32),
            Float(f64),
            Text(String),
        }

        let row = vec![
            SperateSheetCell::Int(3),
            SperateSheetCell::Float(30.0),
            SperateSheetCell::Text(String::from(&quot;hello&quot;)),
        ]
    }
</code></pre>
<p>Rust needs to know what types will be in the vector at compile time so it knows exactly how much memory on the heap will be needed to store each element.</p>
<h2>Storing UTF-8 Encoded Text with Strings</h2>
<blockquote>
<h3><a href="https://doc.rust-lang.org/book/ch08-02-strings.html#what-is-a-string">What Is a String?</a></h3>
<p>We’ll first define what we mean by the term <em>string</em>. Rust has only one string type in the core language, which is the string slice <code>str</code> that is usually seen in its borrowed form <code>&amp;str</code>. In Chapter 4, we talked about <em>string slices</em>, which are references to some UTF-8 encoded string data stored elsewhere. String literals, for example, are stored in the program’s binary and are therefore string slices.</p>
<p>The <code>String</code> type, which is provided by Rust’s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to “strings” in Rust, they usually mean the <code>String</code> and the string slice <code>&amp;str</code> types, not just one of those types. Although this section is largely about <code>String</code>, both types are used heavily in Rust’s standard library, and both <code>String</code> and string slices are UTF-8 encoded.</p>
<p>Rust’s standard library also includes a number of other string types, such as <code>OsString</code>, <code>OsStr</code>, <code>CString</code>, and <code>CStr</code>. Library crates can provide even more options for storing string data. See how those names all end in <code>String</code> or <code>Str</code>? They refer to owned and borrowed variants, just like the <code>String</code> and <code>str</code> types you’ve seen previously. These string types can store text in different encodings or be represented in memory in a different way, for example. We won’t discuss these other string types in this chapter; see their API documentation for more about how to use them and when each is appropriate.</p>
</blockquote>
<p>什么是字符串？
我们将首先定义术语字符串的含义。 Rust 在核心语言中只有一种字符串类型，即通常以借用形式 &amp;str 看到的字符串切片 str。在第 4 章中，我们讨论了字符串切片，它是对存储在其他地方的一些 UTF-8 编码字符串数据的引用。例如，字符串文字存储在程序的二进制文件中，因此是字符串切片。</p>
<p>String 类型由 Rust 的标准库提供而不是编码到核心语言中，它是一种可增长、可变、拥有、UTF-8 编码的字符串类型。当 Rustaceans 在 Rust 中提到“字符串”时，他们通常指的是 String 和字符串 slice &amp;str 类型，而不仅仅是这些类型中的一种。虽然本节主要是关于字符串，但这两种类型在 Rust 的标准库中都被大量使用，并且字符串和字符串切片都是 UTF-8 编码的。</p>
<p>Rust 的标准库还包括许多其他字符串类型，例如 <code>OsString</code>、<code>OsStr</code>、<code>CString </code>和 <code>CStr</code>。 Library crate 可以提供更多选项来存储字符串数据。看看这些名字都是如何以 String 或 Str 结尾的？它们指的是拥有和借用的变体，就像您之前看到的 <code>String </code>和 <code>str </code>类型一样。例如，这些字符串类型可以以不同的编码存储文本或以不同的方式在内存中表示。我们不会在本章中讨论这些其他字符串类型；请参阅他们的 API 文档，了解有关如何使用它们以及何时使用它们的更多信息。</p>
<h3><a href="https://doc.rust-lang.org/book/ch08-02-strings.html#creating-a-new-string">Creating a New String</a></h3>
<p>和创建vector差不多</p>
<pre><code class="language-rust">let mut s = String::new();
</code></pre>
<p>This line creates a new empty string called <code>s</code>, which we can then load data into.</p>
<pre><code class="language-rust">    {
        //创建一个字符串类型
        let mut s = String::new();//s类型是String

        //str转String
        let data = &quot;initial contents&quot;;

        let s = data.to_string();

        let s = &quot;initial contents2&quot;.to_string();
    }
</code></pre>
<p>还有就是最常用的<code>String::from()</code></p>
<h3>Updating a String</h3>
<p>if you push more data into it. In addition, you can conveniently use the <code>+</code> operator or the <code>format!</code> macro to concatenate <code>String</code> values.</p>
<h4>Appending to a String with <code>push_str</code> and <code>push</code></h4>
<ul>
<li>
<p>We can grow a <code>String</code> by using the <code>push_str</code> method to append a string slice</p>
<pre><code class="language-rust">    let mut s = String::from(&quot;foo&quot;);
    s.push_str(&quot;bar&quot;);
</code></pre>
<p>The <code>push_str</code> method takes a string slice because we don’t necessarily want to take ownership of the parameter.</p>
<p>关于从属关系</p>
<pre><code class="language-rust">fn main() {
    let mut s1 = String::from(&quot;foo&quot;);
    let s2 = &quot;bar&quot;;
    s1.push_str(s2);
    println!(&quot;s2 is {}&quot;, s2);
}
</code></pre>
</li>
<li>
<p>The <code>push</code> method takes a single character as a parameter and adds it to the <code>String</code>.</p>
<pre><code class="language-rust">    let mut s = String::from(&quot;lo&quot;);
    s.push('l');
</code></pre>
</li>
</ul>
<h4>Concatenation with the <code>+</code> Operator or the <code>format!</code> Macro</h4>
<ul>
<li>
<p>使用<code>+</code>连接两个字符串</p>
<pre><code class="language-rust">            let s1 = String::from(&quot;Hello, &quot;);
            let s2 = String::from(&quot;world!&quot;);
            let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
</code></pre>
<p>此时的s3就是原来的s1，原因如下</p>
<p><strong>The reason <code>s1</code> is no longer valid after the addition and the reason we used a reference to <code>s2</code> has to do with the signature of the method that gets called when we use the <code>+</code> operator. The <code>+</code> operator uses the <code>add</code> method, whose signature looks something like this:</strong></p>
<pre><code class="language-rust">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>But wait—the type of <code>&amp;s2</code> is <code>&amp;String</code>, not <code>&amp;str</code>, as specified in the second parameter to <code>add</code>. So why does Listing 8-18 compile?</p>
<p>the compiler can <em>coerce</em> the <code>&amp;String</code> argument into a <code>&amp;str</code>.//强制转换</p>
<p>we can see in the signature that <code>add</code> takes ownership of <code>self</code>, because <code>self</code> does <em>not</em> have an <code>&amp;</code>. This means <code>s1</code> in Listing 8-18 will be moved into the <code>add</code> call and no longer be valid after that.</p>
</li>
<li>
<p>If we need to concatenate multiple strings, the behavior of the <code>+</code> operator gets unwieldy:</p>
<pre><code class="language-rust">fn main() {
    let s1 = String::from(&quot;tic&quot;);
    let s2 = String::from(&quot;tac&quot;);
    let s3 = String::from(&quot;toe&quot;);

    let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
}
</code></pre>
</li>
</ul>
<h3>Indexing into Strings</h3>
<p><strong>Rust strings don’t support indexing.</strong></p>
<h4>Internal Representation</h4>
<p>在rust中，String可以存储unicode类型，不同类型的存储长度导致无法找到位置</p>
<p>What should the value of <code>answer</code> be? Should it be <code>З</code>, the first letter? When encoded in UTF-8, the first byte of <code>З</code> is <code>208</code> and the second is <code>151</code>, so <code>answer</code> should in fact be <code>208</code>, but <code>208</code> is not a valid character on its own. Returning <code>208</code> is likely not what a user would want if they asked for the first letter of this string; however, that’s the only data that Rust has at byte index 0. Users generally don’t want the byte value returned, even if the string contains only Latin letters: if <code>&amp;&quot;hello&quot;[0]</code> were valid code that returned the byte value, it would return <code>104</code>, not <code>h</code>. To avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesn’t compile this code at all and prevents misunderstandings early in the development process.</p>
<h4>Bytes and Scalar Values and Grapheme Clusters! Oh My!</h4>
<p>Another point about UTF-8 is that there are actually three relevant ways to look at strings from Rust’s perspective: as <strong>bytes</strong>, <strong>scalar values</strong>, and <strong>grapheme clusters</strong></p>
<p>Rust provides different ways of interpreting the raw string data that computers store so that each program can choose the interpretation it needs, no matter what human language the data is in.</p>
<h3>Slicing Strings</h3>
<p>Rust asks you to be more specific if you really need to use indices to create string slices. To be more specific in your indexing and indicate that you want a string slice, rather than indexing using <code>[]</code> with a single number, you can use <code>[]</code> with a range to create a string slice containing particular bytes:</p>
<pre><code class="language-rust">            let hello = &quot;Здравствуйте&quot;;
            let s = &amp;hello[0..4];
</code></pre>
<h3>Methods for Iterating Over Strings</h3>
<p>If you need to perform operations on individual Unicode scalar values, the best way to do so is to use the <code>chars</code> method.</p>
<p>使用<code>chars</code>函数</p>
<pre><code class="language-rust">for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
</code></pre>
<p>The <code>bytes</code> method returns each raw byte, which might be appropriate for your domain:</p>
<pre><code class="language-rust">for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
</code></pre>
<p>结果</p>
<pre><code>224
164
// --snip--
165
135
</code></pre>
<h3>Strings Are Not So Simple</h3>
<p>To summarize, strings are complicated. Different programming languages make different choices about how to present this complexity to the programmer. Rust has chosen to make the correct handling of <code>String</code> data the default behavior for all Rust programs, which means programmers have to put more thought into handling UTF-8 data upfront. This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle.</p>
<h2>Storing Keys with Associated Values in Hash Maps</h2>
<h3>Creating a New Hash Map</h3>
<p>同上面两个差不多，使用<code>new</code>创建，<code>insert</code>加入值</p>
<pre><code class="language-rust">        use std::collections::HashMap;
        let mut socers = HashMap::new();

        socers.insert(String::from(&quot;Blue&quot;),10);
        socers.insert(String::from(&quot;Yellow&quot;), 50);
</code></pre>
<p>创建了Buel:10，Yellow:50，两个kv</p>
<p>使用iterators and the <code>collect</code> method on a vector of tuples, where each tuple consists of a key and its value.</p>
<pre><code class="language-rust">        use std::collections::HashMap;
        let teams = vec![String::from(&quot;Bule&quot;),String::from(&quot;Yellow&quot;)];
        let initial_scores = vec![10,50];

        let mut scores: HashMap&lt;_,_&gt; = 
            teams.into_iter().zip(initial_scores.into_iter()).collect();
</code></pre>
<h3>Hash Maps and Ownership</h3>
<pre><code class="language-rust">        use std::collections::HashMap;

        let field_name = String::from(&quot;Favorite color&quot;);
        let field_value = String::from(&quot;Blue&quot;);
    
        let mut map = HashMap::new();
        map.insert(field_name, field_value);
        // field_name and field_value are invalid at this point, try using them and
        // see what compiler error you get!
</code></pre>
<p>这样的话，<code>field_name</code>和<code>field_value</code>会变成map的从属，就不能再被访问到了</p>
<h3>Accessing Values in a Hash Map</h3>
<p>使用<code>get</code>方法</p>
<pre><code class="language-rust">    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    let team_name = String::from(&quot;Blue&quot;);
    let score = scores.get(&amp;team_name);
</code></pre>
<p>the result will be <code>Some(&amp;10)</code>. The result is wrapped in <code>Some</code> because <code>get</code> returns an <code>Option&lt;&amp;V&gt;</code>; if there’s no value for that key in the hash map, <code>get</code> will return <code>None</code>. The program will need to handle the <code>Option</code> in one of the ways that we covered in Chapter 6.</p>
<p>使用<code>for</code>循环访问</p>
<pre><code class="language-rust">    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Yellow&quot;), 50);

    for (key, value) in &amp;scores {
        println!(&quot;{}: {}&quot;, key, value);
    }
</code></pre>
<p>直接使用引用访问</p>
<h3>Updating a Hash Map</h3>
<h4>Overwriting a Value</h4>
<p>直接使用<code>insert</code>即可覆盖</p>
<pre><code class="language-rust">    scores.insert(String::from(&quot;Blue&quot;), 10);
    scores.insert(String::from(&quot;Blue&quot;), 25);
</code></pre>
<h4>Only Inserting a Value If the Key Has No Value</h4>
<p><strong>Hash maps have a special API for this called <code>entry</code> that takes the key you want to check as a parameter.</strong></p>
<pre><code class="language-rust">    use std::collections::HashMap;

    let mut scores = HashMap::new();
    scores.insert(String::from(&quot;Blue&quot;), 10);

    scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
    scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

    println!(&quot;{:?}&quot;, scores);
</code></pre>
<h4>Updating a Value Based on the Old Value</h4>
<p>Listing 8-26 shows code that counts how many times each word appears in some text.</p>
<pre><code class="language-rust">        //update based on old value
        use std::collections::HashMap;

        let text = &quot;hello world wonderful world&quot;;
    
        let mut map = HashMap::new();
    
        for word in text.split_whitespace() {
            let count = map.entry(word).or_insert(0);
            *count += 1;
        }
    
        println!(&quot;{:?}&quot;, map);
</code></pre>
<h3>Hashing Functions</h3>
<p>By default, <code>HashMap</code> uses a hashing function called SipHash that can provide resistance to Denial of Service (DoS) attacks involving hash tables<a href="https://doc.rust-lang.org/book/ch08-03-hash-maps.html#siphash">1</a>. This is not the fastest hashing algorithm available, but the trade-off for better security that comes with the drop in performance is worth it. If you profile your code and find that the default hash function is too slow for your purposes, you can switch to another function by specifying a different <em>hasher</em>. A hasher is a type that implements the <code>BuildHasher</code> trait. We’ll talk about traits and how to implement them in Chapter 10. You don’t necessarily have to implement your own hasher from scratch; <a href="https://crates.io/">crates.io</a> has libraries shared by other Rust users that provide hashers implementing many common hashing algorithms.</p>
<h2>Summary</h2>
<p>Vectors, strings, and hash maps will provide a large amount of functionality necessary in programs when you need to store, access, and modify data. Here are some exercises you should now be equipped to solve:</p>
<ul>
<li>Given a list of integers, use a vector and return the mean (the average value), median (when sorted, the value in the middle position), and mode (the value that occurs most often; a hash map will be helpful here) of the list.</li>
<li>Convert strings to pig latin. The first consonant of each word is moved to the end of the word and “ay” is added, so “first” becomes “irst-fay.” Words that start with a vowel have “hay” added to the end instead (“apple” becomes “apple-hay”). Keep in mind the details about UTF-8 encoding!</li>
<li>Using a hash map and vectors, create a text interface to allow a user to add employee names to a department in a company. For example, “Add Sally to Engineering” or “Add Amir to Sales.” Then let the user retrieve a list of all people in a department or all people in the company by department, sorted alphabetically.</li>
</ul>
<p>The standard library API documentation describes methods that vectors, strings, and hash maps have that will be helpful for these exercises!</p>
<p>We’re getting into more complex programs in which operations can fail, so, it’s a perfect time to discuss error handling. We’ll do that next!</p>
<h1>9-Error Handling</h1>
<p>In many cases, Rust requires you to acknowledge the possibility of an error and take some action before your code will compile.</p>
<p>Rust groups errors into two major categories: <em>recoverable</em> and <em>unrecoverable</em> errors.</p>
<ul>
<li>
<p>recoverable</p>
<p>such as a file not found error, it’s reasonable to report the problem to the user and retry the operation.</p>
</li>
<li>
<p>Unrecoverable</p>
<p>always symptoms of bugs, like trying to access a location beyond the end of an array.</p>
</li>
</ul>
<p>Rust doesn’t have exceptions. Instead, it has the type <code>Result&lt;T, E&gt;</code> for recoverable errors and the <code>panic!</code> macro that stops execution when the program encounters an unrecoverable error.</p>
<h2>Unrecoverable Errors with <code>panic!</code></h2>
<p>When the <code>panic!</code> macro executes, your program will print a failure message, unwind and clean up the stack, and then quit.</p>
<pre><code class="language-rust">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre>
<pre><code>thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>The first line shows our panic message and the place in our source code where the panic occurred: <em>src/main.rs:2:5</em> indicates that it’s the second line, fifth character of our <em>src/main.rs</em> file.</p>
<p>In other cases, the <code>panic!</code> call might be in code that our code calls, and the filename and line number reported by the <strong>error message will be someone else’s code where the <code>panic!</code> macro is called, not the line of our code that eventually led to the <code>panic!</code> call.</strong></p>
<h3>Using a <code>panic!</code> Backtrace</h3>
<p>利用错误代码实现函数反追踪</p>
<pre><code class="language-rust">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre>
<pre><code>thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 
99', src/main.rs:3:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>A <em>backtrace</em> is a list of all the functions that have been called to get to this point.</p>
<p><strong>RUST_BACKTRACE</strong></p>
<pre><code class="language-shell">joe1sn@MSI:/mnt/d/Programming/Rust/The Rust Programming Language/9-Error Handling/unrecoverable_error$ RUST_BACKTRACE=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.09s
     Running `target/debug/unrecoverable_error`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 
99', src/main.rs:3:5
stack backtrace:
   0: rust_begin_unwind
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/std/src/panicking.rs:517:5
   1: core::panicking::panic_fmt
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:101:14
   2: core::panicking::panic_bounds_check
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:77:5
   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:184:10
   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index    
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:15:9
   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/alloc/src/vec/mod.rs:2465:9
   6: unrecoverable_error::main
             at ./src/main.rs:3:5
   7: core::ops::function::FnOnce::call_once
             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p><strong>Debug symbols are enabled by default when using <code>cargo build</code> or <code>cargo run</code> without the <code>--release</code> flag, as we have here.</strong></p>
<p>We’ll come back to <code>panic!</code> and when we should and should not use <code>panic!</code> to handle error conditions in the <a href="https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">“To <code>panic!</code> or Not to <code>panic!</code>”</a> section later in this chapter. Next, we’ll look at how to recover from an error using <code>Result</code>.</p>
<h2>Recoverable Errors with <code>Result</code></h2>
<p>Recall from <a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">“Handling Potential Failure with the <code>Result</code> Type”</a> in Chapter 2 that the <code>Result</code> enum is defined as having two variants, <code>Ok</code> and <code>Err</code>, as follows:</p>
<pre><code class="language-rust">fn main() {
    enum Result&lt;T, E&gt; {
        Ok(T),
        Err(E),
    }
}
</code></pre>
<p>创建一个一定会出错的程序</p>
<pre><code class="language-rust">let f = File::open(&quot;hello.txt&quot;);
</code></pre>
<p>match的验证代码</p>
<pre><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;Problem opening the file: {:?}&quot;, error),
    };
}
</code></pre>
<pre><code>thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace 
</code></pre>
<h3>Matching on Different Errors</h3>
<p>if <code>File::open</code> failed because the file doesn’t exist, we want to create the file and return the handle to the new file.</p>
<p>If <code>File::open</code> failed for any other reason—for example, because we didn’t have permission to open the file—we still want the code to <code>panic!</code> in the same way as it did in Listing 9-4.</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem creating new file&quot;),
            },
            other_error =&gt; {
                panic!(&quot;Problem opening the file: {:?}&quot;, other_error)
            }
        },
    };
}
</code></pre>
<p>In Chapter 13, you’ll learn about closures; the <code>Result&lt;T, E&gt;</code> type has many methods that accept a closure and are implemented using <code>match</code> expressions. Using those methods will make your code more concise. A more seasoned Rustacean might write this code instead of Listing 9-5:</p>
<pre><code class="language-rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Problem creating the file: {:?}&quot;, error);
            })
        } else {
            panic!(&quot;Problem opening the file: {:?}&quot;, error);
        }
    });
}
</code></pre>
<h3>Shortcuts for Panic on Error: <code>unwrap</code> and <code>expect</code></h3>
<p><strong>unwrap</strong></p>
<pre><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre>
<p>If we run this code without a <em>hello.txt</em> file, we’ll see an error message from the <code>panic!</code> call that the <code>unwrap</code> method makes:</p>
<p><strong>expect</strong></p>
<p>Using <code>expect</code> instead of <code>unwrap</code> and providing good error messages can convey your intent and make tracking down the source of a panic easier.</p>
<pre><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}
</code></pre>
<h3>Propagating Errors</h3>
<p>instead of handling the error within this function, you can return the error to the calling code so that it can decide what to do. This is known as <em>propagating</em> the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.</p>
<p>For example, Listing 9-6 shows a function that reads a username from a file. If the file doesn’t exist or can’t be read, this function will return those errors to the code that called this function.</p>
<pre><code class="language-rust">fn main() {
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
}
</code></pre>
<h4>A Shortcut for Propagating Errors: the <code>?</code> Operator</h4>
<pre><code class="language-rust">fn main() {
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
}
</code></pre>
<pre><code class="language-rust">fn main() {
use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
}
</code></pre>
<pre><code class="language-rust">fn main() {
use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
}
</code></pre>
<h4>The <code>?</code> Operator Can Be Used in Functions That Return <code>Result</code></h4>
<p>报错程序</p>
<pre><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<pre><code>$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)
 --&gt; src/main.rs:4:36
  |
3 | / fn main() {
4 | |     let f = File::open(&quot;hello.txt&quot;)?;
  | |                                    ^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`
  = note: required by `from_residual`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling`

To learn more, run the command again with --verbose.
</code></pre>
<p>The <code>main</code> function is special, and there are restrictions on what its return type must be. One valid return type for main is <code>()</code>, and conveniently, another valid return type is <code>Result&lt;T, E&gt;</code>, as shown here:</p>
<pre><code class="language-rust">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let f = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}
</code></pre>
<h2><a href="https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">To <code>panic!</code> or Not to <code>panic!</code></a></h2>
<h2><a href="https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#summary">Summary</a></h2>
<p>Rust’s error handling features are designed to help you write more robust code. The <code>panic!</code> macro signals that your program is in a state it can’t handle and lets you tell the process to stop instead of trying to proceed with invalid or incorrect values. The <code>Result</code> enum uses Rust’s type system to indicate that operations might fail in a way that your code could recover from. You can use <code>Result</code> to tell code that calls your code that it needs to handle potential success or failure as well. Using <code>panic!</code> and <code>Result</code> in the appropriate situations will make your code more reliable in the face of inevitable problems.</p>
<p>Now that you’ve seen useful ways that the standard library uses generics with the <code>Option</code> and <code>Result</code> enums, we’ll talk about how generics work and how you can use them in your code.</p>
<h1>10-Generic Types, Traits, and Lifetimes</h1>
<p>rust使用泛型来对 duplication of concepts 处理</p>
<p>When we’re writing code, we can express the behavior of generics or how they relate to other generics without knowing what will be in their place when compiling and running the code.</p>
<p>一些之前使用过的例子</p>
<p>like <code>i32</code> or <code>String</code>. In fact, we’ve already used generics in Chapter 6 with <code>Option&lt;T&gt;</code>, Chapter 8 with <code>Vec&lt;T&gt;</code> and <code>HashMap&lt;K, V&gt;</code>, and Chapter 9 with <code>Result&lt;T, E&gt;</code>.</p>
<p>rust使用特征<em>traits</em> 来定义泛型的行为</p>
<ul>
<li>First, we’ll review how to extract a function to reduce code duplication.</li>
<li>Then you’ll learn how to use <em>traits</em> to define behavior in a generic way.</li>
<li>Finally, we’ll discuss <em>lifetimes</em>, a variety of generics that give the compiler information about how references relate to each other.</li>
</ul>
<h2>Removing Duplication by Extracting a Function</h2>
<p>Before diving into generics syntax, let’s first look at how to <strong>remove duplication that doesn’t involve generic types by extracting a function</strong>.</p>
<p>src/main.rs</p>
<pre><code class="language-rust">fn main() {
    let number_list = vec![34,35,654,234,12,23];
    let mut largest = number_list[0];
    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre>
<p>现在要得到两个数列中的最大数</p>
<pre><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre>
<p>其中最开始的</p>
<pre><code class="language-rust">    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];
</code></pre>
<p>会被重复定义</p>
<p>这个时候定义成函数</p>
<pre><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
    assert_eq!(result, 100);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
    assert_eq!(result, 6000);
}
</code></pre>
<p>In sum, here are the steps we took to change the code from Listing 10-2 to Listing 10-3:</p>
<ol>
<li>Identify duplicate code.</li>
<li>Extract the duplicate code into the body of the function and specify the inputs and return values of that code in the function signature.</li>
<li>Update the two instances of duplicated code to call the function instead.</li>
</ol>
<h2>Generic Data Types</h2>
<p>第一时间想到的肯定是c++里面的泛型</p>
<p>测试程序如下</p>
<pre><code class="language-rust">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<pre><code>error[E0369]: binary operation `&gt;` cannot be applied to type `T`
help: consider restricting type parameter `T`
  |
1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; T {
  |             ++++++++++++++++++++++

</code></pre>
<p>其中<code>std::cmp::PartialOrd</code>就是泛型的一个特征</p>
<p><strong>Because we want to compare values of type <code>T</code> in the body, we can only use types whose values can be ordered. To enable comparisons, the standard library has the <code>std::cmp::PartialOrd</code> trait that you can implement on types (see Appendix C for more on this trait).</strong></p>
<h3>In Struct Definitions</h3>
<p>泛型结构体</p>
<pre><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre>
<p>If we create an instance of a <code>Point&lt;T&gt;</code> that has values of different types, as in Listing 10-7, our code won’t compile.</p>
<p>解决这个问题可以使用</p>
<pre><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}
</code></pre>
<h3><a href="https://doc.rust-lang.org/book/ch10-01-syntax.html#in-enum-definitions">In Enum Definitions</a></h3>
<p>略。。。</p>
<h2>Traits: Defining Shared Behavior</h2>
<p>We want to make a media aggregator library that can display summaries of data that might be stored in a <code>NewsArticle</code> or <code>Tweet</code> instance. To do this, we need a summary from each type, and we need to request that summary by calling a <code>summarize</code> method on an instance. Listing 10-12 shows the definition of a <code>Summary</code> trait that expresses this behavior.</p>
<pre><code class="language-rust">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
</code></pre>
<p>Each type implementing this trait must provide its own custom behavior for the body of the method. The compiler will enforce that any type that has the <code>Summary</code> trait will have the method <code>summarize</code> defined with this signature exactly.</p>
<h3>Implementing a Trait on a Type</h3>
<pre><code class="language-rust">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
</code></pre>
<h2><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">Validating References with Lifetimes</a></h2>
<h2><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#summary">Summary</a></h2>
<p>We covered a lot in this chapter! Now that you know about generic type parameters, traits and trait bounds, and generic lifetime parameters, you’re ready to write code without repetition that works in many different situations. Generic type parameters let you apply the code to different types. Traits and trait bounds ensure that even though the types are generic, they’ll have the behavior the code needs. You learned how to use lifetime annotations to ensure that this flexible code won’t have any dangling references. And all of this analysis happens at compile time, which doesn’t affect runtime performance!</p>
<p>Believe it or not, there is much more to learn on the topics we discussed in this chapter: Chapter 17 discusses trait objects, which are another way to use traits. There are also more complex scenarios involving lifetime annotations that you will only need in very advanced scenarios; for those, you should read the <a href="https://doc.rust-lang.org/reference/index.html">Rust Reference</a>. But next, you’ll learn how to write tests in Rust so you can make sure your code is working the way it should.</p>
<h1>后面的基本上就跳者来了，从项目中学代码</h1>

</div>
</div></body>