<!DOCTYPE html>
<head>
<meta charset="UTF-8" /><title>PureWeb Blog-JavaWeb笔记-注解</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>  <script>    document.querySelectorAll('code').forEach((code) => {      if (!code.classList.length) {        code.classList.add('language-bash');      }    });  </script>	<script>		document.addEventListener('DOMContentLoaded', (event) => {			hljs.highlightAll();		});	</script><link rel="stylesheet" href="../github.css">
<link rel="stylesheet" href="../speciou.css"
</head><body>    <div class="container">        <header class="main-header">            <h1 class="main-header__title uplize"><a class="main-header__title__link" href="/">Joe1sn's Cabinet</a></h1>            <nav class="main-header__nav">                <ul class="main-nav">                    <li class="main-nav__list"><a class="main-nav__list__link active" href="/" target="_self">HOME</a>                    </li>                    <li class="main-nav__list"><a class="main-nav__list__link" href="/archives/"                            target="_self">ARCHIVE</a>                    </li>                    <li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn"                            target="_blank">GITHUB</a></li>                </ul>            </nav>        </header>    </div><div class="typora-export os-windows"><div id="write" class>
<p><strong>2022-03-16 20:49:29</strong></p>
<p>注释部分</p>
<!-- more -->
<h2>注解</h2>
<p><strong>概念</strong>：说明程序。For计算机</p>
<blockquote>
<p><strong>从JDK1.5开始，Java增加对元数据的支持</strong>，也就是注解，注解与注释是有一定区别的，可以把注解理解为代码里的特殊标记，<strong>这些标记可以在编译，类加载，运行时被读取</strong>，并执行相应的处理。通过注解开发人员可以在不改变原有代码和逻辑的情况下在源代码中嵌入补充信息。</p>
</blockquote>
<blockquote>
<p>注释：用文字描述程序。For程序员</p>
</blockquote>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/eddfbc89d08cbd1cf6c61e1a3bcd242f.jpg" alt="" /></p>
<h2>作用</h2>
<ol>
<li>
<p>编写文档：标识生成doc文档</p>
<pre><code class="language-java">package LearnJunit.annotation;
/**
 * 注解 java doc演示
 * @since 1.5 
 * @author joe1sn
 * @version 1.0
 */
public class AnnoDemo1 {
    //计算两数之和
    public int add(int a, int b){
        return a+b;
    }
}

</code></pre>
<p><code>javadoc AnnoDemo1.java -encoding UTF-8 -charset UTF-8</code></p>
<pre><code>正在加载源文件AnnoDemo1.java...
正在构造 Javadoc 信息...
标准 Doclet 版本 1.8.0_301
正在构建所有程序包和类的树...
正在生成.\AnnoDemo1.html...
正在生成.\package-frame.html...
正在生成.\package-summary.html...
正在生成.\package-tree.html...
正在生成.\constant-values.html...
正在构建所有程序包和类的索引...
正在生成.\overview-tree.html...
正在生成.\index-all.html...
正在生成.\deprecated-list.html...
正在构建所有类的索引...
正在生成.\allclasses-frame.html...
正在生成.\allclasses-noframe.html...
正在生成.\index.html...
正在生成.\help-doc.html...
</code></pre>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/824030c0e01f1b9d908641eb1c531649.png" alt="image-20220317110445576" /></p>
</li>
<li>
<p>代码检查：代码分析（使用反射）</p>
<p>例子： <strong>@Override</strong></p>
<p>也可以自定义注解【使用反射】</p>
</li>
<li>
<p>让编译器实现基本的检查</p>
</li>
</ol>
<h2>JDK预定义注解</h2>
<ol>
<li>
<p><strong>@Override</strong></p>
<p>编译检查，检查被标记方法是否是被父类覆写的方法</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/d22da63fa06a2ff90c7fd341620b6694.png" alt="image-20220316205850409" /></p>
</li>
<li>
<p><strong>@Deprecated</strong></p>
<p>该注解内容已过时</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/553ce0833380809c33a8c6367e51e9fe.png" alt="image-20220317111415161" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/692186f911683d1e667c555ea00aebeb.png" alt="image-20220317111514278" /></p>
</li>
<li>
<p><strong>@SuppressWarnings</strong></p>
<p>压制警告，需要传参，一般传递&quot;all&quot;压制所有警告</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/33fb9bf43b067d9eafaf9c9f8fbc0f18.png" alt="image-20220317111629903" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/bd29498aa83737f8eb253b185c412e95.png" alt="" /></p>
</li>
</ol>
<p><strong>自定义注解及使用(解析)</strong></p>
<p><strong>格式</strong></p>
<pre><code class="language-java">@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
</code></pre>
<pre><code class="language-java">元注解
public @interface 注解名称{
    属性列表
}
</code></pre>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a0bfe62d40a309e36f5822ea1ddf0751.png" alt="image-20220317205535179" /></p>
<p><strong>本质</strong>：注解本质上就是一个接口，接口默认继承Annotation()</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/dc07bb2fa1d18d4faae9377a7f74222c.png" alt="image-20220317205755742" /></p>
<pre><code class="language-java">public interface MyAnno extends java.lang.annotation.Annotation {
}
</code></pre>
<p><strong>属性</strong>：接口中可以定义的成员方法</p>
<ul>
<li>
<p>要求：</p>
<ol>
<li>
<p>属性返回类型</p>
<ul>
<li>基本数据类型</li>
<li>String</li>
<li>枚举</li>
<li>注解</li>
<li>以上类型数组</li>
</ul>
<pre><code class="language-java">public @interface MyAnno {
    int show1();
    String show2();
    Person per();   //枚举
    MyAnno2 anno2();//注解
    String[] strs();//字符串数组
}
</code></pre>
</li>
<li>
<p>定义的属性在使用时需要给属性赋值</p>
<p>缺少赋值：</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/5190e30a9f7de7721cae0b5e8ed8edb3.png" alt="image-20220317210750659" /></p>
<p>只留下show1进行赋值</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/76ca396dd0a1f0648ff03f48ef821ec5.png" alt="image-20220317210854025" /></p>
<p>默认赋值</p>
<pre><code class="language-java">public @interface MyAnno {
    int age();
    String name() default &quot;Doe&quot;;
}
</code></pre>
<p>如果只有一个属性需要赋值，如果属性名称是value，直接赋值</p>
<pre><code class="language-java">package LearnJunit.annotation;

@MyAnno(1)
public class Worker {
}

</code></pre>
<p>对于枚举、注解、字符串的注解</p>
<pre><code class="language-java">@MyAnno(age=1,
        per=Person.P1,
        anno2=@MyAnno2,
//        strs={&quot;1&quot;,&quot;a&quot;,&quot;v&quot;}
        strs = &quot;abcdefg&quot;
)
public class Worker {
}
</code></pre>
</li>
</ol>
</li>
</ul>
<p><strong>元注解</strong>：用于描述注解的注解</p>
<ul>
<li>
<p>@Target：描述注解能够作用的位置</p>
<p>ElementType取值：</p>
<ul>
<li>TYPE：作用于类上</li>
<li>METHOD：作用于方法上</li>
<li>FIELD：作用于成员变量上</li>
</ul>
<pre><code class="language-java">//表示anno3注解只能作用于类上
@Target(value = {
        ElementType.TYPE,
        ElementType.METHOD,
        ElementType.FIELD
})
public @interface MyAnno3 {
}
</code></pre>
</li>
<li>
<p>@Retention：描述注解能被保留的阶段</p>
<p>RetentionPolicy：判断在哪个阶段，使用该注解</p>
<ol>
<li>SOURCE</li>
<li>CLASS</li>
<li>RUNTIME（一般使用这个）：会保留到class字节码文件中，并被JVM读取到</li>
</ol>
</li>
<li>
<p>@Documented：描述注解是否被抽取到api文档中</p>
<pre><code class="language-java">@MyAnno3
public class Worker {
    public String name = &quot;John&quot;;
    @MyAnno3
    public void show(){};
}
</code></pre>
<pre><code class="language-java">/**
 *
 - @Target：描述注解能够作用的位置
 - @Retention：描述注解能被保留的阶段
 - @Documented：描述注解是否被抽取到api文档中
 - @Inherited：描述注解是否这子类继承
 */

import java.lang.annotation.*;

//表示anno3注解只能作用于类上
@Target(value = {
        ElementType.TYPE,
        ElementType.METHOD,
        ElementType.FIELD
})
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnno3 {
}
</code></pre>
<img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/55ec7742b3dfd3a6307eab6c0fbfeb65.png" alt="image-20220317213546637" style="zoom:50%;" />
<p>删除该注解后</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/a5887fe0ae0e2f8ba715f092e921dbe5.png" alt="image-20220317213717359" /></p>
</li>
<li>
<p>@Inherited：描述注解是否被子类继承</p>
</li>
</ul>
<h2>解析注解</h2>
<p>将配置文件的工作交给注解完成</p>
<pre><code class="language-java">/**
 * 描述需要执行的类名和方法名
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Pro {
    String className();
    String method();
}
</code></pre>
<pre><code class="language-java">package LearnJunit.annotation;

import LearnJunit.reflect.ReflectDemo1;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Properties;

//假设框架类
@Pro(className = &quot;LearnJunit.annotation.Demo1&quot;,
        method = &quot;show&quot;
)
public class ReflectFramework {
    public static void main(String[] args) throws Exception {
        //1.解析注解
        //  获取该类的字节码文件对象
        Class&lt;ReflectFramework&gt; reflectFrameworkClass = ReflectFramework.class;
        //2.获得注解对象
        //  内存中生成了该注解接口的 子类实现对象
        Pro an = reflectFrameworkClass.getAnnotation(Pro.class);
        //3.调用注解对象中定义的抽象方法，获取返回值
        String className = an.className();

    }
}
</code></pre>
<p>关于步骤2，在 21行下个断点</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/d35c50f49cf1c60cb715378fd3d6b3ad.png" alt="image-20220318104234263" /></p>
<p>这个时候注解相关的都还没有对应数据，但是获得了注解(<code>.getAnnotation</code>)对象后</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/2772d124590eb9c47998ee09e53de0a2.png" alt="image-20220318104558428" /></p>
<p>不仅<code>reflectFrameworkClass</code>注解有了值，而且在内存中多出了一个<code>an</code>变量，而<code>an</code>就是我们注解的内容</p>
<p>最后加上</p>
<pre><code class="language-java">        //4.反射获得类
        Class aClass = Class.forName(className);
        //5.获得类的方法
        Method aMethod = aClass.getMethod(methodName);
        //6.调用方法
        Object aObject = aClass.newInstance();
        aMethod.invoke(aObject);
</code></pre>
<p>就能使用注解中的类的对应方法了</p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/043e3d7d89bd90901e4b29981c43aed9.png" alt="image-20220318105703388" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/9ec7243bbbb505cc94160fd5b7748d06.png" alt="image-20220318105745302" /></p>
<h2>案例</h2>
<p>测试类</p>
<p><code>LearnJunit.annotation.demo.Calculator</code></p>
<pre><code class="language-java">package LearnJunit.annotation.demo;

public class Calculator {
    @check
    public void add() {
        System.out.println(&quot;1 + 0 = &quot; + (1 + 0));
    }

    @check
    public void sub() {
        System.out.println(&quot;1 - 0 = &quot; + (1 - 0));
    }

    @check
    public void mul() {
        System.out.println(&quot;1 * 0 = &quot; + (1 * 0));
    }

    @check
    public void div() {
        System.out.println(&quot;1 / 0 = &quot; + (1 / 0));
    }

    public void show(){
        System.out.println(&quot;always normal&quot;);
    }
}
</code></pre>
<p>测试注解</p>
<p><code>LearnJunit.annotation.demo.check</code></p>
<pre><code class="language-java">package LearnJunit.annotation.demo;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface check {
}
</code></pre>
<p>测试方法</p>
<p><code>LearnJunit.annotation.demo.testCheck</code></p>
<pre><code class="language-java">package LearnJunit.annotation.demo;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Method;

/**
 * 简单测试框架
 * 挡住方法执行后，自动执行被检测的所有方法
 */
public class testCheck {
    public static void main(String[] args) throws IOException {
        //1.创建被测试对象
        Calculator calculator = new Calculator();
        //2.得到所有带注解的函数
        int e_num = 0;//出现异常的次数
        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bug.txt&quot;));//创建文件对象

        //2.1得到所有函数
        Method[] methods = calculator.getClass().getMethods();
        for (Method method:methods){
            //2.2检测是否带注解
            if(method.isAnnotationPresent(check.class)){
                //2.3若带注解则执行
                try {
                    method.invoke(calculator);
                } catch(Exception e){
                    //2.3.1捕获异常
                    e.printStackTrace();
                    //2.3.2记录到文件
                    e_num++;
                    bw.write(&quot;+++++&quot;+method.getName()+&quot; 方法异常&quot;);
                    bw.newLine();
                    bw.write(&quot;异常名称&gt;&gt; &quot;+e.getCause().getClass().getSimpleName());
                    bw.newLine();
                    bw.write(&quot;异常原因&gt;&gt;&quot;+e.getCause().getMessage());
                    bw.newLine();
                }
            }
        }
        bw.write(&quot;本次测试一共出现 &quot;+e_num+&quot; 次异常&quot;);
        bw.newLine();
        bw.flush();
        bw.close();
    }
}

</code></pre>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/f72d98876821e798e96b8728ff0bf827.png" alt="image-20220318161130327" /></p>
<p><img src="https://img-1300594400.cos.ap-shanghai.myqcloud.com/uploads/big/18f70660cfbf601197e9f5a2c85fa2fc.png" alt="image-20220318161502996" /></p>
<h2>小结</h2>
<ol>
<li>大多数时候使用注解而不是自定义注解</li>
<li>注解给谁用：
<ul>
<li>编译器</li>
<li>解析程序（checkTest）</li>
</ul>
</li>
<li>注解不是程序的一部分（相当于C的编译参数，如预编译命令）</li>
</ol>

</div>
</div></body>