<!DOCTYPE html>
<head>
<meta charset="UTF-8" /><title>PureWeb Blog-CVE_2021_3156 sudo堆溢出提权漏洞分析</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>  <script>    document.querySelectorAll('code').forEach((code) => {      if (!code.classList.length) {        code.classList.add('language-bash');      }    });  </script>	<script>		document.addEventListener('DOMContentLoaded', (event) => {			hljs.highlightAll();		});	</script><link rel="stylesheet" href="TestRepo/github.css">
<link rel="stylesheet" href="TestRepo/speciou.css"
</head><body><div class="container"><header class="main-header"><h1 class="main-header__title uplize"><a class="main-header__title__link" href="/TestRepo/">Joe1sn's Cabinet</a></h1><nav class="main-header__nav"><ul class="main-nav"><li class="main-nav__list"><a class="main-nav__list__link active" href="TestRepo/" target="_self">HOME</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="TestRepo/archives/"target="_self">ARCHIVE</a></li><li class="main-nav__list"><a class="main-nav__list__link" href="https://github.com/Joe1sn"target="_blank">GITHUB</a></li></ul></nav></header></div><div id="write" class>
<div id="write" class>
<div class="typora-export os-windows"><div id="write" class>
<p><strong>2022-01-04 20:17:51</strong></p>
<h1>CVE_2021_3156 sudo堆溢出提权漏洞分析</h1>
<h1>简介</h1>
<blockquote>
<p>Sudo before 1.9.5p2 contains an off-by-one error that can result in a heap-based buffer overflow, which allows privilege escalation to root via &quot;sudoedit -s&quot; and a command-line argument that ends with a single backslash character.[1]</p>
</blockquote>
<p>Linux 下 系统管理指令工具sudo存在off by one 漏洞导致堆溢出，可以使普通用户使用<code>sudoedit -s</code>和命令行参数进行提权</p>
<!-- more -->
<p>受影响版本</p>
<p>Sudo 1.8.2 – 1.8.31p2</p>
<p>Sudo 1.9.0 – 1.9.5p1</p>
<p>不受影响版本</p>
<p>sudo =&gt;1.9.5p2</p>
<h1>复现</h1>
<h2>环境</h2>
<p>为了方便使用，这里使用Ubuntu18.04的vm虚拟机</p>
<p><strong>在kali19版本中可以直接提权</strong></p>
<p><img src="https://img.joe1sn.top/uploads/big/c638fdc11e20f640908315c4d0f97bb3.png" alt="" /></p>
<p>[可选]优化gdb调试器</p>
<pre><code class="language-shell">git clone git://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh
</code></pre>
<ul>
<li>
<p><strong>1.</strong> 创建普通用户</p>
<pre><code class="language-shell">useradd -m -r -s /bin/bash test
su passwd test #设置密码
</code></pre>
</li>
<li>
<p><strong>2.</strong> 从源码开始安装</p>
<pre><code class="language-shell">su root
cd /home/test
wget https://www.sudo.ws/dist/sudo-1.8.21.tar.gz #下载源码
tar -zxvf sudo-1.8.21.tar.gz #解压源码
cd sudo-1.8.21
mkdir build
./configure --prefix=/home/test/sudo-1.8.21/build/ --enable-env-debug #配置编译选项
make &amp;&amp; make install #安装
</code></pre>
<p>进入<code>sudo-1.8.21/build/bin</code>，可以看到有漏洞的文件 sudoedit</p>
</li>
<li>
<p><strong>3.</strong> 替换原有sudo和sudoedit（最好先提前备份）</p>
<pre><code class="language-bash">cd build/bin
cp sudo /usr/bin
cp sudoedit /usr/bin
</code></pre>
</li>
<li>
<p><strong>4.</strong> 配置sudo全局变量</p>
<pre><code class="language-shell">cd build/bin
cp sudo /usr/bin
cp sudoedit /usr/bin
chmod 4755 /usr/bin/sudo
chmod 4755 /usr/bin/sudoedit
</code></pre>
<pre><code class="language-shell">su root
sudo passwd test
123
123
</code></pre>
<pre><code class="language-shell">chmod 777 /etc/sudoers
vi /etc/sudoers
</code></pre>
<p><img src="https://img.joe1sn.top/uploads/big/b5eb2a7a30c1195d2cd83597b9453599.png" alt="" /></p>
<pre><code class="language-shell">chmod =r /etc/sudoers
</code></pre>
</li>
<li>
<p><strong>5.</strong> 测试</p>
<pre><code>sudoedit -s 'AAAAA\'
sudoedit -s 'AAAAAAAAAAAAAAAAAAAAAAA\'
</code></pre>
<p><img src="https://img.joe1sn.top/uploads/big/238274ee8b1366a05fb7d0d744dbf35c.png" alt="" /></p>
<p>说明存在漏洞</p>
</li>
</ul>
<h2>使用EXP</h2>
<pre><code class="language-shell">cd /home/test
git clone git://github.com/blasty/CVE-2021-3156
cd CVE-2021-3156
make
</code></pre>
<p>直接按照README.md上的说明操作</p>
<p><img src="https://img.joe1sn.top/uploads/big/c1fe03fb6c0f0854856216a57a4f2a54.png" alt="" /></p>
<p>发现没有打通，开始微调EXP，同时分析漏洞</p>
<h1>漏洞分析</h1>
<h2>入口</h2>
<p>首先从源码一步步分析，具体思路可以参照<a href="https://blog.qualys.com/vulnerabilities-threat-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit">CVE-2021-3156: Heap-Based Buffer Overflow in Sudo (Baron Samedit)</a></p>
<p>这里我使用的就是刚才下载的<strong>sudo-1.8.21</strong>的源代码</p>
<p><img src="https://img.joe1sn.top/uploads/big/509432fd8f57d601ec5df60f449de7e0.png" alt="" /></p>
<p><code>sudoedit</code>就是一个链接到<code>sudo</code>的文件，所以应该尝试先从<code>sudo.c</code>开始分析</p>
<p>因为一般在c中<code>argv[0]</code>代表自生名字，所以应该有个地方判断了自生名字是否为<code>sudoedit</code></p>
<p>可能的代码如下</p>
<pre><code class="language-c">if (!strncmp(argv[0],&quot;sudoedit&quot;,8)){
    execute(sudoedit);
    ....
}
</code></pre>
<p><strong>src/sudo.c</strong></p>
<p><img src="https://img.joe1sn.top/uploads/big/e546a2f6db64bdb2101c60740f419b61.png" alt="" /></p>
<p><strong>src/parse_args.c</strong></p>
<p><img src="https://img.joe1sn.top/uploads/big/debf46957f139cfc887a8b88c19e7c88.png" alt="" /></p>
<p>顺带找到-s选项的相关设置，设置了SHELL_MODE，从而要改写argv</p>
<p><img src="https://img.joe1sn.top/uploads/big/4d6f4eda220beeb913d8a57ca7c34b6c.png" alt="" /></p>
<p>rewrite argv这里注意<code>if</code>中的条件，可以用 <code>'\'</code>替换掉<code>' '</code>空格</p>
<p><img src="https://img.joe1sn.top/uploads/big/31918bc3118bdde6e6a67f09a4a9e426.png" alt="" /></p>
<h2>开始调试</h2>
<p>首先在gdb启动时添加参数：<code> -s 'AAAAAAAAAAAAAAAAAAAAAAA\'</code></p>
<pre><code class="language-shell">set args -s 'AAAAAAAAAAAAAAAAAAAAAAA\'
</code></pre>
<p><img src="https://img.joe1sn.top/uploads/big/99ba7d33f729a16a73f0c1abd48f97a4.png" alt="gdb-1" /></p>
<p>这里要过一个检查</p>
<p><img src="https://img.joe1sn.top/uploads/big/5588ec427ac54b5d0fa8100a96a1d507.png" alt="" /></p>
<p>在<code>test al, al</code>之前把返回结果改为0就行了，这个其实就是检查debug模式的一些选线</p>
<p><img src="https://img.joe1sn.top/uploads/big/c1a4460b177bc6214760a586f1b22ffe.png" alt="gdb-3" /></p>
<p>在<code>parse_args.c</code>下面下断点</p>
<pre><code class="language-shell">b parse_args.c:528
</code></pre>
<p><img src="https://img.joe1sn.top/uploads/big/219bcd670d423cf40137d81fbbf054b6.png" alt="" /></p>
<p>之前这段代码的意思就是进行一些替换，将<code>'\'</code>转义，其他非法字符串替换为空格</p>
<p>后来追踪最后的报错点：<code>sudoers_policy_open</code></p>
<p><img src="https://img.joe1sn.top/uploads/big/6dffaba21188a46803c5e37573338fee.png" alt="" /></p>
<p>[2]可以一步步到最终的漏洞函数 <code>plugins/sudoers/sudoers.c</code> 中的 <code>set_cmnd()</code>函数</p>
<p>删减掉无关代码如下</p>
<pre><code class="language-c">static int
set_cmnd(void)
{
	...
	/* set user_args */
	if (NewArgc &gt; 1) {
	    char *to, *from, **av;
	    size_t size, n;

	    /* Alloc and build up user_args. */
	    for (size = 0, av = NewArgv + 1; *av; av++)
		size += strlen(*av) + 1;
	    if (size == 0 || (user_args = malloc(size)) == NULL) {
		sudo_warnx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;));
		debug_return_int(-1);
	    }
	    if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
		for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
		    while (*from) {
			if (from[0] == '\\' &amp;&amp; !isspace((unsigned char)from[1]))
			    from++;
			*to++ = *from++;
		    }
		    *to++ = ' ';
		}
		*--to = '\0';
	    } else {
		for (to = user_args, av = NewArgv + 1; *av; av++) {
		    n = strlcpy(to, *av, size - (to - user_args));
		    if (n &gt;= size - (to - user_args)) {
			sudo_warnx(U_(&quot;internal error, %s overflow&quot;), __func__);
			debug_return_int(-1);
		    }
		    to += n;
		    *to++ = ' ';
		}
		*--to = '\0';
	    }
	}
    }
	...
}
</code></pre>
<p>漏洞点就在这里，指针复制的时候遇到<code>\</code>跳过，同时复制下一个；之后接着判断，结束后在结尾加上<code>\0</code>。但是如果参数是<code>\</code>结尾的，如<code> -s 'aaaaaaaaaaa\'</code>，就会将数组末尾的<code>\0</code>复制过去，造成内存复制越界，从而 <strong>off by null</strong></p>
<p><img src="https://img.joe1sn.top/uploads/big/e65d7ec4164a492500776f15f57966b8.png" alt="" /></p>
<p>整理得到完整的利用路线</p>
<p><img src="https://img.joe1sn.top/uploads/big/c8b2afaa8bcefcec99179454025b26cb.png" alt="n" /></p>
<p>这里带入&quot;POC&quot;去思考一下</p>
<pre><code class="language-shell">sudoedit -s 'AAAAAAAAAAAAAAAAAAAAAAA\'
</code></pre>
<p><strong>暂时写到这里吧</strong></p>
<p><strong>没有图片与实验</strong></p>
<p>其实这里调试一下就会发现复制到的目的区域存在envp的内容，后面使用root权限执行，所以exp设定好envp参数，就能得到一个root shell实现提权</p>
<p><strong>另外 youtube上面 LiveOverflow也在对这个漏洞进行分析（写fuzz那种级别），有条件的可以去看下</strong></p>
<p>YOUTUBE CHANNELhttps://www.youtube.com/c/LiveOverflow</p>
<p><a href="https://www.youtube.com/watch?v=TLa2VqcGGEQ">How SUDO on Linux was HACKED! // CVE-2021-3156</a></p>
<p><a href="https://www.youtube.com/watch?v=uj1FTiczJSE">Why Pick sudo as Research Target? | Ep. 01</a></p>
<p>..........................................................................</p>
<p><a href="https://www.youtube.com/watch?v=0ti-YgB2iR4">Learning about nss (Linux Name Service Switch) During Sudo Exploitation</a></p>
<h1>引用文章</h1>
<p>[1]<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-3156">CVE-2021-3156</a></p>
<p>[2]<a href="https://blog.qualys.com/vulnerabilities-threat-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit">CVE-2021-3156: Heap-Based Buffer Overflow in Sudo (Baron Samedit)</a></p>
<p>[3]<a href="https://www.sudo.ws/alerts/unescape_overflow.html">Buffer overflow in command line unescaping</a></p>

</div>
</div></body>